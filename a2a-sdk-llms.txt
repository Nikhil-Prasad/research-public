Directory Structure:

└── ./
    └── a2a-python
        ├── scripts
        │   └── grpc_gen_post_processor.py
        ├── src
        │   └── a2a
        │       ├── auth
        │       │   ├── __init__.py
        │       │   └── user.py
        │       ├── client
        │       │   ├── auth
        │       │   │   ├── __init__.py
        │       │   │   ├── credentials.py
        │       │   │   └── interceptor.py
        │       │   ├── transports
        │       │   │   ├── __init__.py
        │       │   │   ├── base.py
        │       │   │   ├── grpc.py
        │       │   │   ├── jsonrpc.py
        │       │   │   └── rest.py
        │       │   ├── __init__.py
        │       │   ├── base_client.py
        │       │   ├── card_resolver.py
        │       │   ├── client_factory.py
        │       │   ├── client_task_manager.py
        │       │   ├── client.py
        │       │   ├── errors.py
        │       │   ├── helpers.py
        │       │   ├── legacy_grpc.py
        │       │   ├── legacy.py
        │       │   ├── middleware.py
        │       │   └── optionals.py
        │       ├── extensions
        │       │   ├── __init__.py
        │       │   └── common.py
        │       ├── grpc
        │       │   ├── __init__.py
        │       │   ├── a2a_pb2_grpc.py
        │       │   └── a2a_pb2.py
        │       ├── server
        │       │   ├── agent_execution
        │       │   │   ├── __init__.py
        │       │   │   ├── agent_executor.py
        │       │   │   ├── context.py
        │       │   │   ├── request_context_builder.py
        │       │   │   └── simple_request_context_builder.py
        │       │   ├── apps
        │       │   │   ├── jsonrpc
        │       │   │   │   ├── __init__.py
        │       │   │   │   ├── fastapi_app.py
        │       │   │   │   ├── jsonrpc_app.py
        │       │   │   │   └── starlette_app.py
        │       │   │   ├── rest
        │       │   │   │   ├── __init__.py
        │       │   │   │   ├── fastapi_app.py
        │       │   │   │   └── rest_adapter.py
        │       │   │   └── __init__.py
        │       │   ├── events
        │       │   │   ├── __init__.py
        │       │   │   ├── event_consumer.py
        │       │   │   ├── event_queue.py
        │       │   │   ├── in_memory_queue_manager.py
        │       │   │   └── queue_manager.py
        │       │   ├── request_handlers
        │       │   │   ├── __init__.py
        │       │   │   ├── default_request_handler.py
        │       │   │   ├── grpc_handler.py
        │       │   │   ├── jsonrpc_handler.py
        │       │   │   ├── request_handler.py
        │       │   │   ├── response_helpers.py
        │       │   │   └── rest_handler.py
        │       │   ├── tasks
        │       │   │   ├── __init__.py
        │       │   │   ├── base_push_notification_sender.py
        │       │   │   ├── database_push_notification_config_store.py
        │       │   │   ├── database_task_store.py
        │       │   │   ├── inmemory_push_notification_config_store.py
        │       │   │   ├── inmemory_task_store.py
        │       │   │   ├── push_notification_config_store.py
        │       │   │   ├── push_notification_sender.py
        │       │   │   ├── result_aggregator.py
        │       │   │   ├── task_manager.py
        │       │   │   ├── task_store.py
        │       │   │   └── task_updater.py
        │       │   ├── __init__.py
        │       │   ├── context.py
        │       │   └── models.py
        │       ├── utils
        │       │   ├── __init__.py
        │       │   ├── artifact.py
        │       │   ├── constants.py
        │       │   ├── error_handlers.py
        │       │   ├── errors.py
        │       │   ├── helpers.py
        │       │   ├── message.py
        │       │   ├── proto_utils.py
        │       │   ├── task.py
        │       │   └── telemetry.py
        │       ├── __init__.py
        │       ├── _base.py
        │       └── types.py
        └── tests
            ├── auth
            │   └── test_user.py
            ├── client
            │   ├── test_auth_middleware.py
            │   ├── test_base_client.py
            │   ├── test_client_factory.py
            │   ├── test_client_task_manager.py
            │   ├── test_errors.py
            │   ├── test_grpc_client.py
            │   ├── test_jsonrpc_client.py
            │   ├── test_legacy_client.py
            │   └── test_optionals.py
            ├── extensions
            │   └── test_common.py
            ├── integration
            │   └── test_client_server_integration.py
            ├── server
            │   ├── agent_execution
            │   │   ├── test_context.py
            │   │   └── test_simple_request_context_builder.py
            │   ├── apps
            │   │   ├── jsonrpc
            │   │   │   ├── test_fastapi_app.py
            │   │   │   ├── test_jsonrpc_app.py
            │   │   │   ├── test_serialization.py
            │   │   │   └── test_starlette_app.py
            │   │   └── rest
            │   │       └── test_rest_fastapi_app.py
            │   ├── events
            │   │   ├── test_event_consumer.py
            │   │   ├── test_event_queue.py
            │   │   └── test_inmemory_queue_manager.py
            │   ├── request_handlers
            │   │   ├── test_default_request_handler.py
            │   │   ├── test_grpc_handler.py
            │   │   ├── test_jsonrpc_handler.py
            │   │   └── test_response_helpers.py
            │   ├── tasks
            │   │   ├── test_database_push_notification_config_store.py
            │   │   ├── test_database_task_store.py
            │   │   ├── test_inmemory_push_notifications.py
            │   │   ├── test_inmemory_task_store.py
            │   │   ├── test_push_notification_sender.py
            │   │   ├── test_result_aggregator.py
            │   │   ├── test_task_manager.py
            │   │   └── test_task_updater.py
            │   ├── test_integration.py
            │   └── test_models.py
            ├── utils
            │   ├── test_artifact.py
            │   ├── test_constants.py
            │   ├── test_error_handlers.py
            │   ├── test_helpers.py
            │   ├── test_message.py
            │   ├── test_proto_utils.py
            │   ├── test_task.py
            │   └── test_telemetry.py
            └── test_types.py



---
File: /a2a-python/scripts/grpc_gen_post_processor.py
---

"""Fix absolute imports in *_pb2_grpc.py files.

Example:
import a2a_pb2 as a2a__pb2
from . import a2a_pb2 as a2a__pb2
"""

import re
import sys

from pathlib import Path


def process_generated_code(src_folder: str = 'src/a2a/grpc') -> None:
    """Post processor for the generated code."""
    dir_path = Path(src_folder)
    print(dir_path)
    if not dir_path.is_dir():
        print('Source folder not found')
        sys.exit(1)

    grpc_pattern = '**/*_pb2_grpc.py'
    files = dir_path.glob(grpc_pattern)

    for file in files:
        print(f'Processing {file}')
        try:
            with file.open('r', encoding='utf-8') as f:
                src_content = f.read()

                # Change import a2a_pb2 as a2a__pb2
                import_pattern = r'^import (\w+_pb2) as (\w+__pb2)$'
                # to from . import a2a_pb2 as a2a__pb2
                replacement_pattern = r'from . import \1 as \2'

                fixed_src_content = re.sub(
                    import_pattern,
                    replacement_pattern,
                    src_content,
                    flags=re.MULTILINE,
                )

            if fixed_src_content != src_content:
                with file.open('w', encoding='utf-8') as f:
                    f.write(fixed_src_content)
                    print('Imports fixed')
            else:
                print('No changes needed')

        except Exception as e:  # noqa: BLE001
            print(f'Error processing file {file}: {e}')
            sys.exit(1)


if __name__ == '__main__':
    process_generated_code()



---
File: /a2a-python/src/a2a/auth/__init__.py
---




---
File: /a2a-python/src/a2a/auth/user.py
---

"""Authenticated user information."""

from abc import ABC, abstractmethod


class User(ABC):
    """A representation of an authenticated user."""

    @property
    @abstractmethod
    def is_authenticated(self) -> bool:
        """Returns whether the current user is authenticated."""

    @property
    @abstractmethod
    def user_name(self) -> str:
        """Returns the user name of the current user."""


class UnauthenticatedUser(User):
    """A representation that no user has been authenticated in the request."""

    @property
    def is_authenticated(self) -> bool:
        """Returns whether the current user is authenticated."""
        return False

    @property
    def user_name(self) -> str:
        """Returns the user name of the current user."""
        return ''



---
File: /a2a-python/src/a2a/client/auth/__init__.py
---

"""Client-side authentication components for the A2A Python SDK."""

from a2a.client.auth.credentials import (
    CredentialService,
    InMemoryContextCredentialStore,
)
from a2a.client.auth.interceptor import AuthInterceptor


__all__ = [
    'AuthInterceptor',
    'CredentialService',
    'InMemoryContextCredentialStore',
]



---
File: /a2a-python/src/a2a/client/auth/credentials.py
---

from abc import ABC, abstractmethod

from a2a.client.middleware import ClientCallContext


class CredentialService(ABC):
    """An abstract service for retrieving credentials."""

    @abstractmethod
    async def get_credentials(
        self,
        security_scheme_name: str,
        context: ClientCallContext | None,
    ) -> str | None:
        """
        Retrieves a credential (e.g., token) for a security scheme.
        """


class InMemoryContextCredentialStore(CredentialService):
    """A simple in-memory store for session-keyed credentials.

    This class uses the 'sessionId' from the ClientCallContext state to
    store and retrieve credentials...
    """

    def __init__(self) -> None:
        self._store: dict[str, dict[str, str]] = {}

    async def get_credentials(
        self,
        security_scheme_name: str,
        context: ClientCallContext | None,
    ) -> str | None:
        """Retrieves credentials from the in-memory store.

        Args:
            security_scheme_name: The name of the security scheme.
            context: The client call context.

        Returns:
            The credential string, or None if not found.
        """
        if not context or 'sessionId' not in context.state:
            return None
        session_id = context.state['sessionId']
        return self._store.get(session_id, {}).get(security_scheme_name)

    async def set_credentials(
        self, session_id: str, security_scheme_name: str, credential: str
    ) -> None:
        """Method to populate the store."""
        if session_id not in self._store:
            self._store[session_id] = {}
        self._store[session_id][security_scheme_name] = credential



---
File: /a2a-python/src/a2a/client/auth/interceptor.py
---

import logging  # noqa: I001
from typing import Any

from a2a.client.auth.credentials import CredentialService
from a2a.client.middleware import ClientCallContext, ClientCallInterceptor
from a2a.types import (
    AgentCard,
    APIKeySecurityScheme,
    HTTPAuthSecurityScheme,
    In,
    OAuth2SecurityScheme,
    OpenIdConnectSecurityScheme,
)

logger = logging.getLogger(__name__)


class AuthInterceptor(ClientCallInterceptor):
    """An interceptor that automatically adds authentication details to requests.

    Based on the agent's security schemes.
    """

    def __init__(self, credential_service: CredentialService):
        self._credential_service = credential_service

    async def intercept(
        self,
        method_name: str,
        request_payload: dict[str, Any],
        http_kwargs: dict[str, Any],
        agent_card: AgentCard | None,
        context: ClientCallContext | None,
    ) -> tuple[dict[str, Any], dict[str, Any]]:
        """Applies authentication headers to the request if credentials are available."""
        if (
            agent_card is None
            or agent_card.security is None
            or agent_card.security_schemes is None
        ):
            return request_payload, http_kwargs

        for requirement in agent_card.security:
            for scheme_name in requirement:
                credential = await self._credential_service.get_credentials(
                    scheme_name, context
                )
                if credential and scheme_name in agent_card.security_schemes:
                    scheme_def_union = agent_card.security_schemes.get(
                        scheme_name
                    )
                    if not scheme_def_union:
                        continue
                    scheme_def = scheme_def_union.root

                    headers = http_kwargs.get('headers', {})

                    match scheme_def:
                        # Case 1a: HTTP Bearer scheme with an if guard
                        case HTTPAuthSecurityScheme() if (
                            scheme_def.scheme.lower() == 'bearer'
                        ):
                            headers['Authorization'] = f'Bearer {credential}'
                            logger.debug(
                                f"Added Bearer token for scheme '{scheme_name}' (type: {scheme_def.type})."
                            )
                            http_kwargs['headers'] = headers
                            return request_payload, http_kwargs

                        # Case 1b: OAuth2 and OIDC schemes, which are implicitly Bearer
                        case (
                            OAuth2SecurityScheme()
                            | OpenIdConnectSecurityScheme()
                        ):
                            headers['Authorization'] = f'Bearer {credential}'
                            logger.debug(
                                f"Added Bearer token for scheme '{scheme_name}' (type: {scheme_def.type})."
                            )
                            http_kwargs['headers'] = headers
                            return request_payload, http_kwargs

                        # Case 2: API Key in Header
                        case APIKeySecurityScheme(in_=In.header):
                            headers[scheme_def.name] = credential
                            logger.debug(
                                f"Added API Key Header for scheme '{scheme_name}'."
                            )
                            http_kwargs['headers'] = headers
                            return request_payload, http_kwargs

                # Note: Other cases like API keys in query/cookie are not handled and will be skipped.

        return request_payload, http_kwargs



---
File: /a2a-python/src/a2a/client/transports/__init__.py
---

"""A2A Client Transports."""

from a2a.client.transports.base import ClientTransport
from a2a.client.transports.jsonrpc import JsonRpcTransport
from a2a.client.transports.rest import RestTransport


try:
    from a2a.client.transports.grpc import GrpcTransport
except ImportError:
    GrpcTransport = None  # type: ignore


__all__ = [
    'ClientTransport',
    'GrpcTransport',
    'JsonRpcTransport',
    'RestTransport',
]



---
File: /a2a-python/src/a2a/client/transports/base.py
---

from abc import ABC, abstractmethod
from collections.abc import AsyncGenerator

from a2a.client.middleware import ClientCallContext
from a2a.types import (
    AgentCard,
    GetTaskPushNotificationConfigParams,
    Message,
    MessageSendParams,
    Task,
    TaskArtifactUpdateEvent,
    TaskIdParams,
    TaskPushNotificationConfig,
    TaskQueryParams,
    TaskStatusUpdateEvent,
)


class ClientTransport(ABC):
    """Abstract base class for a client transport."""

    @abstractmethod
    async def send_message(
        self,
        request: MessageSendParams,
        *,
        context: ClientCallContext | None = None,
    ) -> Task | Message:
        """Sends a non-streaming message request to the agent."""

    @abstractmethod
    async def send_message_streaming(
        self,
        request: MessageSendParams,
        *,
        context: ClientCallContext | None = None,
    ) -> AsyncGenerator[
        Message | Task | TaskStatusUpdateEvent | TaskArtifactUpdateEvent
    ]:
        """Sends a streaming message request to the agent and yields responses as they arrive."""
        return
        yield

    @abstractmethod
    async def get_task(
        self,
        request: TaskQueryParams,
        *,
        context: ClientCallContext | None = None,
    ) -> Task:
        """Retrieves the current state and history of a specific task."""

    @abstractmethod
    async def cancel_task(
        self,
        request: TaskIdParams,
        *,
        context: ClientCallContext | None = None,
    ) -> Task:
        """Requests the agent to cancel a specific task."""

    @abstractmethod
    async def set_task_callback(
        self,
        request: TaskPushNotificationConfig,
        *,
        context: ClientCallContext | None = None,
    ) -> TaskPushNotificationConfig:
        """Sets or updates the push notification configuration for a specific task."""

    @abstractmethod
    async def get_task_callback(
        self,
        request: GetTaskPushNotificationConfigParams,
        *,
        context: ClientCallContext | None = None,
    ) -> TaskPushNotificationConfig:
        """Retrieves the push notification configuration for a specific task."""

    @abstractmethod
    async def resubscribe(
        self,
        request: TaskIdParams,
        *,
        context: ClientCallContext | None = None,
    ) -> AsyncGenerator[
        Task | Message | TaskStatusUpdateEvent | TaskArtifactUpdateEvent
    ]:
        """Reconnects to get task updates."""
        return
        yield

    @abstractmethod
    async def get_card(
        self,
        *,
        context: ClientCallContext | None = None,
    ) -> AgentCard:
        """Retrieves the AgentCard."""

    @abstractmethod
    async def close(self) -> None:
        """Closes the transport."""



---
File: /a2a-python/src/a2a/client/transports/grpc.py
---

import logging

from collections.abc import AsyncGenerator


try:
    import grpc
except ImportError as e:
    raise ImportError(
        'A2AGrpcClient requires grpcio and grpcio-tools to be installed. '
        'Install with: '
        "'pip install a2a-sdk[grpc]'"
    ) from e

from a2a.client.client import ClientConfig
from a2a.client.middleware import ClientCallContext, ClientCallInterceptor
from a2a.client.optionals import Channel
from a2a.client.transports.base import ClientTransport
from a2a.grpc import a2a_pb2, a2a_pb2_grpc
from a2a.types import (
    AgentCard,
    GetTaskPushNotificationConfigParams,
    Message,
    MessageSendParams,
    Task,
    TaskArtifactUpdateEvent,
    TaskIdParams,
    TaskPushNotificationConfig,
    TaskQueryParams,
    TaskStatusUpdateEvent,
)
from a2a.utils import proto_utils
from a2a.utils.telemetry import SpanKind, trace_class


logger = logging.getLogger(__name__)


@trace_class(kind=SpanKind.CLIENT)
class GrpcTransport(ClientTransport):
    """A gRPC transport for the A2A client."""

    def __init__(
        self,
        channel: Channel,
        agent_card: AgentCard | None,
    ):
        """Initializes the GrpcTransport."""
        self.agent_card = agent_card
        self.channel = channel
        self.stub = a2a_pb2_grpc.A2AServiceStub(channel)
        self._needs_extended_card = (
            agent_card.supports_authenticated_extended_card
            if agent_card
            else True
        )

    @classmethod
    def create(
        cls,
        card: AgentCard,
        url: str,
        config: ClientConfig,
        interceptors: list[ClientCallInterceptor],
    ) -> 'GrpcTransport':
        """Creates a gRPC transport for the A2A client."""
        if config.grpc_channel_factory is None:
            raise ValueError('grpc_channel_factory is required when using gRPC')
        return cls(
            config.grpc_channel_factory(url),
            card,
        )

    async def send_message(
        self,
        request: MessageSendParams,
        *,
        context: ClientCallContext | None = None,
    ) -> Task | Message:
        """Sends a non-streaming message request to the agent."""
        response = await self.stub.SendMessage(
            a2a_pb2.SendMessageRequest(
                request=proto_utils.ToProto.message(request.message),
                configuration=proto_utils.ToProto.message_send_configuration(
                    request.configuration
                ),
                metadata=proto_utils.ToProto.metadata(request.metadata),
            )
        )
        if response.HasField('task'):
            return proto_utils.FromProto.task(response.task)
        return proto_utils.FromProto.message(response.msg)

    async def send_message_streaming(
        self,
        request: MessageSendParams,
        *,
        context: ClientCallContext | None = None,
    ) -> AsyncGenerator[
        Message | Task | TaskStatusUpdateEvent | TaskArtifactUpdateEvent
    ]:
        """Sends a streaming message request to the agent and yields responses as they arrive."""
        stream = self.stub.SendStreamingMessage(
            a2a_pb2.SendMessageRequest(
                request=proto_utils.ToProto.message(request.message),
                configuration=proto_utils.ToProto.message_send_configuration(
                    request.configuration
                ),
                metadata=proto_utils.ToProto.metadata(request.metadata),
            )
        )
        while True:
            response = await stream.read()
            if response == grpc.aio.EOF:  # pyright: ignore[reportAttributeAccessIssue]
                break
            yield proto_utils.FromProto.stream_response(response)

    async def resubscribe(
        self, request: TaskIdParams, *, context: ClientCallContext | None = None
    ) -> AsyncGenerator[
        Task | Message | TaskStatusUpdateEvent | TaskArtifactUpdateEvent
    ]:
        """Reconnects to get task updates."""
        stream = self.stub.TaskSubscription(
            a2a_pb2.TaskSubscriptionRequest(name=f'tasks/{request.id}')
        )
        while True:
            response = await stream.read()
            if response == grpc.aio.EOF:  # pyright: ignore[reportAttributeAccessIssue]
                break
            yield proto_utils.FromProto.stream_response(response)

    async def get_task(
        self,
        request: TaskQueryParams,
        *,
        context: ClientCallContext | None = None,
    ) -> Task:
        """Retrieves the current state and history of a specific task."""
        task = await self.stub.GetTask(
            a2a_pb2.GetTaskRequest(
                name=f'tasks/{request.id}',
                history_length=request.history_length,
            )
        )
        return proto_utils.FromProto.task(task)

    async def cancel_task(
        self,
        request: TaskIdParams,
        *,
        context: ClientCallContext | None = None,
    ) -> Task:
        """Requests the agent to cancel a specific task."""
        task = await self.stub.CancelTask(
            a2a_pb2.CancelTaskRequest(name=f'tasks/{request.id}')
        )
        return proto_utils.FromProto.task(task)

    async def set_task_callback(
        self,
        request: TaskPushNotificationConfig,
        *,
        context: ClientCallContext | None = None,
    ) -> TaskPushNotificationConfig:
        """Sets or updates the push notification configuration for a specific task."""
        config = await self.stub.CreateTaskPushNotificationConfig(
            a2a_pb2.CreateTaskPushNotificationConfigRequest(
                parent=f'tasks/{request.task_id}',
                config_id=request.push_notification_config.id,
                config=proto_utils.ToProto.task_push_notification_config(
                    request
                ),
            )
        )
        return proto_utils.FromProto.task_push_notification_config(config)

    async def get_task_callback(
        self,
        request: GetTaskPushNotificationConfigParams,
        *,
        context: ClientCallContext | None = None,
    ) -> TaskPushNotificationConfig:
        """Retrieves the push notification configuration for a specific task."""
        config = await self.stub.GetTaskPushNotificationConfig(
            a2a_pb2.GetTaskPushNotificationConfigRequest(
                name=f'tasks/{request.id}/pushNotificationConfigs/{request.push_notification_config_id}',
            )
        )
        return proto_utils.FromProto.task_push_notification_config(config)

    async def get_card(
        self,
        *,
        context: ClientCallContext | None = None,
    ) -> AgentCard:
        """Retrieves the agent's card."""
        card = self.agent_card
        if card and not self._needs_extended_card:
            return card
        if card is None and not self._needs_extended_card:
            raise ValueError('Agent card is not available.')

        card_pb = await self.stub.GetAgentCard(
            a2a_pb2.GetAgentCardRequest(),
        )
        card = proto_utils.FromProto.agent_card(card_pb)
        self.agent_card = card
        self._needs_extended_card = False
        return card

    async def close(self) -> None:
        """Closes the gRPC channel."""
        await self.channel.close()



---
File: /a2a-python/src/a2a/client/transports/jsonrpc.py
---

import json
import logging

from collections.abc import AsyncGenerator
from typing import Any
from uuid import uuid4

import httpx

from httpx_sse import SSEError, aconnect_sse

from a2a.client.card_resolver import A2ACardResolver
from a2a.client.errors import (
    A2AClientHTTPError,
    A2AClientJSONError,
    A2AClientJSONRPCError,
    A2AClientTimeoutError,
)
from a2a.client.middleware import ClientCallContext, ClientCallInterceptor
from a2a.client.transports.base import ClientTransport
from a2a.types import (
    AgentCard,
    CancelTaskRequest,
    CancelTaskResponse,
    GetAuthenticatedExtendedCardRequest,
    GetAuthenticatedExtendedCardResponse,
    GetTaskPushNotificationConfigParams,
    GetTaskPushNotificationConfigRequest,
    GetTaskPushNotificationConfigResponse,
    GetTaskRequest,
    GetTaskResponse,
    JSONRPCErrorResponse,
    Message,
    MessageSendParams,
    SendMessageRequest,
    SendMessageResponse,
    SendStreamingMessageRequest,
    SendStreamingMessageResponse,
    SetTaskPushNotificationConfigRequest,
    SetTaskPushNotificationConfigResponse,
    Task,
    TaskArtifactUpdateEvent,
    TaskIdParams,
    TaskPushNotificationConfig,
    TaskQueryParams,
    TaskResubscriptionRequest,
    TaskStatusUpdateEvent,
)
from a2a.utils.telemetry import SpanKind, trace_class


logger = logging.getLogger(__name__)


@trace_class(kind=SpanKind.CLIENT)
class JsonRpcTransport(ClientTransport):
    """A JSON-RPC transport for the A2A client."""

    def __init__(
        self,
        httpx_client: httpx.AsyncClient,
        agent_card: AgentCard | None = None,
        url: str | None = None,
        interceptors: list[ClientCallInterceptor] | None = None,
    ):
        """Initializes the JsonRpcTransport."""
        if url:
            self.url = url
        elif agent_card:
            self.url = agent_card.url
        else:
            raise ValueError('Must provide either agent_card or url')

        self.httpx_client = httpx_client
        self.agent_card = agent_card
        self.interceptors = interceptors or []
        self._needs_extended_card = (
            agent_card.supports_authenticated_extended_card
            if agent_card
            else True
        )

    async def _apply_interceptors(
        self,
        method_name: str,
        request_payload: dict[str, Any],
        http_kwargs: dict[str, Any] | None,
        context: ClientCallContext | None,
    ) -> tuple[dict[str, Any], dict[str, Any]]:
        final_http_kwargs = http_kwargs or {}
        final_request_payload = request_payload

        for interceptor in self.interceptors:
            (
                final_request_payload,
                final_http_kwargs,
            ) = await interceptor.intercept(
                method_name,
                final_request_payload,
                final_http_kwargs,
                self.agent_card,
                context,
            )
        return final_request_payload, final_http_kwargs

    def _get_http_args(
        self, context: ClientCallContext | None
    ) -> dict[str, Any] | None:
        return context.state.get('http_kwargs') if context else None

    async def send_message(
        self,
        request: MessageSendParams,
        *,
        context: ClientCallContext | None = None,
    ) -> Task | Message:
        """Sends a non-streaming message request to the agent."""
        rpc_request = SendMessageRequest(params=request, id=str(uuid4()))
        payload, modified_kwargs = await self._apply_interceptors(
            'message/send',
            rpc_request.model_dump(mode='json', exclude_none=True),
            self._get_http_args(context),
            context,
        )
        response_data = await self._send_request(payload, modified_kwargs)
        response = SendMessageResponse.model_validate(response_data)
        if isinstance(response.root, JSONRPCErrorResponse):
            raise A2AClientJSONRPCError(response.root)
        return response.root.result

    async def send_message_streaming(
        self,
        request: MessageSendParams,
        *,
        context: ClientCallContext | None = None,
    ) -> AsyncGenerator[
        Message | Task | TaskStatusUpdateEvent | TaskArtifactUpdateEvent
    ]:
        """Sends a streaming message request to the agent and yields responses as they arrive."""
        rpc_request = SendStreamingMessageRequest(
            params=request, id=str(uuid4())
        )
        payload, modified_kwargs = await self._apply_interceptors(
            'message/stream',
            rpc_request.model_dump(mode='json', exclude_none=True),
            self._get_http_args(context),
            context,
        )

        modified_kwargs.setdefault('timeout', None)

        async with aconnect_sse(
            self.httpx_client,
            'POST',
            self.url,
            json=payload,
            **modified_kwargs,
        ) as event_source:
            try:
                async for sse in event_source.aiter_sse():
                    response = SendStreamingMessageResponse.model_validate(
                        json.loads(sse.data)
                    )
                    if isinstance(response.root, JSONRPCErrorResponse):
                        raise A2AClientJSONRPCError(response.root)
                    yield response.root.result
            except SSEError as e:
                raise A2AClientHTTPError(
                    400, f'Invalid SSE response or protocol error: {e}'
                ) from e
            except json.JSONDecodeError as e:
                raise A2AClientJSONError(str(e)) from e
            except httpx.RequestError as e:
                raise A2AClientHTTPError(
                    503, f'Network communication error: {e}'
                ) from e

    async def _send_request(
        self,
        rpc_request_payload: dict[str, Any],
        http_kwargs: dict[str, Any] | None = None,
    ) -> dict[str, Any]:
        try:
            response = await self.httpx_client.post(
                self.url, json=rpc_request_payload, **(http_kwargs or {})
            )
            response.raise_for_status()
            return response.json()
        except httpx.ReadTimeout as e:
            raise A2AClientTimeoutError('Client Request timed out') from e
        except httpx.HTTPStatusError as e:
            raise A2AClientHTTPError(e.response.status_code, str(e)) from e
        except json.JSONDecodeError as e:
            raise A2AClientJSONError(str(e)) from e
        except httpx.RequestError as e:
            raise A2AClientHTTPError(
                503, f'Network communication error: {e}'
            ) from e

    async def get_task(
        self,
        request: TaskQueryParams,
        *,
        context: ClientCallContext | None = None,
    ) -> Task:
        """Retrieves the current state and history of a specific task."""
        rpc_request = GetTaskRequest(params=request, id=str(uuid4()))
        payload, modified_kwargs = await self._apply_interceptors(
            'tasks/get',
            rpc_request.model_dump(mode='json', exclude_none=True),
            self._get_http_args(context),
            context,
        )
        response_data = await self._send_request(payload, modified_kwargs)
        response = GetTaskResponse.model_validate(response_data)
        if isinstance(response.root, JSONRPCErrorResponse):
            raise A2AClientJSONRPCError(response.root)
        return response.root.result

    async def cancel_task(
        self,
        request: TaskIdParams,
        *,
        context: ClientCallContext | None = None,
    ) -> Task:
        """Requests the agent to cancel a specific task."""
        rpc_request = CancelTaskRequest(params=request, id=str(uuid4()))
        payload, modified_kwargs = await self._apply_interceptors(
            'tasks/cancel',
            rpc_request.model_dump(mode='json', exclude_none=True),
            self._get_http_args(context),
            context,
        )
        response_data = await self._send_request(payload, modified_kwargs)
        response = CancelTaskResponse.model_validate(response_data)
        if isinstance(response.root, JSONRPCErrorResponse):
            raise A2AClientJSONRPCError(response.root)
        return response.root.result

    async def set_task_callback(
        self,
        request: TaskPushNotificationConfig,
        *,
        context: ClientCallContext | None = None,
    ) -> TaskPushNotificationConfig:
        """Sets or updates the push notification configuration for a specific task."""
        rpc_request = SetTaskPushNotificationConfigRequest(
            params=request, id=str(uuid4())
        )
        payload, modified_kwargs = await self._apply_interceptors(
            'tasks/pushNotificationConfig/set',
            rpc_request.model_dump(mode='json', exclude_none=True),
            self._get_http_args(context),
            context,
        )
        response_data = await self._send_request(payload, modified_kwargs)
        response = SetTaskPushNotificationConfigResponse.model_validate(
            response_data
        )
        if isinstance(response.root, JSONRPCErrorResponse):
            raise A2AClientJSONRPCError(response.root)
        return response.root.result

    async def get_task_callback(
        self,
        request: GetTaskPushNotificationConfigParams,
        *,
        context: ClientCallContext | None = None,
    ) -> TaskPushNotificationConfig:
        """Retrieves the push notification configuration for a specific task."""
        rpc_request = GetTaskPushNotificationConfigRequest(
            params=request, id=str(uuid4())
        )
        payload, modified_kwargs = await self._apply_interceptors(
            'tasks/pushNotificationConfig/get',
            rpc_request.model_dump(mode='json', exclude_none=True),
            self._get_http_args(context),
            context,
        )
        response_data = await self._send_request(payload, modified_kwargs)
        response = GetTaskPushNotificationConfigResponse.model_validate(
            response_data
        )
        if isinstance(response.root, JSONRPCErrorResponse):
            raise A2AClientJSONRPCError(response.root)
        return response.root.result

    async def resubscribe(
        self,
        request: TaskIdParams,
        *,
        context: ClientCallContext | None = None,
    ) -> AsyncGenerator[
        Task | Message | TaskStatusUpdateEvent | TaskArtifactUpdateEvent
    ]:
        """Reconnects to get task updates."""
        rpc_request = TaskResubscriptionRequest(params=request, id=str(uuid4()))
        payload, modified_kwargs = await self._apply_interceptors(
            'tasks/resubscribe',
            rpc_request.model_dump(mode='json', exclude_none=True),
            self._get_http_args(context),
            context,
        )

        modified_kwargs.setdefault('timeout', None)

        async with aconnect_sse(
            self.httpx_client,
            'POST',
            self.url,
            json=payload,
            **modified_kwargs,
        ) as event_source:
            try:
                async for sse in event_source.aiter_sse():
                    response = SendStreamingMessageResponse.model_validate_json(
                        sse.data
                    )
                    if isinstance(response.root, JSONRPCErrorResponse):
                        raise A2AClientJSONRPCError(response.root)
                    yield response.root.result
            except SSEError as e:
                raise A2AClientHTTPError(
                    400, f'Invalid SSE response or protocol error: {e}'
                ) from e
            except json.JSONDecodeError as e:
                raise A2AClientJSONError(str(e)) from e
            except httpx.RequestError as e:
                raise A2AClientHTTPError(
                    503, f'Network communication error: {e}'
                ) from e

    async def get_card(
        self,
        *,
        context: ClientCallContext | None = None,
    ) -> AgentCard:
        """Retrieves the agent's card."""
        card = self.agent_card
        if not card:
            resolver = A2ACardResolver(self.httpx_client, self.url)
            card = await resolver.get_agent_card(
                http_kwargs=self._get_http_args(context)
            )
            self._needs_extended_card = (
                card.supports_authenticated_extended_card
            )
            self.agent_card = card

        if not self._needs_extended_card:
            return card

        request = GetAuthenticatedExtendedCardRequest(id=str(uuid4()))
        payload, modified_kwargs = await self._apply_interceptors(
            request.method,
            request.model_dump(mode='json', exclude_none=True),
            self._get_http_args(context),
            context,
        )

        response_data = await self._send_request(
            payload,
            modified_kwargs,
        )
        response = GetAuthenticatedExtendedCardResponse.model_validate(
            response_data
        )
        if isinstance(response.root, JSONRPCErrorResponse):
            raise A2AClientJSONRPCError(response.root)
        self.agent_card = response.root.result
        self._needs_extended_card = False
        return card

    async def close(self) -> None:
        """Closes the httpx client."""
        await self.httpx_client.aclose()



---
File: /a2a-python/src/a2a/client/transports/rest.py
---

import json
import logging

from collections.abc import AsyncGenerator
from typing import Any

import httpx

from google.protobuf.json_format import MessageToDict, Parse, ParseDict
from httpx_sse import SSEError, aconnect_sse

from a2a.client.card_resolver import A2ACardResolver
from a2a.client.errors import A2AClientHTTPError, A2AClientJSONError
from a2a.client.middleware import ClientCallContext, ClientCallInterceptor
from a2a.client.transports.base import ClientTransport
from a2a.grpc import a2a_pb2
from a2a.types import (
    AgentCard,
    GetTaskPushNotificationConfigParams,
    Message,
    MessageSendParams,
    Task,
    TaskArtifactUpdateEvent,
    TaskIdParams,
    TaskPushNotificationConfig,
    TaskQueryParams,
    TaskStatusUpdateEvent,
)
from a2a.utils import proto_utils
from a2a.utils.telemetry import SpanKind, trace_class


logger = logging.getLogger(__name__)


@trace_class(kind=SpanKind.CLIENT)
class RestTransport(ClientTransport):
    """A REST transport for the A2A client."""

    def __init__(
        self,
        httpx_client: httpx.AsyncClient,
        agent_card: AgentCard | None = None,
        url: str | None = None,
        interceptors: list[ClientCallInterceptor] | None = None,
    ):
        """Initializes the RestTransport."""
        if url:
            self.url = url
        elif agent_card:
            self.url = agent_card.url
        else:
            raise ValueError('Must provide either agent_card or url')
        if self.url.endswith('/'):
            self.url = self.url[:-1]
        self.httpx_client = httpx_client
        self.agent_card = agent_card
        self.interceptors = interceptors or []
        self._needs_extended_card = (
            agent_card.supports_authenticated_extended_card
            if agent_card
            else True
        )

    async def _apply_interceptors(
        self,
        request_payload: dict[str, Any],
        http_kwargs: dict[str, Any] | None,
        context: ClientCallContext | None,
    ) -> tuple[dict[str, Any], dict[str, Any]]:
        final_http_kwargs = http_kwargs or {}
        final_request_payload = request_payload
        # TODO: Implement interceptors for other transports
        return final_request_payload, final_http_kwargs

    def _get_http_args(
        self, context: ClientCallContext | None
    ) -> dict[str, Any] | None:
        return context.state.get('http_kwargs') if context else None

    async def _prepare_send_message(
        self, request: MessageSendParams, context: ClientCallContext | None
    ) -> tuple[dict[str, Any], dict[str, Any]]:
        pb = a2a_pb2.SendMessageRequest(
            request=proto_utils.ToProto.message(request.message),
            configuration=proto_utils.ToProto.message_send_configuration(
                request.configuration
            ),
            metadata=(
                proto_utils.ToProto.metadata(request.metadata)
                if request.metadata
                else None
            ),
        )
        payload = MessageToDict(pb)
        payload, modified_kwargs = await self._apply_interceptors(
            payload,
            self._get_http_args(context),
            context,
        )
        return payload, modified_kwargs

    async def send_message(
        self,
        request: MessageSendParams,
        *,
        context: ClientCallContext | None = None,
    ) -> Task | Message:
        """Sends a non-streaming message request to the agent."""
        payload, modified_kwargs = await self._prepare_send_message(
            request, context
        )
        response_data = await self._send_post_request(
            '/v1/message:send', payload, modified_kwargs
        )
        response_pb = a2a_pb2.SendMessageResponse()
        ParseDict(response_data, response_pb)
        return proto_utils.FromProto.task_or_message(response_pb)

    async def send_message_streaming(
        self,
        request: MessageSendParams,
        *,
        context: ClientCallContext | None = None,
    ) -> AsyncGenerator[
        Task | TaskStatusUpdateEvent | TaskArtifactUpdateEvent | Message
    ]:
        """Sends a streaming message request to the agent and yields responses as they arrive."""
        payload, modified_kwargs = await self._prepare_send_message(
            request, context
        )

        modified_kwargs.setdefault('timeout', None)

        async with aconnect_sse(
            self.httpx_client,
            'POST',
            f'{self.url}/v1/message:stream',
            json=payload,
            **modified_kwargs,
        ) as event_source:
            try:
                async for sse in event_source.aiter_sse():
                    event = a2a_pb2.StreamResponse()
                    Parse(sse.data, event)
                    yield proto_utils.FromProto.stream_response(event)
            except SSEError as e:
                raise A2AClientHTTPError(
                    400, f'Invalid SSE response or protocol error: {e}'
                ) from e
            except json.JSONDecodeError as e:
                raise A2AClientJSONError(str(e)) from e
            except httpx.RequestError as e:
                raise A2AClientHTTPError(
                    503, f'Network communication error: {e}'
                ) from e

    async def _send_request(self, request: httpx.Request) -> dict[str, Any]:
        try:
            response = await self.httpx_client.send(request)
            response.raise_for_status()
            return response.json()
        except httpx.HTTPStatusError as e:
            raise A2AClientHTTPError(e.response.status_code, str(e)) from e
        except json.JSONDecodeError as e:
            raise A2AClientJSONError(str(e)) from e
        except httpx.RequestError as e:
            raise A2AClientHTTPError(
                503, f'Network communication error: {e}'
            ) from e

    async def _send_post_request(
        self,
        target: str,
        rpc_request_payload: dict[str, Any],
        http_kwargs: dict[str, Any] | None = None,
    ) -> dict[str, Any]:
        return await self._send_request(
            self.httpx_client.build_request(
                'POST',
                f'{self.url}{target}',
                json=rpc_request_payload,
                **(http_kwargs or {}),
            )
        )

    async def _send_get_request(
        self,
        target: str,
        query_params: dict[str, str],
        http_kwargs: dict[str, Any] | None = None,
    ) -> dict[str, Any]:
        return await self._send_request(
            self.httpx_client.build_request(
                'GET',
                f'{self.url}{target}',
                params=query_params,
                **(http_kwargs or {}),
            )
        )

    async def get_task(
        self,
        request: TaskQueryParams,
        *,
        context: ClientCallContext | None = None,
    ) -> Task:
        """Retrieves the current state and history of a specific task."""
        payload, modified_kwargs = await self._apply_interceptors(
            request.model_dump(mode='json', exclude_none=True),
            self._get_http_args(context),
            context,
        )
        response_data = await self._send_get_request(
            f'/v1/tasks/{request.id}',
            {'historyLength': str(request.history_length)}
            if request.history_length
            else {},
            modified_kwargs,
        )
        task = a2a_pb2.Task()
        ParseDict(response_data, task)
        return proto_utils.FromProto.task(task)

    async def cancel_task(
        self,
        request: TaskIdParams,
        *,
        context: ClientCallContext | None = None,
    ) -> Task:
        """Requests the agent to cancel a specific task."""
        pb = a2a_pb2.CancelTaskRequest(name=f'tasks/{request.id}')
        payload = MessageToDict(pb)
        payload, modified_kwargs = await self._apply_interceptors(
            payload,
            self._get_http_args(context),
            context,
        )
        response_data = await self._send_post_request(
            f'/v1/tasks/{request.id}:cancel', payload, modified_kwargs
        )
        task = a2a_pb2.Task()
        ParseDict(response_data, task)
        return proto_utils.FromProto.task(task)

    async def set_task_callback(
        self,
        request: TaskPushNotificationConfig,
        *,
        context: ClientCallContext | None = None,
    ) -> TaskPushNotificationConfig:
        """Sets or updates the push notification configuration for a specific task."""
        pb = a2a_pb2.CreateTaskPushNotificationConfigRequest(
            parent=f'tasks/{request.task_id}',
            config_id=request.push_notification_config.id,
            config=proto_utils.ToProto.task_push_notification_config(request),
        )
        payload = MessageToDict(pb)
        payload, modified_kwargs = await self._apply_interceptors(
            payload, self._get_http_args(context), context
        )
        response_data = await self._send_post_request(
            f'/v1/tasks/{request.task_id}/pushNotificationConfigs',
            payload,
            modified_kwargs,
        )
        config = a2a_pb2.TaskPushNotificationConfig()
        ParseDict(response_data, config)
        return proto_utils.FromProto.task_push_notification_config(config)

    async def get_task_callback(
        self,
        request: GetTaskPushNotificationConfigParams,
        *,
        context: ClientCallContext | None = None,
    ) -> TaskPushNotificationConfig:
        """Retrieves the push notification configuration for a specific task."""
        pb = a2a_pb2.GetTaskPushNotificationConfigRequest(
            name=f'tasks/{request.id}/pushNotificationConfigs/{request.push_notification_config_id}',
        )
        payload = MessageToDict(pb)
        payload, modified_kwargs = await self._apply_interceptors(
            payload,
            self._get_http_args(context),
            context,
        )
        response_data = await self._send_get_request(
            f'/v1/tasks/{request.id}/pushNotificationConfigs/{request.push_notification_config_id}',
            {},
            modified_kwargs,
        )
        config = a2a_pb2.TaskPushNotificationConfig()
        ParseDict(response_data, config)
        return proto_utils.FromProto.task_push_notification_config(config)

    async def resubscribe(
        self,
        request: TaskIdParams,
        *,
        context: ClientCallContext | None = None,
    ) -> AsyncGenerator[
        Task | TaskStatusUpdateEvent | TaskArtifactUpdateEvent | Message
    ]:
        """Reconnects to get task updates."""
        http_kwargs = self._get_http_args(context) or {}
        http_kwargs.setdefault('timeout', None)

        async with aconnect_sse(
            self.httpx_client,
            'GET',
            f'{self.url}/v1/tasks/{request.id}:subscribe',
            **http_kwargs,
        ) as event_source:
            try:
                async for sse in event_source.aiter_sse():
                    event = a2a_pb2.StreamResponse()
                    Parse(sse.data, event)
                    yield proto_utils.FromProto.stream_response(event)
            except SSEError as e:
                raise A2AClientHTTPError(
                    400, f'Invalid SSE response or protocol error: {e}'
                ) from e
            except json.JSONDecodeError as e:
                raise A2AClientJSONError(str(e)) from e
            except httpx.RequestError as e:
                raise A2AClientHTTPError(
                    503, f'Network communication error: {e}'
                ) from e

    async def get_card(
        self,
        *,
        context: ClientCallContext | None = None,
    ) -> AgentCard:
        """Retrieves the agent's card."""
        card = self.agent_card
        if not card:
            resolver = A2ACardResolver(self.httpx_client, self.url)
            card = await resolver.get_agent_card(
                http_kwargs=self._get_http_args(context)
            )
            self._needs_extended_card = (
                card.supports_authenticated_extended_card
            )
            self.agent_card = card

        if not self._needs_extended_card:
            return card

        _, modified_kwargs = await self._apply_interceptors(
            {},
            self._get_http_args(context),
            context,
        )
        response_data = await self._send_get_request(
            '/v1/card', {}, modified_kwargs
        )
        card = AgentCard.model_validate(response_data)
        self.agent_card = card
        self._needs_extended_card = False
        return card

    async def close(self) -> None:
        """Closes the httpx client."""
        await self.httpx_client.aclose()



---
File: /a2a-python/src/a2a/client/__init__.py
---

"""Client-side components for interacting with an A2A agent."""

import logging

from a2a.client.auth import (
    AuthInterceptor,
    CredentialService,
    InMemoryContextCredentialStore,
)
from a2a.client.card_resolver import A2ACardResolver
from a2a.client.client import Client, ClientConfig, ClientEvent, Consumer
from a2a.client.client_factory import ClientFactory, minimal_agent_card
from a2a.client.errors import (
    A2AClientError,
    A2AClientHTTPError,
    A2AClientJSONError,
    A2AClientTimeoutError,
)
from a2a.client.helpers import create_text_message_object
from a2a.client.legacy import A2AClient
from a2a.client.middleware import ClientCallContext, ClientCallInterceptor


logger = logging.getLogger(__name__)

try:
    from a2a.client.legacy_grpc import A2AGrpcClient  # type: ignore
except ImportError as e:
    _original_error = e
    logger.debug(
        'A2AGrpcClient not loaded. This is expected if gRPC dependencies are not installed. Error: %s',
        _original_error,
    )

    class A2AGrpcClient:  # type: ignore
        """Placeholder for A2AGrpcClient when dependencies are not installed."""

        def __init__(self, *args, **kwargs):
            raise ImportError(
                'To use A2AGrpcClient, its dependencies must be installed. '
                'You can install them with \'pip install "a2a-sdk[grpc]"\''
            ) from _original_error


__all__ = [
    'A2ACardResolver',
    'A2AClient',
    'A2AClientError',
    'A2AClientHTTPError',
    'A2AClientJSONError',
    'A2AClientTimeoutError',
    'A2AGrpcClient',
    'AuthInterceptor',
    'Client',
    'ClientCallContext',
    'ClientCallInterceptor',
    'ClientConfig',
    'ClientEvent',
    'ClientFactory',
    'Consumer',
    'CredentialService',
    'InMemoryContextCredentialStore',
    'create_text_message_object',
    'minimal_agent_card',
]



---
File: /a2a-python/src/a2a/client/base_client.py
---

from collections.abc import AsyncIterator

from a2a.client.client import (
    Client,
    ClientCallContext,
    ClientConfig,
    ClientEvent,
    Consumer,
)
from a2a.client.client_task_manager import ClientTaskManager
from a2a.client.errors import A2AClientInvalidStateError
from a2a.client.middleware import ClientCallInterceptor
from a2a.client.transports.base import ClientTransport
from a2a.types import (
    AgentCard,
    GetTaskPushNotificationConfigParams,
    Message,
    MessageSendConfiguration,
    MessageSendParams,
    Task,
    TaskArtifactUpdateEvent,
    TaskIdParams,
    TaskPushNotificationConfig,
    TaskQueryParams,
    TaskStatusUpdateEvent,
)


class BaseClient(Client):
    """Base implementation of the A2A client, containing transport-independent logic."""

    def __init__(
        self,
        card: AgentCard,
        config: ClientConfig,
        transport: ClientTransport,
        consumers: list[Consumer],
        middleware: list[ClientCallInterceptor],
    ):
        super().__init__(consumers, middleware)
        self._card = card
        self._config = config
        self._transport = transport

    async def send_message(
        self,
        request: Message,
        *,
        context: ClientCallContext | None = None,
    ) -> AsyncIterator[ClientEvent | Message]:
        """Sends a message to the agent.

        This method handles both streaming and non-streaming (polling) interactions
        based on the client configuration and agent capabilities. It will yield
        events as they are received from the agent.

        Args:
            request: The message to send to the agent.
            context: The client call context.

        Yields:
            An async iterator of `ClientEvent` or a final `Message` response.
        """
        config = MessageSendConfiguration(
            accepted_output_modes=self._config.accepted_output_modes,
            blocking=not self._config.polling,
            push_notification_config=(
                self._config.push_notification_configs[0]
                if self._config.push_notification_configs
                else None
            ),
        )
        params = MessageSendParams(message=request, configuration=config)

        if not self._config.streaming or not self._card.capabilities.streaming:
            response = await self._transport.send_message(
                params, context=context
            )
            result = (
                (response, None) if isinstance(response, Task) else response
            )
            await self.consume(result, self._card)
            yield result
            return

        tracker = ClientTaskManager()
        stream = self._transport.send_message_streaming(params, context=context)

        first_event = await anext(stream)
        # The response from a server may be either exactly one Message or a
        # series of Task updates. Separate out the first message for special
        # case handling, which allows us to simplify further stream processing.
        if isinstance(first_event, Message):
            await self.consume(first_event, self._card)
            yield first_event
            return

        yield await self._process_response(tracker, first_event)

        async for event in stream:
            yield await self._process_response(tracker, event)

    async def _process_response(
        self,
        tracker: ClientTaskManager,
        event: Task | Message | TaskStatusUpdateEvent | TaskArtifactUpdateEvent,
    ) -> ClientEvent:
        if isinstance(event, Message):
            raise A2AClientInvalidStateError(
                'received a streamed Message from server after first response; this is not supported'
            )
        await tracker.process(event)
        task = tracker.get_task_or_raise()
        update = None if isinstance(event, Task) else event
        client_event = (task, update)
        await self.consume(client_event, self._card)
        return client_event

    async def get_task(
        self,
        request: TaskQueryParams,
        *,
        context: ClientCallContext | None = None,
    ) -> Task:
        """Retrieves the current state and history of a specific task.

        Args:
            request: The `TaskQueryParams` object specifying the task ID.
            context: The client call context.

        Returns:
            A `Task` object representing the current state of the task.
        """
        return await self._transport.get_task(request, context=context)

    async def cancel_task(
        self,
        request: TaskIdParams,
        *,
        context: ClientCallContext | None = None,
    ) -> Task:
        """Requests the agent to cancel a specific task.

        Args:
            request: The `TaskIdParams` object specifying the task ID.
            context: The client call context.

        Returns:
            A `Task` object containing the updated task status.
        """
        return await self._transport.cancel_task(request, context=context)

    async def set_task_callback(
        self,
        request: TaskPushNotificationConfig,
        *,
        context: ClientCallContext | None = None,
    ) -> TaskPushNotificationConfig:
        """Sets or updates the push notification configuration for a specific task.

        Args:
            request: The `TaskPushNotificationConfig` object with the new configuration.
            context: The client call context.

        Returns:
            The created or updated `TaskPushNotificationConfig` object.
        """
        return await self._transport.set_task_callback(request, context=context)

    async def get_task_callback(
        self,
        request: GetTaskPushNotificationConfigParams,
        *,
        context: ClientCallContext | None = None,
    ) -> TaskPushNotificationConfig:
        """Retrieves the push notification configuration for a specific task.

        Args:
            request: The `GetTaskPushNotificationConfigParams` object specifying the task.
            context: The client call context.

        Returns:
            A `TaskPushNotificationConfig` object containing the configuration.
        """
        return await self._transport.get_task_callback(request, context=context)

    async def resubscribe(
        self,
        request: TaskIdParams,
        *,
        context: ClientCallContext | None = None,
    ) -> AsyncIterator[ClientEvent]:
        """Resubscribes to a task's event stream.

        This is only available if both the client and server support streaming.

        Args:
            request: Parameters to identify the task to resubscribe to.
            context: The client call context.

        Yields:
            An async iterator of `ClientEvent` objects.

        Raises:
            NotImplementedError: If streaming is not supported by the client or server.
        """
        if not self._config.streaming or not self._card.capabilities.streaming:
            raise NotImplementedError(
                'client and/or server do not support resubscription.'
            )

        tracker = ClientTaskManager()
        # Note: resubscribe can only be called on an existing task. As such,
        # we should never see Message updates, despite the typing of the service
        # definition indicating it may be possible.
        async for event in self._transport.resubscribe(
            request, context=context
        ):
            yield await self._process_response(tracker, event)

    async def get_card(
        self, *, context: ClientCallContext | None = None
    ) -> AgentCard:
        """Retrieves the agent's card.

        This will fetch the authenticated card if necessary and update the
        client's internal state with the new card.

        Args:
            context: The client call context.

        Returns:
            The `AgentCard` for the agent.
        """
        card = await self._transport.get_card(context=context)
        self._card = card
        return card

    async def close(self) -> None:
        """Closes the underlying transport."""
        await self._transport.close()



---
File: /a2a-python/src/a2a/client/card_resolver.py
---

import json
import logging

from typing import Any

import httpx

from pydantic import ValidationError

from a2a.client.errors import (
    A2AClientHTTPError,
    A2AClientJSONError,
)
from a2a.types import (
    AgentCard,
)
from a2a.utils.constants import AGENT_CARD_WELL_KNOWN_PATH


logger = logging.getLogger(__name__)


class A2ACardResolver:
    """Agent Card resolver."""

    def __init__(
        self,
        httpx_client: httpx.AsyncClient,
        base_url: str,
        agent_card_path: str = AGENT_CARD_WELL_KNOWN_PATH,
    ) -> None:
        """Initializes the A2ACardResolver.

        Args:
            httpx_client: An async HTTP client instance (e.g., httpx.AsyncClient).
            base_url: The base URL of the agent's host.
            agent_card_path: The path to the agent card endpoint, relative to the base URL.
        """
        self.base_url = base_url.rstrip('/')
        self.agent_card_path = agent_card_path.lstrip('/')
        self.httpx_client = httpx_client

    async def get_agent_card(
        self,
        relative_card_path: str | None = None,
        http_kwargs: dict[str, Any] | None = None,
    ) -> AgentCard:
        """Fetches an agent card from a specified path relative to the base_url.

        If relative_card_path is None, it defaults to the resolver's configured
        agent_card_path (for the public agent card).

        Args:
            relative_card_path: Optional path to the agent card endpoint,
                relative to the base URL. If None, uses the default public
                agent card path.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.get request.

        Returns:
            An `AgentCard` object representing the agent's capabilities.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON
                or validated against the AgentCard schema.
        """
        if relative_card_path is None:
            # Use the default public agent card path configured during initialization
            path_segment = self.agent_card_path
        else:
            path_segment = relative_card_path.lstrip('/')

        target_url = f'{self.base_url}/{path_segment}'

        try:
            response = await self.httpx_client.get(
                target_url,
                **(http_kwargs or {}),
            )
            response.raise_for_status()
            agent_card_data = response.json()
            logger.info(
                'Successfully fetched agent card data from %s: %s',
                target_url,
                agent_card_data,
            )
            agent_card = AgentCard.model_validate(agent_card_data)
        except httpx.HTTPStatusError as e:
            raise A2AClientHTTPError(
                e.response.status_code,
                f'Failed to fetch agent card from {target_url}: {e}',
            ) from e
        except json.JSONDecodeError as e:
            raise A2AClientJSONError(
                f'Failed to parse JSON for agent card from {target_url}: {e}'
            ) from e
        except httpx.RequestError as e:
            raise A2AClientHTTPError(
                503,
                f'Network communication error fetching agent card from {target_url}: {e}',
            ) from e
        except ValidationError as e:  # Pydantic validation error
            raise A2AClientJSONError(
                f'Failed to validate agent card structure from {target_url}: {e.json()}'
            ) from e

        return agent_card



---
File: /a2a-python/src/a2a/client/client_factory.py
---

from __future__ import annotations

import logging

from collections.abc import Callable

import httpx

from a2a.client.base_client import BaseClient
from a2a.client.client import Client, ClientConfig, Consumer
from a2a.client.middleware import ClientCallInterceptor
from a2a.client.transports.base import ClientTransport
from a2a.client.transports.jsonrpc import JsonRpcTransport
from a2a.client.transports.rest import RestTransport
from a2a.types import (
    AgentCapabilities,
    AgentCard,
    AgentInterface,
    TransportProtocol,
)


try:
    from a2a.client.transports.grpc import GrpcTransport
except ImportError:
    GrpcTransport = None  # type: ignore # pyright: ignore


logger = logging.getLogger(__name__)


TransportProducer = Callable[
    [AgentCard, str, ClientConfig, list[ClientCallInterceptor]],
    ClientTransport,
]


class ClientFactory:
    """ClientFactory is used to generate the appropriate client for the agent.

    The factory is configured with a `ClientConfig` and optionally a list of
    `Consumer`s to use for all generated `Client`s. The expected use is:

    factory = ClientFactory(config, consumers)
    # Optionally register custom client implementations
    factory.register('my_customer_transport', NewCustomTransportClient)
    # Then with an agent card make a client with additional consumers and
    # interceptors
    client = factory.create(card, additional_consumers, interceptors)
    # Now the client can be used the same regardless of transport and
    # aligns client config with server capabilities.
    """

    def __init__(
        self,
        config: ClientConfig,
        consumers: list[Consumer] | None = None,
    ):
        if consumers is None:
            consumers = []
        self._config = config
        self._consumers = consumers
        self._registry: dict[str, TransportProducer] = {}
        self._register_defaults(config.supported_transports)

    def _register_defaults(
        self, supported: list[str | TransportProtocol]
    ) -> None:
        # Empty support list implies JSON-RPC only.
        if TransportProtocol.jsonrpc in supported or not supported:
            self.register(
                TransportProtocol.jsonrpc,
                lambda card, url, config, interceptors: JsonRpcTransport(
                    config.httpx_client or httpx.AsyncClient(),
                    card,
                    url,
                    interceptors,
                ),
            )
        if TransportProtocol.http_json in supported:
            self.register(
                TransportProtocol.http_json,
                lambda card, url, config, interceptors: RestTransport(
                    config.httpx_client or httpx.AsyncClient(),
                    card,
                    url,
                    interceptors,
                ),
            )
        if TransportProtocol.grpc in supported:
            if GrpcTransport is None:
                raise ImportError(
                    'To use GrpcClient, its dependencies must be installed. '
                    'You can install them with \'pip install "a2a-sdk[grpc]"\''
                )
            self.register(
                TransportProtocol.grpc,
                GrpcTransport.create,
            )

    def register(self, label: str, generator: TransportProducer) -> None:
        """Register a new transport producer for a given transport label."""
        self._registry[label] = generator

    def create(
        self,
        card: AgentCard,
        consumers: list[Consumer] | None = None,
        interceptors: list[ClientCallInterceptor] | None = None,
    ) -> Client:
        """Create a new `Client` for the provided `AgentCard`.

        Args:
          card: An `AgentCard` defining the characteristics of the agent.
          consumers: A list of `Consumer` methods to pass responses to.
          interceptors: A list of interceptors to use for each request. These
            are used for things like attaching credentials or http headers
            to all outbound requests.

        Returns:
          A `Client` object.

        Raises:
          If there is no valid matching of the client configuration with the
          server configuration, a `ValueError` is raised.
        """
        server_preferred = card.preferred_transport or TransportProtocol.jsonrpc
        server_set = {server_preferred: card.url}
        if card.additional_interfaces:
            server_set.update(
                {x.transport: x.url for x in card.additional_interfaces}
            )
        client_set = self._config.supported_transports or [
            TransportProtocol.jsonrpc
        ]
        transport_protocol = None
        transport_url = None
        if self._config.use_client_preference:
            for x in client_set:
                if x in server_set:
                    transport_protocol = x
                    transport_url = server_set[x]
                    break
        else:
            for x, url in server_set.items():
                if x in client_set:
                    transport_protocol = x
                    transport_url = url
                    break
        if not transport_protocol or not transport_url:
            raise ValueError('no compatible transports found.')
        if transport_protocol not in self._registry:
            raise ValueError(f'no client available for {transport_protocol}')

        all_consumers = self._consumers.copy()
        if consumers:
            all_consumers.extend(consumers)

        transport = self._registry[transport_protocol](
            card, transport_url, self._config, interceptors or []
        )

        return BaseClient(
            card, self._config, transport, all_consumers, interceptors or []
        )


def minimal_agent_card(
    url: str, transports: list[str] | None = None
) -> AgentCard:
    """Generates a minimal card to simplify bootstrapping client creation.

    This minimal card is not viable itself to interact with the remote agent.
    Instead this is a short hand way to take a known url and transport option
    and interact with the get card endpoint of the agent server to get the
    correct agent card. This pattern is necessary for gRPC based card access
    as typically these servers won't expose a well known path card.
    """
    if transports is None:
        transports = []
    return AgentCard(
        url=url,
        preferred_transport=transports[0] if transports else None,
        additional_interfaces=[
            AgentInterface(transport=t, url=url) for t in transports[1:]
        ]
        if len(transports) > 1
        else [],
        supports_authenticated_extended_card=True,
        capabilities=AgentCapabilities(),
        default_input_modes=[],
        default_output_modes=[],
        description='',
        skills=[],
        version='',
        name='',
    )



---
File: /a2a-python/src/a2a/client/client_task_manager.py
---

import logging

from a2a.client.errors import (
    A2AClientInvalidArgsError,
    A2AClientInvalidStateError,
)
from a2a.server.events.event_queue import Event
from a2a.types import (
    Message,
    Task,
    TaskArtifactUpdateEvent,
    TaskState,
    TaskStatus,
    TaskStatusUpdateEvent,
)
from a2a.utils import append_artifact_to_task


logger = logging.getLogger(__name__)


class ClientTaskManager:
    """Helps manage a task's lifecycle during execution of a request.

    Responsible for retrieving, saving, and updating the `Task` object based on
    events received from the agent.
    """

    def __init__(
        self,
    ) -> None:
        """Initializes the `ClientTaskManager`."""
        self._current_task: Task | None = None
        self._task_id: str | None = None
        self._context_id: str | None = None

    def get_task(self) -> Task | None:
        """Retrieves the current task object, either from memory.

        If `task_id` is set, it returns `_current_task` otherwise None.

        Returns:
            The `Task` object if found, otherwise `None`.
        """
        if not self._task_id:
            logger.debug('task_id is not set, cannot get task.')
            return None

        return self._current_task

    def get_task_or_raise(self) -> Task:
        """Retrieves the current task object.

        Returns:
            The `Task` object.

        Raises:
            A2AClientInvalidStateError: If there is no current known Task.
        """
        if not (task := self.get_task()):
            # Note: The source of this error is either from bad client usage
            # or from the server sending invalid updates. It indicates that this
            # task manager has not consumed any information about a task, yet
            # the caller is attempting to retrieve the current state of the task
            # it expects to be present.
            raise A2AClientInvalidStateError('no current Task')
        return task

    async def save_task_event(
        self, event: Task | TaskStatusUpdateEvent | TaskArtifactUpdateEvent
    ) -> Task | None:
        """Processes a task-related event (Task, Status, Artifact) and saves the updated task state.

        Ensures task and context IDs match or are set from the event.

        Args:
            event: The task-related event (`Task`, `TaskStatusUpdateEvent`, or `TaskArtifactUpdateEvent`).

        Returns:
            The updated `Task` object after processing the event.

        Raises:
            ClientError: If the task ID in the event conflicts with the TaskManager's ID
                         when the TaskManager's ID is already set.
        """
        if isinstance(event, Task):
            if self._current_task:
                raise A2AClientInvalidArgsError(
                    'Task is already set, create new manager for new tasks.'
                )
            await self._save_task(event)
            return event
        task_id_from_event = (
            event.id if isinstance(event, Task) else event.task_id
        )
        if not self._task_id:
            self._task_id = task_id_from_event
        if not self._context_id:
            self._context_id = event.context_id

        logger.debug(
            'Processing save of task event of type %s for task_id: %s',
            type(event).__name__,
            task_id_from_event,
        )

        task = self._current_task
        if not task:
            task = Task(
                status=TaskStatus(state=TaskState.unknown),
                id=task_id_from_event,
                context_id=self._context_id if self._context_id else '',
            )
        if isinstance(event, TaskStatusUpdateEvent):
            logger.debug(
                'Updating task %s status to: %s',
                event.task_id,
                event.status.state,
            )
            if event.status.message:
                if not task.history:
                    task.history = [event.status.message]
                else:
                    task.history.append(event.status.message)
            if event.metadata:
                if not task.metadata:
                    task.metadata = {}
                task.metadata.update(event.metadata)
            task.status = event.status
        else:
            logger.debug('Appending artifact to task %s', task.id)
            append_artifact_to_task(task, event)
        self._current_task = task
        return task

    async def process(self, event: Event) -> Event:
        """Processes an event, updates the task state if applicable, stores it, and returns the event.

        If the event is task-related (`Task`, `TaskStatusUpdateEvent`, `TaskArtifactUpdateEvent`),
        the internal task state is updated and persisted.

        Args:
            event: The event object received from the agent.

        Returns:
            The same event object that was processed.
        """
        if isinstance(
            event, Task | TaskStatusUpdateEvent | TaskArtifactUpdateEvent
        ):
            await self.save_task_event(event)

        return event

    async def _save_task(self, task: Task) -> None:
        """Saves the given task to the `_current_task` and updated `_task_id` and `_context_id`.

        Args:
            task: The `Task` object to save.
        """
        logger.debug('Saving task with id: %s', task.id)
        self._current_task = task
        if not self._task_id:
            logger.info('New task created with id: %s', task.id)
            self._task_id = task.id
            self._context_id = task.context_id

    def update_with_message(self, message: Message, task: Task) -> Task:
        """Updates a task object adding a new message to its history.

        If the task has a message in its current status, that message is moved
        to the history first.

        Args:
            message: The new `Message` to add to the history.
            task: The `Task` object to update.

        Returns:
            The updated `Task` object (updated in-place).
        """
        if task.status.message:
            if task.history:
                task.history.append(task.status.message)
            else:
                task.history = [task.status.message]
            task.status.message = None
        if task.history:
            task.history.append(message)
        else:
            task.history = [message]
        self._current_task = task
        return task



---
File: /a2a-python/src/a2a/client/client.py
---

import dataclasses
import logging

from abc import ABC, abstractmethod
from collections.abc import AsyncIterator, Callable, Coroutine
from typing import Any

import httpx

from a2a.client.middleware import ClientCallContext, ClientCallInterceptor
from a2a.client.optionals import Channel
from a2a.types import (
    AgentCard,
    GetTaskPushNotificationConfigParams,
    Message,
    PushNotificationConfig,
    Task,
    TaskArtifactUpdateEvent,
    TaskIdParams,
    TaskPushNotificationConfig,
    TaskQueryParams,
    TaskStatusUpdateEvent,
    TransportProtocol,
)


logger = logging.getLogger(__name__)


@dataclasses.dataclass
class ClientConfig:
    """Configuration class for the A2AClient Factory."""

    streaming: bool = True
    """Whether client supports streaming"""

    polling: bool = False
    """Whether client prefers to poll for updates from message:send. It is
    the callers job to check if the response is completed and if not run a
    polling loop."""

    httpx_client: httpx.AsyncClient | None = None
    """Http client to use to connect to agent."""

    grpc_channel_factory: Callable[[str], Channel] | None = None
    """Generates a grpc connection channel for a given url."""

    supported_transports: list[TransportProtocol | str] = dataclasses.field(
        default_factory=list
    )
    """Ordered list of transports for connecting to agent
       (in order of preference). Empty implies JSONRPC only.

       This is a string type to allow custom
       transports to exist in closed ecosystems.
    """

    use_client_preference: bool = False
    """Whether to use client transport preferences over server preferences.
       Recommended to use server preferences in most situations."""

    accepted_output_modes: list[str] = dataclasses.field(default_factory=list)
    """The set of accepted output modes for the client."""

    push_notification_configs: list[PushNotificationConfig] = dataclasses.field(
        default_factory=list
    )
    """Push notification callbacks to use for every request."""


UpdateEvent = TaskStatusUpdateEvent | TaskArtifactUpdateEvent | None
# Alias for emitted events from client
ClientEvent = tuple[Task, UpdateEvent]
# Alias for an event consuming callback. It takes either a (task, update) pair
# or a message as well as the agent card for the agent this came from.
Consumer = Callable[
    [ClientEvent | Message, AgentCard], Coroutine[None, Any, Any]
]


class Client(ABC):
    """Abstract base class defining the interface for an A2A client.

    This class provides a standard set of methods for interacting with an A2A
    agent, regardless of the underlying transport protocol (e.g., gRPC, JSON-RPC).
    It supports sending messages, managing tasks, and handling event streams.
    """

    def __init__(
        self,
        consumers: list[Consumer] | None = None,
        middleware: list[ClientCallInterceptor] | None = None,
    ):
        """Initializes the client with consumers and middleware.

        Args:
            consumers: A list of callables to process events from the agent.
            middleware: A list of interceptors to process requests and responses.
        """
        if middleware is None:
            middleware = []
        if consumers is None:
            consumers = []
        self._consumers = consumers
        self._middleware = middleware

    @abstractmethod
    async def send_message(
        self,
        request: Message,
        *,
        context: ClientCallContext | None = None,
    ) -> AsyncIterator[ClientEvent | Message]:
        """Sends a message to the server.

        This will automatically use the streaming or non-streaming approach
        as supported by the server and the client config. Client will
        aggregate update events and return an iterator of (`Task`,`Update`)
        pairs, or a `Message`. Client will also send these values to any
        configured `Consumer`s in the client.
        """
        return
        yield

    @abstractmethod
    async def get_task(
        self,
        request: TaskQueryParams,
        *,
        context: ClientCallContext | None = None,
    ) -> Task:
        """Retrieves the current state and history of a specific task."""

    @abstractmethod
    async def cancel_task(
        self,
        request: TaskIdParams,
        *,
        context: ClientCallContext | None = None,
    ) -> Task:
        """Requests the agent to cancel a specific task."""

    @abstractmethod
    async def set_task_callback(
        self,
        request: TaskPushNotificationConfig,
        *,
        context: ClientCallContext | None = None,
    ) -> TaskPushNotificationConfig:
        """Sets or updates the push notification configuration for a specific task."""

    @abstractmethod
    async def get_task_callback(
        self,
        request: GetTaskPushNotificationConfigParams,
        *,
        context: ClientCallContext | None = None,
    ) -> TaskPushNotificationConfig:
        """Retrieves the push notification configuration for a specific task."""

    @abstractmethod
    async def resubscribe(
        self,
        request: TaskIdParams,
        *,
        context: ClientCallContext | None = None,
    ) -> AsyncIterator[ClientEvent]:
        """Resubscribes to a task's event stream."""
        return
        yield

    @abstractmethod
    async def get_card(
        self, *, context: ClientCallContext | None = None
    ) -> AgentCard:
        """Retrieves the agent's card."""

    async def add_event_consumer(self, consumer: Consumer) -> None:
        """Attaches additional consumers to the `Client`."""
        self._consumers.append(consumer)

    async def add_request_middleware(
        self, middleware: ClientCallInterceptor
    ) -> None:
        """Attaches additional middleware to the `Client`."""
        self._middleware.append(middleware)

    async def consume(
        self,
        event: tuple[Task, UpdateEvent] | Message | None,
        card: AgentCard,
    ) -> None:
        """Processes the event via all the registered `Consumer`s."""
        if not event:
            return
        for c in self._consumers:
            await c(event, card)



---
File: /a2a-python/src/a2a/client/errors.py
---

"""Custom exceptions for the A2A client."""

from a2a.types import JSONRPCErrorResponse


class A2AClientError(Exception):
    """Base exception for A2A Client errors."""


class A2AClientHTTPError(A2AClientError):
    """Client exception for HTTP errors received from the server."""

    def __init__(self, status_code: int, message: str):
        """Initializes the A2AClientHTTPError.

        Args:
            status_code: The HTTP status code of the response.
            message: A descriptive error message.
        """
        self.status_code = status_code
        self.message = message
        super().__init__(f'HTTP Error {status_code}: {message}')


class A2AClientJSONError(A2AClientError):
    """Client exception for JSON errors during response parsing or validation."""

    def __init__(self, message: str):
        """Initializes the A2AClientJSONError.

        Args:
            message: A descriptive error message.
        """
        self.message = message
        super().__init__(f'JSON Error: {message}')


class A2AClientTimeoutError(A2AClientError):
    """Client exception for timeout errors during a request."""

    def __init__(self, message: str):
        """Initializes the A2AClientTimeoutError.

        Args:
            message: A descriptive error message.
        """
        self.message = message
        super().__init__(f'Timeout Error: {message}')


class A2AClientInvalidArgsError(A2AClientError):
    """Client exception for invalid arguments passed to a method."""

    def __init__(self, message: str):
        """Initializes the A2AClientInvalidArgsError.

        Args:
            message: A descriptive error message.
        """
        self.message = message
        super().__init__(f'Invalid arguments error: {message}')


class A2AClientInvalidStateError(A2AClientError):
    """Client exception for an invalid client state."""

    def __init__(self, message: str):
        """Initializes the A2AClientInvalidStateError.

        Args:
            message: A descriptive error message.
        """
        self.message = message
        super().__init__(f'Invalid state error: {message}')


class A2AClientJSONRPCError(A2AClientError):
    """Client exception for JSON-RPC errors returned by the server."""

    def __init__(self, error: JSONRPCErrorResponse):
        """Initializes the A2AClientJsonRPCError.

        Args:
            error: The JSON-RPC error object.
        """
        self.error = error.error
        super().__init__(f'JSON-RPC Error {error.error}')



---
File: /a2a-python/src/a2a/client/helpers.py
---

"""Helper functions for the A2A client."""

from uuid import uuid4

from a2a.types import Message, Part, Role, TextPart


def create_text_message_object(
    role: Role = Role.user, content: str = ''
) -> Message:
    """Create a Message object containing a single TextPart.

    Args:
        role: The role of the message sender (user or agent). Defaults to Role.user.
        content: The text content of the message. Defaults to an empty string.

    Returns:
        A `Message` object with a new UUID message_id.
    """
    return Message(
        role=role, parts=[Part(TextPart(text=content))], message_id=str(uuid4())
    )



---
File: /a2a-python/src/a2a/client/legacy_grpc.py
---

"""Backwards compatibility layer for the legacy A2A gRPC client."""

import warnings

from typing import TYPE_CHECKING

from a2a.client.transports.grpc import GrpcTransport
from a2a.types import AgentCard


if TYPE_CHECKING:
    from a2a.grpc.a2a_pb2_grpc import A2AServiceStub


class A2AGrpcClient(GrpcTransport):
    """[DEPRECATED] Backwards compatibility wrapper for the gRPC client."""

    def __init__(  # pylint: disable=super-init-not-called
        self,
        grpc_stub: 'A2AServiceStub',
        agent_card: AgentCard,
    ):
        warnings.warn(
            'A2AGrpcClient is deprecated and will be removed in a future version. '
            'Use ClientFactory to create a client with a gRPC transport.',
            DeprecationWarning,
            stacklevel=2,
        )
        # The old gRPC client accepted a stub directly. The new one accepts a
        # channel and builds the stub itself. We just have a stub here, so we
        # need to handle initialization ourselves.
        self.stub = grpc_stub
        self.agent_card = agent_card
        self._needs_extended_card = (
            agent_card.supports_authenticated_extended_card
            if agent_card
            else True
        )

        class _NopChannel:
            async def close(self) -> None:
                pass

        self.channel = _NopChannel()



---
File: /a2a-python/src/a2a/client/legacy.py
---

"""Backwards compatibility layer for legacy A2A clients."""

import warnings

from collections.abc import AsyncGenerator
from typing import Any

import httpx

from a2a.client.errors import A2AClientJSONRPCError
from a2a.client.middleware import ClientCallContext, ClientCallInterceptor
from a2a.client.transports.jsonrpc import JsonRpcTransport
from a2a.types import (
    AgentCard,
    CancelTaskRequest,
    CancelTaskResponse,
    CancelTaskSuccessResponse,
    GetTaskPushNotificationConfigParams,
    GetTaskPushNotificationConfigRequest,
    GetTaskPushNotificationConfigResponse,
    GetTaskPushNotificationConfigSuccessResponse,
    GetTaskRequest,
    GetTaskResponse,
    GetTaskSuccessResponse,
    JSONRPCErrorResponse,
    SendMessageRequest,
    SendMessageResponse,
    SendMessageSuccessResponse,
    SendStreamingMessageRequest,
    SendStreamingMessageResponse,
    SendStreamingMessageSuccessResponse,
    SetTaskPushNotificationConfigRequest,
    SetTaskPushNotificationConfigResponse,
    SetTaskPushNotificationConfigSuccessResponse,
    TaskIdParams,
    TaskResubscriptionRequest,
)


class A2AClient:
    """[DEPRECATED] Backwards compatibility wrapper for the JSON-RPC client."""

    def __init__(
        self,
        httpx_client: httpx.AsyncClient,
        agent_card: AgentCard | None = None,
        url: str | None = None,
        interceptors: list[ClientCallInterceptor] | None = None,
    ):
        warnings.warn(
            'A2AClient is deprecated and will be removed in a future version. '
            'Use ClientFactory to create a client with a JSON-RPC transport.',
            DeprecationWarning,
            stacklevel=2,
        )
        self._transport = JsonRpcTransport(
            httpx_client, agent_card, url, interceptors
        )

    async def send_message(
        self,
        request: SendMessageRequest,
        *,
        http_kwargs: dict[str, Any] | None = None,
        context: ClientCallContext | None = None,
    ) -> SendMessageResponse:
        """Sends a non-streaming message request to the agent.

        Args:
            request: The `SendMessageRequest` object containing the message and configuration.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request.
            context: The client call context.

        Returns:
            A `SendMessageResponse` object containing the agent's response (Task or Message) or an error.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON or validated.
        """
        if not context and http_kwargs:
            context = ClientCallContext(state={'http_kwargs': http_kwargs})

        try:
            result = await self._transport.send_message(
                request.params, context=context
            )
            return SendMessageResponse(
                root=SendMessageSuccessResponse(
                    id=request.id, jsonrpc='2.0', result=result
                )
            )
        except A2AClientJSONRPCError as e:
            return SendMessageResponse(JSONRPCErrorResponse(error=e.error))

    async def send_message_streaming(
        self,
        request: SendStreamingMessageRequest,
        *,
        http_kwargs: dict[str, Any] | None = None,
        context: ClientCallContext | None = None,
    ) -> AsyncGenerator[SendStreamingMessageResponse, None]:
        """Sends a streaming message request to the agent and yields responses as they arrive.

        This method uses Server-Sent Events (SSE) to receive a stream of updates from the agent.

        Args:
            request: The `SendStreamingMessageRequest` object containing the message and configuration.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request. A default `timeout=None` is set but can be overridden.
            context: The client call context.

        Yields:
            `SendStreamingMessageResponse` objects as they are received in the SSE stream.
            These can be Task, Message, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent.

        Raises:
            A2AClientHTTPError: If an HTTP or SSE protocol error occurs during the request.
            A2AClientJSONError: If an SSE event data cannot be decoded as JSON or validated.
        """
        if not context and http_kwargs:
            context = ClientCallContext(state={'http_kwargs': http_kwargs})

        async for result in self._transport.send_message_streaming(
            request.params, context=context
        ):
            yield SendStreamingMessageResponse(
                root=SendStreamingMessageSuccessResponse(
                    id=request.id, jsonrpc='2.0', result=result
                )
            )

    async def get_task(
        self,
        request: GetTaskRequest,
        *,
        http_kwargs: dict[str, Any] | None = None,
        context: ClientCallContext | None = None,
    ) -> GetTaskResponse:
        """Retrieves the current state and history of a specific task.

        Args:
            request: The `GetTaskRequest` object specifying the task ID and history length.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request.
            context: The client call context.

        Returns:
            A `GetTaskResponse` object containing the Task or an error.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON or validated.
        """
        if not context and http_kwargs:
            context = ClientCallContext(state={'http_kwargs': http_kwargs})
        try:
            result = await self._transport.get_task(
                request.params, context=context
            )
            return GetTaskResponse(
                root=GetTaskSuccessResponse(
                    id=request.id, jsonrpc='2.0', result=result
                )
            )
        except A2AClientJSONRPCError as e:
            return GetTaskResponse(root=JSONRPCErrorResponse(error=e.error))

    async def cancel_task(
        self,
        request: CancelTaskRequest,
        *,
        http_kwargs: dict[str, Any] | None = None,
        context: ClientCallContext | None = None,
    ) -> CancelTaskResponse:
        """Requests the agent to cancel a specific task.

        Args:
            request: The `CancelTaskRequest` object specifying the task ID.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request.
            context: The client call context.

        Returns:
            A `CancelTaskResponse` object containing the updated Task with canceled status or an error.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON or validated.
        """
        if not context and http_kwargs:
            context = ClientCallContext(state={'http_kwargs': http_kwargs})
        try:
            result = await self._transport.cancel_task(
                request.params, context=context
            )
            return CancelTaskResponse(
                root=CancelTaskSuccessResponse(
                    id=request.id, jsonrpc='2.0', result=result
                )
            )
        except A2AClientJSONRPCError as e:
            return CancelTaskResponse(JSONRPCErrorResponse(error=e.error))

    async def set_task_callback(
        self,
        request: SetTaskPushNotificationConfigRequest,
        *,
        http_kwargs: dict[str, Any] | None = None,
        context: ClientCallContext | None = None,
    ) -> SetTaskPushNotificationConfigResponse:
        """Sets or updates the push notification configuration for a specific task.

        Args:
            request: The `SetTaskPushNotificationConfigRequest` object specifying the task ID and configuration.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request.
            context: The client call context.

        Returns:
            A `SetTaskPushNotificationConfigResponse` object containing the confirmation or an error.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON or validated.
        """
        if not context and http_kwargs:
            context = ClientCallContext(state={'http_kwargs': http_kwargs})
        try:
            result = await self._transport.set_task_callback(
                request.params, context=context
            )
            return SetTaskPushNotificationConfigResponse(
                root=SetTaskPushNotificationConfigSuccessResponse(
                    id=request.id, jsonrpc='2.0', result=result
                )
            )
        except A2AClientJSONRPCError as e:
            return SetTaskPushNotificationConfigResponse(
                JSONRPCErrorResponse(error=e.error)
            )

    async def get_task_callback(
        self,
        request: GetTaskPushNotificationConfigRequest,
        *,
        http_kwargs: dict[str, Any] | None = None,
        context: ClientCallContext | None = None,
    ) -> GetTaskPushNotificationConfigResponse:
        """Retrieves the push notification configuration for a specific task.

        Args:
            request: The `GetTaskPushNotificationConfigRequest` object specifying the task ID.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request.
            context: The client call context.

        Returns:
            A `GetTaskPushNotificationConfigResponse` object containing the configuration or an error.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON or validated.
        """
        if not context and http_kwargs:
            context = ClientCallContext(state={'http_kwargs': http_kwargs})
        params = request.params
        if isinstance(params, TaskIdParams):
            params = GetTaskPushNotificationConfigParams(id=request.params.id)
        try:
            result = await self._transport.get_task_callback(
                params, context=context
            )
            return GetTaskPushNotificationConfigResponse(
                root=GetTaskPushNotificationConfigSuccessResponse(
                    id=request.id, jsonrpc='2.0', result=result
                )
            )
        except A2AClientJSONRPCError as e:
            return GetTaskPushNotificationConfigResponse(
                JSONRPCErrorResponse(error=e.error)
            )

    async def resubscribe(
        self,
        request: TaskResubscriptionRequest,
        *,
        http_kwargs: dict[str, Any] | None = None,
        context: ClientCallContext | None = None,
    ) -> AsyncGenerator[SendStreamingMessageResponse, None]:
        """Reconnects to get task updates.

        This method uses Server-Sent Events (SSE) to receive a stream of updates from the agent.

        Args:
            request: The `TaskResubscriptionRequest` object containing the task information to reconnect to.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request. A default `timeout=None` is set but can be overridden.
            context: The client call context.

        Yields:
            `SendStreamingMessageResponse` objects as they are received in the SSE stream.
            These can be Task, Message, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent.

        Raises:
            A2AClientHTTPError: If an HTTP or SSE protocol error occurs during the request.
            A2AClientJSONError: If an SSE event data cannot be decoded as JSON or validated.
        """
        if not context and http_kwargs:
            context = ClientCallContext(state={'http_kwargs': http_kwargs})

        async for result in self._transport.resubscribe(
            request.params, context=context
        ):
            yield SendStreamingMessageResponse(
                root=SendStreamingMessageSuccessResponse(
                    id=request.id, jsonrpc='2.0', result=result
                )
            )

    async def get_card(
        self,
        *,
        http_kwargs: dict[str, Any] | None = None,
        context: ClientCallContext | None = None,
    ) -> AgentCard:
        """Retrieves the authenticated card (if necessary) or the public one.

        Args:
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request.
            context: The client call context.

        Returns:
            A `AgentCard` object containing the card or an error.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON or validated.
        """
        if not context and http_kwargs:
            context = ClientCallContext(state={'http_kwargs': http_kwargs})
        return await self._transport.get_card(context=context)



---
File: /a2a-python/src/a2a/client/middleware.py
---

from __future__ import annotations

from abc import ABC, abstractmethod
from collections.abc import MutableMapping  # noqa: TC003
from typing import TYPE_CHECKING, Any

from pydantic import BaseModel, Field


if TYPE_CHECKING:
    from a2a.types import AgentCard


class ClientCallContext(BaseModel):
    """A context passed with each client call, allowing for call-specific.

    configuration and data passing. Such as authentication details or
    request deadlines.
    """

    state: MutableMapping[str, Any] = Field(default_factory=dict)


class ClientCallInterceptor(ABC):
    """An abstract base class for client-side call interceptors.

    Interceptors can inspect and modify requests before they are sent,
    which is ideal for concerns like authentication, logging, or tracing.
    """

    @abstractmethod
    async def intercept(
        self,
        method_name: str,
        request_payload: dict[str, Any],
        http_kwargs: dict[str, Any],
        agent_card: AgentCard | None,
        context: ClientCallContext | None,
    ) -> tuple[dict[str, Any], dict[str, Any]]:
        """
        Intercepts a client call before the request is sent.

        Args:
            method_name: The name of the RPC method (e.g., 'message/send').
            request_payload: The JSON RPC request payload dictionary.
            http_kwargs: The keyword arguments for the httpx request.
            agent_card: The AgentCard associated with the client.
            context: The ClientCallContext for this specific call.

        Returns:
            A tuple containing the (potentially modified) request_payload
            and http_kwargs.
        """



---
File: /a2a-python/src/a2a/client/optionals.py
---

from typing import TYPE_CHECKING


# Attempt to import the optional module
try:
    from grpc.aio import Channel  # pyright: ignore[reportAssignmentType]
except ImportError:
    # If grpc.aio is not available, define a dummy type for type checking.
    # This dummy type will only be used by type checkers.
    if TYPE_CHECKING:

        class Channel:  # type: ignore[no-redef]
            """Dummy class for type hinting when grpc.aio is not available."""

    else:
        Channel = None  # At runtime, pd will be None if the import failed.



---
File: /a2a-python/src/a2a/extensions/__init__.py
---




---
File: /a2a-python/src/a2a/extensions/common.py
---

from a2a.types import AgentCard, AgentExtension


HTTP_EXTENSION_HEADER = 'X-A2A-Extensions'


def get_requested_extensions(values: list[str]) -> set[str]:
    """Get the set of requested extensions from an input list.

    This handles the list containing potentially comma-separated values, as
    occurs when using a list in an HTTP header.
    """
    return {
        stripped
        for v in values
        for ext in v.split(',')
        if (stripped := ext.strip())
    }


def find_extension_by_uri(card: AgentCard, uri: str) -> AgentExtension | None:
    """Find an AgentExtension in an AgentCard given a uri."""
    for ext in card.capabilities.extensions or []:
        if ext.uri == uri:
            return ext

    return None



---
File: /a2a-python/src/a2a/grpc/__init__.py
---




---
File: /a2a-python/src/a2a/grpc/a2a_pb2_grpc.py
---

# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from . import a2a_pb2 as a2a__pb2
from google.protobuf import empty_pb2 as google_dot_protobuf_dot_empty__pb2


class A2AServiceStub(object):
    """A2AService defines the gRPC version of the A2A protocol. This has a slightly
    different shape than the JSONRPC version to better conform to AIP-127,
    where appropriate. The nouns are AgentCard, Message, Task and
    TaskPushNotificationConfig.
    - Messages are not a standard resource so there is no get/delete/update/list
    interface, only a send and stream custom methods.
    - Tasks have a get interface and custom cancel and subscribe methods.
    - TaskPushNotificationConfig are a resource whose parent is a task.
    They have get, list and create methods.
    - AgentCard is a static resource with only a get method.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.SendMessage = channel.unary_unary(
                '/a2a.v1.A2AService/SendMessage',
                request_serializer=a2a__pb2.SendMessageRequest.SerializeToString,
                response_deserializer=a2a__pb2.SendMessageResponse.FromString,
                _registered_method=True)
        self.SendStreamingMessage = channel.unary_stream(
                '/a2a.v1.A2AService/SendStreamingMessage',
                request_serializer=a2a__pb2.SendMessageRequest.SerializeToString,
                response_deserializer=a2a__pb2.StreamResponse.FromString,
                _registered_method=True)
        self.GetTask = channel.unary_unary(
                '/a2a.v1.A2AService/GetTask',
                request_serializer=a2a__pb2.GetTaskRequest.SerializeToString,
                response_deserializer=a2a__pb2.Task.FromString,
                _registered_method=True)
        self.CancelTask = channel.unary_unary(
                '/a2a.v1.A2AService/CancelTask',
                request_serializer=a2a__pb2.CancelTaskRequest.SerializeToString,
                response_deserializer=a2a__pb2.Task.FromString,
                _registered_method=True)
        self.TaskSubscription = channel.unary_stream(
                '/a2a.v1.A2AService/TaskSubscription',
                request_serializer=a2a__pb2.TaskSubscriptionRequest.SerializeToString,
                response_deserializer=a2a__pb2.StreamResponse.FromString,
                _registered_method=True)
        self.CreateTaskPushNotificationConfig = channel.unary_unary(
                '/a2a.v1.A2AService/CreateTaskPushNotificationConfig',
                request_serializer=a2a__pb2.CreateTaskPushNotificationConfigRequest.SerializeToString,
                response_deserializer=a2a__pb2.TaskPushNotificationConfig.FromString,
                _registered_method=True)
        self.GetTaskPushNotificationConfig = channel.unary_unary(
                '/a2a.v1.A2AService/GetTaskPushNotificationConfig',
                request_serializer=a2a__pb2.GetTaskPushNotificationConfigRequest.SerializeToString,
                response_deserializer=a2a__pb2.TaskPushNotificationConfig.FromString,
                _registered_method=True)
        self.ListTaskPushNotificationConfig = channel.unary_unary(
                '/a2a.v1.A2AService/ListTaskPushNotificationConfig',
                request_serializer=a2a__pb2.ListTaskPushNotificationConfigRequest.SerializeToString,
                response_deserializer=a2a__pb2.ListTaskPushNotificationConfigResponse.FromString,
                _registered_method=True)
        self.GetAgentCard = channel.unary_unary(
                '/a2a.v1.A2AService/GetAgentCard',
                request_serializer=a2a__pb2.GetAgentCardRequest.SerializeToString,
                response_deserializer=a2a__pb2.AgentCard.FromString,
                _registered_method=True)
        self.DeleteTaskPushNotificationConfig = channel.unary_unary(
                '/a2a.v1.A2AService/DeleteTaskPushNotificationConfig',
                request_serializer=a2a__pb2.DeleteTaskPushNotificationConfigRequest.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                _registered_method=True)


class A2AServiceServicer(object):
    """A2AService defines the gRPC version of the A2A protocol. This has a slightly
    different shape than the JSONRPC version to better conform to AIP-127,
    where appropriate. The nouns are AgentCard, Message, Task and
    TaskPushNotificationConfig.
    - Messages are not a standard resource so there is no get/delete/update/list
    interface, only a send and stream custom methods.
    - Tasks have a get interface and custom cancel and subscribe methods.
    - TaskPushNotificationConfig are a resource whose parent is a task.
    They have get, list and create methods.
    - AgentCard is a static resource with only a get method.
    """

    def SendMessage(self, request, context):
        """Send a message to the agent. This is a blocking call that will return the
        task once it is completed, or a LRO if requested.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SendStreamingMessage(self, request, context):
        """SendStreamingMessage is a streaming call that will return a stream of
        task update events until the Task is in an interrupted or terminal state.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetTask(self, request, context):
        """Get the current state of a task from the agent.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def CancelTask(self, request, context):
        """Cancel a task from the agent. If supported one should expect no
        more task updates for the task.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def TaskSubscription(self, request, context):
        """TaskSubscription is a streaming call that will return a stream of task
        update events. This attaches the stream to an existing in process task.
        If the task is complete the stream will return the completed task (like
        GetTask) and close the stream.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def CreateTaskPushNotificationConfig(self, request, context):
        """Set a push notification config for a task.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetTaskPushNotificationConfig(self, request, context):
        """Get a push notification config for a task.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ListTaskPushNotificationConfig(self, request, context):
        """Get a list of push notifications configured for a task.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetAgentCard(self, request, context):
        """GetAgentCard returns the agent card for the agent.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def DeleteTaskPushNotificationConfig(self, request, context):
        """Delete a push notification config for a task.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_A2AServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'SendMessage': grpc.unary_unary_rpc_method_handler(
                    servicer.SendMessage,
                    request_deserializer=a2a__pb2.SendMessageRequest.FromString,
                    response_serializer=a2a__pb2.SendMessageResponse.SerializeToString,
            ),
            'SendStreamingMessage': grpc.unary_stream_rpc_method_handler(
                    servicer.SendStreamingMessage,
                    request_deserializer=a2a__pb2.SendMessageRequest.FromString,
                    response_serializer=a2a__pb2.StreamResponse.SerializeToString,
            ),
            'GetTask': grpc.unary_unary_rpc_method_handler(
                    servicer.GetTask,
                    request_deserializer=a2a__pb2.GetTaskRequest.FromString,
                    response_serializer=a2a__pb2.Task.SerializeToString,
            ),
            'CancelTask': grpc.unary_unary_rpc_method_handler(
                    servicer.CancelTask,
                    request_deserializer=a2a__pb2.CancelTaskRequest.FromString,
                    response_serializer=a2a__pb2.Task.SerializeToString,
            ),
            'TaskSubscription': grpc.unary_stream_rpc_method_handler(
                    servicer.TaskSubscription,
                    request_deserializer=a2a__pb2.TaskSubscriptionRequest.FromString,
                    response_serializer=a2a__pb2.StreamResponse.SerializeToString,
            ),
            'CreateTaskPushNotificationConfig': grpc.unary_unary_rpc_method_handler(
                    servicer.CreateTaskPushNotificationConfig,
                    request_deserializer=a2a__pb2.CreateTaskPushNotificationConfigRequest.FromString,
                    response_serializer=a2a__pb2.TaskPushNotificationConfig.SerializeToString,
            ),
            'GetTaskPushNotificationConfig': grpc.unary_unary_rpc_method_handler(
                    servicer.GetTaskPushNotificationConfig,
                    request_deserializer=a2a__pb2.GetTaskPushNotificationConfigRequest.FromString,
                    response_serializer=a2a__pb2.TaskPushNotificationConfig.SerializeToString,
            ),
            'ListTaskPushNotificationConfig': grpc.unary_unary_rpc_method_handler(
                    servicer.ListTaskPushNotificationConfig,
                    request_deserializer=a2a__pb2.ListTaskPushNotificationConfigRequest.FromString,
                    response_serializer=a2a__pb2.ListTaskPushNotificationConfigResponse.SerializeToString,
            ),
            'GetAgentCard': grpc.unary_unary_rpc_method_handler(
                    servicer.GetAgentCard,
                    request_deserializer=a2a__pb2.GetAgentCardRequest.FromString,
                    response_serializer=a2a__pb2.AgentCard.SerializeToString,
            ),
            'DeleteTaskPushNotificationConfig': grpc.unary_unary_rpc_method_handler(
                    servicer.DeleteTaskPushNotificationConfig,
                    request_deserializer=a2a__pb2.DeleteTaskPushNotificationConfigRequest.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'a2a.v1.A2AService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('a2a.v1.A2AService', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class A2AService(object):
    """A2AService defines the gRPC version of the A2A protocol. This has a slightly
    different shape than the JSONRPC version to better conform to AIP-127,
    where appropriate. The nouns are AgentCard, Message, Task and
    TaskPushNotificationConfig.
    - Messages are not a standard resource so there is no get/delete/update/list
    interface, only a send and stream custom methods.
    - Tasks have a get interface and custom cancel and subscribe methods.
    - TaskPushNotificationConfig are a resource whose parent is a task.
    They have get, list and create methods.
    - AgentCard is a static resource with only a get method.
    """

    @staticmethod
    def SendMessage(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/a2a.v1.A2AService/SendMessage',
            a2a__pb2.SendMessageRequest.SerializeToString,
            a2a__pb2.SendMessageResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def SendStreamingMessage(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/a2a.v1.A2AService/SendStreamingMessage',
            a2a__pb2.SendMessageRequest.SerializeToString,
            a2a__pb2.StreamResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetTask(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/a2a.v1.A2AService/GetTask',
            a2a__pb2.GetTaskRequest.SerializeToString,
            a2a__pb2.Task.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def CancelTask(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/a2a.v1.A2AService/CancelTask',
            a2a__pb2.CancelTaskRequest.SerializeToString,
            a2a__pb2.Task.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def TaskSubscription(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/a2a.v1.A2AService/TaskSubscription',
            a2a__pb2.TaskSubscriptionRequest.SerializeToString,
            a2a__pb2.StreamResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def CreateTaskPushNotificationConfig(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/a2a.v1.A2AService/CreateTaskPushNotificationConfig',
            a2a__pb2.CreateTaskPushNotificationConfigRequest.SerializeToString,
            a2a__pb2.TaskPushNotificationConfig.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetTaskPushNotificationConfig(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/a2a.v1.A2AService/GetTaskPushNotificationConfig',
            a2a__pb2.GetTaskPushNotificationConfigRequest.SerializeToString,
            a2a__pb2.TaskPushNotificationConfig.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ListTaskPushNotificationConfig(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/a2a.v1.A2AService/ListTaskPushNotificationConfig',
            a2a__pb2.ListTaskPushNotificationConfigRequest.SerializeToString,
            a2a__pb2.ListTaskPushNotificationConfigResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetAgentCard(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/a2a.v1.A2AService/GetAgentCard',
            a2a__pb2.GetAgentCardRequest.SerializeToString,
            a2a__pb2.AgentCard.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def DeleteTaskPushNotificationConfig(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/a2a.v1.A2AService/DeleteTaskPushNotificationConfig',
            a2a__pb2.DeleteTaskPushNotificationConfigRequest.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)



---
File: /a2a-python/src/a2a/grpc/a2a_pb2.py
---

# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: a2a.proto
# Protobuf Python Version: 5.29.3
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    5,
    29,
    3,
    '',
    'a2a.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()


from google.api import annotations_pb2 as google_dot_api_dot_annotations__pb2
from google.api import client_pb2 as google_dot_api_dot_client__pb2
from google.api import field_behavior_pb2 as google_dot_api_dot_field__behavior__pb2
from google.protobuf import empty_pb2 as google_dot_protobuf_dot_empty__pb2
from google.protobuf import struct_pb2 as google_dot_protobuf_dot_struct__pb2
from google.protobuf import timestamp_pb2 as google_dot_protobuf_dot_timestamp__pb2


DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\ta2a.proto\x12\x06\x61\x32\x61.v1\x1a\x1cgoogle/api/annotations.proto\x1a\x17google/api/client.proto\x1a\x1fgoogle/api/field_behavior.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xde\x01\n\x18SendMessageConfiguration\x12\x32\n\x15\x61\x63\x63\x65pted_output_modes\x18\x01 \x03(\tR\x13\x61\x63\x63\x65ptedOutputModes\x12K\n\x11push_notification\x18\x02 \x01(\x0b\x32\x1e.a2a.v1.PushNotificationConfigR\x10pushNotification\x12%\n\x0ehistory_length\x18\x03 \x01(\x05R\rhistoryLength\x12\x1a\n\x08\x62locking\x18\x04 \x01(\x08R\x08\x62locking\"\xf1\x01\n\x04Task\x12\x0e\n\x02id\x18\x01 \x01(\tR\x02id\x12\x1d\n\ncontext_id\x18\x02 \x01(\tR\tcontextId\x12*\n\x06status\x18\x03 \x01(\x0b\x32\x12.a2a.v1.TaskStatusR\x06status\x12.\n\tartifacts\x18\x04 \x03(\x0b\x32\x10.a2a.v1.ArtifactR\tartifacts\x12)\n\x07history\x18\x05 \x03(\x0b\x32\x0f.a2a.v1.MessageR\x07history\x12\x33\n\x08metadata\x18\x06 \x01(\x0b\x32\x17.google.protobuf.StructR\x08metadata\"\x99\x01\n\nTaskStatus\x12\'\n\x05state\x18\x01 \x01(\x0e\x32\x11.a2a.v1.TaskStateR\x05state\x12(\n\x06update\x18\x02 \x01(\x0b\x32\x0f.a2a.v1.MessageR\x07message\x12\x38\n\ttimestamp\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.TimestampR\ttimestamp\"t\n\x04Part\x12\x14\n\x04text\x18\x01 \x01(\tH\x00R\x04text\x12&\n\x04\x66ile\x18\x02 \x01(\x0b\x32\x10.a2a.v1.FilePartH\x00R\x04\x66ile\x12&\n\x04\x64\x61ta\x18\x03 \x01(\x0b\x32\x10.a2a.v1.DataPartH\x00R\x04\x64\x61taB\x06\n\x04part\"\x93\x01\n\x08\x46ilePart\x12$\n\rfile_with_uri\x18\x01 \x01(\tH\x00R\x0b\x66ileWithUri\x12(\n\x0f\x66ile_with_bytes\x18\x02 \x01(\x0cH\x00R\rfileWithBytes\x12\x1b\n\tmime_type\x18\x03 \x01(\tR\x08mimeType\x12\x12\n\x04name\x18\x04 \x01(\tR\x04nameB\x06\n\x04\x66ile\"7\n\x08\x44\x61taPart\x12+\n\x04\x64\x61ta\x18\x01 \x01(\x0b\x32\x17.google.protobuf.StructR\x04\x64\x61ta\"\xff\x01\n\x07Message\x12\x1d\n\nmessage_id\x18\x01 \x01(\tR\tmessageId\x12\x1d\n\ncontext_id\x18\x02 \x01(\tR\tcontextId\x12\x17\n\x07task_id\x18\x03 \x01(\tR\x06taskId\x12 \n\x04role\x18\x04 \x01(\x0e\x32\x0c.a2a.v1.RoleR\x04role\x12&\n\x07\x63ontent\x18\x05 \x03(\x0b\x32\x0c.a2a.v1.PartR\x07\x63ontent\x12\x33\n\x08metadata\x18\x06 \x01(\x0b\x32\x17.google.protobuf.StructR\x08metadata\x12\x1e\n\nextensions\x18\x07 \x03(\tR\nextensions\"\xda\x01\n\x08\x41rtifact\x12\x1f\n\x0b\x61rtifact_id\x18\x01 \x01(\tR\nartifactId\x12\x12\n\x04name\x18\x03 \x01(\tR\x04name\x12 \n\x0b\x64\x65scription\x18\x04 \x01(\tR\x0b\x64\x65scription\x12\"\n\x05parts\x18\x05 \x03(\x0b\x32\x0c.a2a.v1.PartR\x05parts\x12\x33\n\x08metadata\x18\x06 \x01(\x0b\x32\x17.google.protobuf.StructR\x08metadata\x12\x1e\n\nextensions\x18\x07 \x03(\tR\nextensions\"\xc6\x01\n\x15TaskStatusUpdateEvent\x12\x17\n\x07task_id\x18\x01 \x01(\tR\x06taskId\x12\x1d\n\ncontext_id\x18\x02 \x01(\tR\tcontextId\x12*\n\x06status\x18\x03 \x01(\x0b\x32\x12.a2a.v1.TaskStatusR\x06status\x12\x14\n\x05\x66inal\x18\x04 \x01(\x08R\x05\x66inal\x12\x33\n\x08metadata\x18\x05 \x01(\x0b\x32\x17.google.protobuf.StructR\x08metadata\"\xeb\x01\n\x17TaskArtifactUpdateEvent\x12\x17\n\x07task_id\x18\x01 \x01(\tR\x06taskId\x12\x1d\n\ncontext_id\x18\x02 \x01(\tR\tcontextId\x12,\n\x08\x61rtifact\x18\x03 \x01(\x0b\x32\x10.a2a.v1.ArtifactR\x08\x61rtifact\x12\x16\n\x06\x61ppend\x18\x04 \x01(\x08R\x06\x61ppend\x12\x1d\n\nlast_chunk\x18\x05 \x01(\x08R\tlastChunk\x12\x33\n\x08metadata\x18\x06 \x01(\x0b\x32\x17.google.protobuf.StructR\x08metadata\"\x94\x01\n\x16PushNotificationConfig\x12\x0e\n\x02id\x18\x01 \x01(\tR\x02id\x12\x10\n\x03url\x18\x02 \x01(\tR\x03url\x12\x14\n\x05token\x18\x03 \x01(\tR\x05token\x12\x42\n\x0e\x61uthentication\x18\x04 \x01(\x0b\x32\x1a.a2a.v1.AuthenticationInfoR\x0e\x61uthentication\"P\n\x12\x41uthenticationInfo\x12\x18\n\x07schemes\x18\x01 \x03(\tR\x07schemes\x12 \n\x0b\x63redentials\x18\x02 \x01(\tR\x0b\x63redentials\"@\n\x0e\x41gentInterface\x12\x10\n\x03url\x18\x01 \x01(\tR\x03url\x12\x1c\n\ttransport\x18\x02 \x01(\tR\ttransport\"\xad\x07\n\tAgentCard\x12)\n\x10protocol_version\x18\x10 \x01(\tR\x0fprotocolVersion\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\x12 \n\x0b\x64\x65scription\x18\x02 \x01(\tR\x0b\x64\x65scription\x12\x10\n\x03url\x18\x03 \x01(\tR\x03url\x12/\n\x13preferred_transport\x18\x0e \x01(\tR\x12preferredTransport\x12K\n\x15\x61\x64\x64itional_interfaces\x18\x0f \x03(\x0b\x32\x16.a2a.v1.AgentInterfaceR\x14\x61\x64\x64itionalInterfaces\x12\x31\n\x08provider\x18\x04 \x01(\x0b\x32\x15.a2a.v1.AgentProviderR\x08provider\x12\x18\n\x07version\x18\x05 \x01(\tR\x07version\x12+\n\x11\x64ocumentation_url\x18\x06 \x01(\tR\x10\x64ocumentationUrl\x12=\n\x0c\x63\x61pabilities\x18\x07 \x01(\x0b\x32\x19.a2a.v1.AgentCapabilitiesR\x0c\x63\x61pabilities\x12Q\n\x10security_schemes\x18\x08 \x03(\x0b\x32&.a2a.v1.AgentCard.SecuritySchemesEntryR\x0fsecuritySchemes\x12,\n\x08security\x18\t \x03(\x0b\x32\x10.a2a.v1.SecurityR\x08security\x12.\n\x13\x64\x65\x66\x61ult_input_modes\x18\n \x03(\tR\x11\x64\x65\x66\x61ultInputModes\x12\x30\n\x14\x64\x65\x66\x61ult_output_modes\x18\x0b \x03(\tR\x12\x64\x65\x66\x61ultOutputModes\x12*\n\x06skills\x18\x0c \x03(\x0b\x32\x12.a2a.v1.AgentSkillR\x06skills\x12O\n$supports_authenticated_extended_card\x18\r \x01(\x08R!supportsAuthenticatedExtendedCard\x12:\n\nsignatures\x18\x11 \x03(\x0b\x32\x1a.a2a.v1.AgentCardSignatureR\nsignatures\x1aZ\n\x14SecuritySchemesEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12,\n\x05value\x18\x02 \x01(\x0b\x32\x16.a2a.v1.SecuritySchemeR\x05value:\x02\x38\x01\"E\n\rAgentProvider\x12\x10\n\x03url\x18\x01 \x01(\tR\x03url\x12\"\n\x0corganization\x18\x02 \x01(\tR\x0corganization\"\x98\x01\n\x11\x41gentCapabilities\x12\x1c\n\tstreaming\x18\x01 \x01(\x08R\tstreaming\x12-\n\x12push_notifications\x18\x02 \x01(\x08R\x11pushNotifications\x12\x36\n\nextensions\x18\x03 \x03(\x0b\x32\x16.a2a.v1.AgentExtensionR\nextensions\"\x91\x01\n\x0e\x41gentExtension\x12\x10\n\x03uri\x18\x01 \x01(\tR\x03uri\x12 \n\x0b\x64\x65scription\x18\x02 \x01(\tR\x0b\x64\x65scription\x12\x1a\n\x08required\x18\x03 \x01(\x08R\x08required\x12/\n\x06params\x18\x04 \x01(\x0b\x32\x17.google.protobuf.StructR\x06params\"\xf4\x01\n\nAgentSkill\x12\x0e\n\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n\x04name\x18\x02 \x01(\tR\x04name\x12 \n\x0b\x64\x65scription\x18\x03 \x01(\tR\x0b\x64\x65scription\x12\x12\n\x04tags\x18\x04 \x03(\tR\x04tags\x12\x1a\n\x08\x65xamples\x18\x05 \x03(\tR\x08\x65xamples\x12\x1f\n\x0binput_modes\x18\x06 \x03(\tR\ninputModes\x12!\n\x0coutput_modes\x18\x07 \x03(\tR\x0boutputModes\x12,\n\x08security\x18\x08 \x03(\x0b\x32\x10.a2a.v1.SecurityR\x08security\"\x8b\x01\n\x12\x41gentCardSignature\x12!\n\tprotected\x18\x01 \x01(\tB\x03\xe0\x41\x02R\tprotected\x12!\n\tsignature\x18\x02 \x01(\tB\x03\xe0\x41\x02R\tsignature\x12/\n\x06header\x18\x03 \x01(\x0b\x32\x17.google.protobuf.StructR\x06header\"\x8a\x01\n\x1aTaskPushNotificationConfig\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\x12X\n\x18push_notification_config\x18\x02 \x01(\x0b\x32\x1e.a2a.v1.PushNotificationConfigR\x16pushNotificationConfig\" \n\nStringList\x12\x12\n\x04list\x18\x01 \x03(\tR\x04list\"\x93\x01\n\x08Security\x12\x37\n\x07schemes\x18\x01 \x03(\x0b\x32\x1d.a2a.v1.Security.SchemesEntryR\x07schemes\x1aN\n\x0cSchemesEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12(\n\x05value\x18\x02 \x01(\x0b\x32\x12.a2a.v1.StringListR\x05value:\x02\x38\x01\"\xe6\x03\n\x0eSecurityScheme\x12U\n\x17\x61pi_key_security_scheme\x18\x01 \x01(\x0b\x32\x1c.a2a.v1.APIKeySecuritySchemeH\x00R\x14\x61piKeySecurityScheme\x12[\n\x19http_auth_security_scheme\x18\x02 \x01(\x0b\x32\x1e.a2a.v1.HTTPAuthSecuritySchemeH\x00R\x16httpAuthSecurityScheme\x12T\n\x16oauth2_security_scheme\x18\x03 \x01(\x0b\x32\x1c.a2a.v1.OAuth2SecuritySchemeH\x00R\x14oauth2SecurityScheme\x12k\n\x1fopen_id_connect_security_scheme\x18\x04 \x01(\x0b\x32#.a2a.v1.OpenIdConnectSecuritySchemeH\x00R\x1bopenIdConnectSecurityScheme\x12S\n\x14mtls_security_scheme\x18\x05 \x01(\x0b\x32\x1f.a2a.v1.MutualTlsSecuritySchemeH\x00R\x12mtlsSecuritySchemeB\x08\n\x06scheme\"h\n\x14\x41PIKeySecurityScheme\x12 \n\x0b\x64\x65scription\x18\x01 \x01(\tR\x0b\x64\x65scription\x12\x1a\n\x08location\x18\x02 \x01(\tR\x08location\x12\x12\n\x04name\x18\x03 \x01(\tR\x04name\"w\n\x16HTTPAuthSecurityScheme\x12 \n\x0b\x64\x65scription\x18\x01 \x01(\tR\x0b\x64\x65scription\x12\x16\n\x06scheme\x18\x02 \x01(\tR\x06scheme\x12#\n\rbearer_format\x18\x03 \x01(\tR\x0c\x62\x65\x61rerFormat\"\x92\x01\n\x14OAuth2SecurityScheme\x12 \n\x0b\x64\x65scription\x18\x01 \x01(\tR\x0b\x64\x65scription\x12(\n\x05\x66lows\x18\x02 \x01(\x0b\x32\x12.a2a.v1.OAuthFlowsR\x05\x66lows\x12.\n\x13oauth2_metadata_url\x18\x03 \x01(\tR\x11oauth2MetadataUrl\"n\n\x1bOpenIdConnectSecurityScheme\x12 \n\x0b\x64\x65scription\x18\x01 \x01(\tR\x0b\x64\x65scription\x12-\n\x13open_id_connect_url\x18\x02 \x01(\tR\x10openIdConnectUrl\";\n\x17MutualTlsSecurityScheme\x12 \n\x0b\x64\x65scription\x18\x01 \x01(\tR\x0b\x64\x65scription\"\xb0\x02\n\nOAuthFlows\x12S\n\x12\x61uthorization_code\x18\x01 \x01(\x0b\x32\".a2a.v1.AuthorizationCodeOAuthFlowH\x00R\x11\x61uthorizationCode\x12S\n\x12\x63lient_credentials\x18\x02 \x01(\x0b\x32\".a2a.v1.ClientCredentialsOAuthFlowH\x00R\x11\x63lientCredentials\x12\x37\n\x08implicit\x18\x03 \x01(\x0b\x32\x19.a2a.v1.ImplicitOAuthFlowH\x00R\x08implicit\x12\x37\n\x08password\x18\x04 \x01(\x0b\x32\x19.a2a.v1.PasswordOAuthFlowH\x00R\x08passwordB\x06\n\x04\x66low\"\x8a\x02\n\x1a\x41uthorizationCodeOAuthFlow\x12+\n\x11\x61uthorization_url\x18\x01 \x01(\tR\x10\x61uthorizationUrl\x12\x1b\n\ttoken_url\x18\x02 \x01(\tR\x08tokenUrl\x12\x1f\n\x0brefresh_url\x18\x03 \x01(\tR\nrefreshUrl\x12\x46\n\x06scopes\x18\x04 \x03(\x0b\x32..a2a.v1.AuthorizationCodeOAuthFlow.ScopesEntryR\x06scopes\x1a\x39\n\x0bScopesEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\xdd\x01\n\x1a\x43lientCredentialsOAuthFlow\x12\x1b\n\ttoken_url\x18\x01 \x01(\tR\x08tokenUrl\x12\x1f\n\x0brefresh_url\x18\x02 \x01(\tR\nrefreshUrl\x12\x46\n\x06scopes\x18\x03 \x03(\x0b\x32..a2a.v1.ClientCredentialsOAuthFlow.ScopesEntryR\x06scopes\x1a\x39\n\x0bScopesEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\xdb\x01\n\x11ImplicitOAuthFlow\x12+\n\x11\x61uthorization_url\x18\x01 \x01(\tR\x10\x61uthorizationUrl\x12\x1f\n\x0brefresh_url\x18\x02 \x01(\tR\nrefreshUrl\x12=\n\x06scopes\x18\x03 \x03(\x0b\x32%.a2a.v1.ImplicitOAuthFlow.ScopesEntryR\x06scopes\x1a\x39\n\x0bScopesEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\xcb\x01\n\x11PasswordOAuthFlow\x12\x1b\n\ttoken_url\x18\x01 \x01(\tR\x08tokenUrl\x12\x1f\n\x0brefresh_url\x18\x02 \x01(\tR\nrefreshUrl\x12=\n\x06scopes\x18\x03 \x03(\x0b\x32%.a2a.v1.PasswordOAuthFlow.ScopesEntryR\x06scopes\x1a\x39\n\x0bScopesEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\xc1\x01\n\x12SendMessageRequest\x12.\n\x07request\x18\x01 \x01(\x0b\x32\x0f.a2a.v1.MessageB\x03\xe0\x41\x02R\x07message\x12\x46\n\rconfiguration\x18\x02 \x01(\x0b\x32 .a2a.v1.SendMessageConfigurationR\rconfiguration\x12\x33\n\x08metadata\x18\x03 \x01(\x0b\x32\x17.google.protobuf.StructR\x08metadata\"P\n\x0eGetTaskRequest\x12\x17\n\x04name\x18\x01 \x01(\tB\x03\xe0\x41\x02R\x04name\x12%\n\x0ehistory_length\x18\x02 \x01(\x05R\rhistoryLength\"\'\n\x11\x43\x61ncelTaskRequest\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\":\n$GetTaskPushNotificationConfigRequest\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\"=\n\'DeleteTaskPushNotificationConfigRequest\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\"\xa9\x01\n\'CreateTaskPushNotificationConfigRequest\x12\x1b\n\x06parent\x18\x01 \x01(\tB\x03\xe0\x41\x02R\x06parent\x12 \n\tconfig_id\x18\x02 \x01(\tB\x03\xe0\x41\x02R\x08\x63onfigId\x12?\n\x06\x63onfig\x18\x03 \x01(\x0b\x32\".a2a.v1.TaskPushNotificationConfigB\x03\xe0\x41\x02R\x06\x63onfig\"-\n\x17TaskSubscriptionRequest\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\"{\n%ListTaskPushNotificationConfigRequest\x12\x16\n\x06parent\x18\x01 \x01(\tR\x06parent\x12\x1b\n\tpage_size\x18\x02 \x01(\x05R\x08pageSize\x12\x1d\n\npage_token\x18\x03 \x01(\tR\tpageToken\"\x15\n\x13GetAgentCardRequest\"m\n\x13SendMessageResponse\x12\"\n\x04task\x18\x01 \x01(\x0b\x32\x0c.a2a.v1.TaskH\x00R\x04task\x12\'\n\x03msg\x18\x02 \x01(\x0b\x32\x0f.a2a.v1.MessageH\x00R\x07messageB\t\n\x07payload\"\xfa\x01\n\x0eStreamResponse\x12\"\n\x04task\x18\x01 \x01(\x0b\x32\x0c.a2a.v1.TaskH\x00R\x04task\x12\'\n\x03msg\x18\x02 \x01(\x0b\x32\x0f.a2a.v1.MessageH\x00R\x07message\x12\x44\n\rstatus_update\x18\x03 \x01(\x0b\x32\x1d.a2a.v1.TaskStatusUpdateEventH\x00R\x0cstatusUpdate\x12J\n\x0f\x61rtifact_update\x18\x04 \x01(\x0b\x32\x1f.a2a.v1.TaskArtifactUpdateEventH\x00R\x0e\x61rtifactUpdateB\t\n\x07payload\"\x8e\x01\n&ListTaskPushNotificationConfigResponse\x12<\n\x07\x63onfigs\x18\x01 \x03(\x0b\x32\".a2a.v1.TaskPushNotificationConfigR\x07\x63onfigs\x12&\n\x0fnext_page_token\x18\x02 \x01(\tR\rnextPageToken*\xfa\x01\n\tTaskState\x12\x1a\n\x16TASK_STATE_UNSPECIFIED\x10\x00\x12\x18\n\x14TASK_STATE_SUBMITTED\x10\x01\x12\x16\n\x12TASK_STATE_WORKING\x10\x02\x12\x18\n\x14TASK_STATE_COMPLETED\x10\x03\x12\x15\n\x11TASK_STATE_FAILED\x10\x04\x12\x18\n\x14TASK_STATE_CANCELLED\x10\x05\x12\x1d\n\x19TASK_STATE_INPUT_REQUIRED\x10\x06\x12\x17\n\x13TASK_STATE_REJECTED\x10\x07\x12\x1c\n\x18TASK_STATE_AUTH_REQUIRED\x10\x08*;\n\x04Role\x12\x14\n\x10ROLE_UNSPECIFIED\x10\x00\x12\r\n\tROLE_USER\x10\x01\x12\x0e\n\nROLE_AGENT\x10\x02\x32\xba\n\n\nA2AService\x12\x63\n\x0bSendMessage\x12\x1a.a2a.v1.SendMessageRequest\x1a\x1b.a2a.v1.SendMessageResponse\"\x1b\x82\xd3\xe4\x93\x02\x15\"\x10/v1/message:send:\x01*\x12k\n\x14SendStreamingMessage\x12\x1a.a2a.v1.SendMessageRequest\x1a\x16.a2a.v1.StreamResponse\"\x1d\x82\xd3\xe4\x93\x02\x17\"\x12/v1/message:stream:\x01*0\x01\x12R\n\x07GetTask\x12\x16.a2a.v1.GetTaskRequest\x1a\x0c.a2a.v1.Task\"!\xda\x41\x04name\x82\xd3\xe4\x93\x02\x14\x12\x12/v1/{name=tasks/*}\x12[\n\nCancelTask\x12\x19.a2a.v1.CancelTaskRequest\x1a\x0c.a2a.v1.Task\"$\x82\xd3\xe4\x93\x02\x1e\"\x19/v1/{name=tasks/*}:cancel:\x01*\x12s\n\x10TaskSubscription\x12\x1f.a2a.v1.TaskSubscriptionRequest\x1a\x16.a2a.v1.StreamResponse\"$\x82\xd3\xe4\x93\x02\x1e\x12\x1c/v1/{name=tasks/*}:subscribe0\x01\x12\xc4\x01\n CreateTaskPushNotificationConfig\x12/.a2a.v1.CreateTaskPushNotificationConfigRequest\x1a\".a2a.v1.TaskPushNotificationConfig\"K\xda\x41\rparent,config\x82\xd3\xe4\x93\x02\x35\"+/v1/{parent=task/*/pushNotificationConfigs}:\x06\x63onfig\x12\xae\x01\n\x1dGetTaskPushNotificationConfig\x12,.a2a.v1.GetTaskPushNotificationConfigRequest\x1a\".a2a.v1.TaskPushNotificationConfig\";\xda\x41\x04name\x82\xd3\xe4\x93\x02.\x12,/v1/{name=tasks/*/pushNotificationConfigs/*}\x12\xbe\x01\n\x1eListTaskPushNotificationConfig\x12-.a2a.v1.ListTaskPushNotificationConfigRequest\x1a..a2a.v1.ListTaskPushNotificationConfigResponse\"=\xda\x41\x06parent\x82\xd3\xe4\x93\x02.\x12,/v1/{parent=tasks/*}/pushNotificationConfigs\x12P\n\x0cGetAgentCard\x12\x1b.a2a.v1.GetAgentCardRequest\x1a\x11.a2a.v1.AgentCard\"\x10\x82\xd3\xe4\x93\x02\n\x12\x08/v1/card\x12\xa8\x01\n DeleteTaskPushNotificationConfig\x12/.a2a.v1.DeleteTaskPushNotificationConfigRequest\x1a\x16.google.protobuf.Empty\";\xda\x41\x04name\x82\xd3\xe4\x93\x02.*,/v1/{name=tasks/*/pushNotificationConfigs/*}Bi\n\ncom.a2a.v1B\x08\x41\x32\x61ProtoP\x01Z\x18google.golang.org/a2a/v1\xa2\x02\x03\x41XX\xaa\x02\x06\x41\x32\x61.V1\xca\x02\x06\x41\x32\x61\\V1\xe2\x02\x12\x41\x32\x61\\V1\\GPBMetadata\xea\x02\x07\x41\x32\x61::V1b\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'a2a_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  _globals['DESCRIPTOR']._loaded_options = None
  _globals['DESCRIPTOR']._serialized_options = b'\n\ncom.a2a.v1B\010A2aProtoP\001Z\030google.golang.org/a2a/v1\242\002\003AXX\252\002\006A2a.V1\312\002\006A2a\\V1\342\002\022A2a\\V1\\GPBMetadata\352\002\007A2a::V1'
  _globals['_AGENTCARD_SECURITYSCHEMESENTRY']._loaded_options = None
  _globals['_AGENTCARD_SECURITYSCHEMESENTRY']._serialized_options = b'8\001'
  _globals['_AGENTCARDSIGNATURE'].fields_by_name['protected']._loaded_options = None
  _globals['_AGENTCARDSIGNATURE'].fields_by_name['protected']._serialized_options = b'\340A\002'
  _globals['_AGENTCARDSIGNATURE'].fields_by_name['signature']._loaded_options = None
  _globals['_AGENTCARDSIGNATURE'].fields_by_name['signature']._serialized_options = b'\340A\002'
  _globals['_SECURITY_SCHEMESENTRY']._loaded_options = None
  _globals['_SECURITY_SCHEMESENTRY']._serialized_options = b'8\001'
  _globals['_AUTHORIZATIONCODEOAUTHFLOW_SCOPESENTRY']._loaded_options = None
  _globals['_AUTHORIZATIONCODEOAUTHFLOW_SCOPESENTRY']._serialized_options = b'8\001'
  _globals['_CLIENTCREDENTIALSOAUTHFLOW_SCOPESENTRY']._loaded_options = None
  _globals['_CLIENTCREDENTIALSOAUTHFLOW_SCOPESENTRY']._serialized_options = b'8\001'
  _globals['_IMPLICITOAUTHFLOW_SCOPESENTRY']._loaded_options = None
  _globals['_IMPLICITOAUTHFLOW_SCOPESENTRY']._serialized_options = b'8\001'
  _globals['_PASSWORDOAUTHFLOW_SCOPESENTRY']._loaded_options = None
  _globals['_PASSWORDOAUTHFLOW_SCOPESENTRY']._serialized_options = b'8\001'
  _globals['_SENDMESSAGEREQUEST'].fields_by_name['request']._loaded_options = None
  _globals['_SENDMESSAGEREQUEST'].fields_by_name['request']._serialized_options = b'\340A\002'
  _globals['_GETTASKREQUEST'].fields_by_name['name']._loaded_options = None
  _globals['_GETTASKREQUEST'].fields_by_name['name']._serialized_options = b'\340A\002'
  _globals['_CREATETASKPUSHNOTIFICATIONCONFIGREQUEST'].fields_by_name['parent']._loaded_options = None
  _globals['_CREATETASKPUSHNOTIFICATIONCONFIGREQUEST'].fields_by_name['parent']._serialized_options = b'\340A\002'
  _globals['_CREATETASKPUSHNOTIFICATIONCONFIGREQUEST'].fields_by_name['config_id']._loaded_options = None
  _globals['_CREATETASKPUSHNOTIFICATIONCONFIGREQUEST'].fields_by_name['config_id']._serialized_options = b'\340A\002'
  _globals['_CREATETASKPUSHNOTIFICATIONCONFIGREQUEST'].fields_by_name['config']._loaded_options = None
  _globals['_CREATETASKPUSHNOTIFICATIONCONFIGREQUEST'].fields_by_name['config']._serialized_options = b'\340A\002'
  _globals['_A2ASERVICE'].methods_by_name['SendMessage']._loaded_options = None
  _globals['_A2ASERVICE'].methods_by_name['SendMessage']._serialized_options = b'\202\323\344\223\002\025\"\020/v1/message:send:\001*'
  _globals['_A2ASERVICE'].methods_by_name['SendStreamingMessage']._loaded_options = None
  _globals['_A2ASERVICE'].methods_by_name['SendStreamingMessage']._serialized_options = b'\202\323\344\223\002\027\"\022/v1/message:stream:\001*'
  _globals['_A2ASERVICE'].methods_by_name['GetTask']._loaded_options = None
  _globals['_A2ASERVICE'].methods_by_name['GetTask']._serialized_options = b'\332A\004name\202\323\344\223\002\024\022\022/v1/{name=tasks/*}'
  _globals['_A2ASERVICE'].methods_by_name['CancelTask']._loaded_options = None
  _globals['_A2ASERVICE'].methods_by_name['CancelTask']._serialized_options = b'\202\323\344\223\002\036\"\031/v1/{name=tasks/*}:cancel:\001*'
  _globals['_A2ASERVICE'].methods_by_name['TaskSubscription']._loaded_options = None
  _globals['_A2ASERVICE'].methods_by_name['TaskSubscription']._serialized_options = b'\202\323\344\223\002\036\022\034/v1/{name=tasks/*}:subscribe'
  _globals['_A2ASERVICE'].methods_by_name['CreateTaskPushNotificationConfig']._loaded_options = None
  _globals['_A2ASERVICE'].methods_by_name['CreateTaskPushNotificationConfig']._serialized_options = b'\332A\rparent,config\202\323\344\223\0025\"+/v1/{parent=task/*/pushNotificationConfigs}:\006config'
  _globals['_A2ASERVICE'].methods_by_name['GetTaskPushNotificationConfig']._loaded_options = None
  _globals['_A2ASERVICE'].methods_by_name['GetTaskPushNotificationConfig']._serialized_options = b'\332A\004name\202\323\344\223\002.\022,/v1/{name=tasks/*/pushNotificationConfigs/*}'
  _globals['_A2ASERVICE'].methods_by_name['ListTaskPushNotificationConfig']._loaded_options = None
  _globals['_A2ASERVICE'].methods_by_name['ListTaskPushNotificationConfig']._serialized_options = b'\332A\006parent\202\323\344\223\002.\022,/v1/{parent=tasks/*}/pushNotificationConfigs'
  _globals['_A2ASERVICE'].methods_by_name['GetAgentCard']._loaded_options = None
  _globals['_A2ASERVICE'].methods_by_name['GetAgentCard']._serialized_options = b'\202\323\344\223\002\n\022\010/v1/card'
  _globals['_A2ASERVICE'].methods_by_name['DeleteTaskPushNotificationConfig']._loaded_options = None
  _globals['_A2ASERVICE'].methods_by_name['DeleteTaskPushNotificationConfig']._serialized_options = b'\332A\004name\202\323\344\223\002.*,/v1/{name=tasks/*/pushNotificationConfigs/*}'
  _globals['_TASKSTATE']._serialized_start=7985
  _globals['_TASKSTATE']._serialized_end=8235
  _globals['_ROLE']._serialized_start=8237
  _globals['_ROLE']._serialized_end=8296
  _globals['_SENDMESSAGECONFIGURATION']._serialized_start=202
  _globals['_SENDMESSAGECONFIGURATION']._serialized_end=424
  _globals['_TASK']._serialized_start=427
  _globals['_TASK']._serialized_end=668
  _globals['_TASKSTATUS']._serialized_start=671
  _globals['_TASKSTATUS']._serialized_end=824
  _globals['_PART']._serialized_start=826
  _globals['_PART']._serialized_end=942
  _globals['_FILEPART']._serialized_start=945
  _globals['_FILEPART']._serialized_end=1092
  _globals['_DATAPART']._serialized_start=1094
  _globals['_DATAPART']._serialized_end=1149
  _globals['_MESSAGE']._serialized_start=1152
  _globals['_MESSAGE']._serialized_end=1407
  _globals['_ARTIFACT']._serialized_start=1410
  _globals['_ARTIFACT']._serialized_end=1628
  _globals['_TASKSTATUSUPDATEEVENT']._serialized_start=1631
  _globals['_TASKSTATUSUPDATEEVENT']._serialized_end=1829
  _globals['_TASKARTIFACTUPDATEEVENT']._serialized_start=1832
  _globals['_TASKARTIFACTUPDATEEVENT']._serialized_end=2067
  _globals['_PUSHNOTIFICATIONCONFIG']._serialized_start=2070
  _globals['_PUSHNOTIFICATIONCONFIG']._serialized_end=2218
  _globals['_AUTHENTICATIONINFO']._serialized_start=2220
  _globals['_AUTHENTICATIONINFO']._serialized_end=2300
  _globals['_AGENTINTERFACE']._serialized_start=2302
  _globals['_AGENTINTERFACE']._serialized_end=2366
  _globals['_AGENTCARD']._serialized_start=2369
  _globals['_AGENTCARD']._serialized_end=3310
  _globals['_AGENTCARD_SECURITYSCHEMESENTRY']._serialized_start=3220
  _globals['_AGENTCARD_SECURITYSCHEMESENTRY']._serialized_end=3310
  _globals['_AGENTPROVIDER']._serialized_start=3312
  _globals['_AGENTPROVIDER']._serialized_end=3381
  _globals['_AGENTCAPABILITIES']._serialized_start=3384
  _globals['_AGENTCAPABILITIES']._serialized_end=3536
  _globals['_AGENTEXTENSION']._serialized_start=3539
  _globals['_AGENTEXTENSION']._serialized_end=3684
  _globals['_AGENTSKILL']._serialized_start=3687
  _globals['_AGENTSKILL']._serialized_end=3931
  _globals['_AGENTCARDSIGNATURE']._serialized_start=3934
  _globals['_AGENTCARDSIGNATURE']._serialized_end=4073
  _globals['_TASKPUSHNOTIFICATIONCONFIG']._serialized_start=4076
  _globals['_TASKPUSHNOTIFICATIONCONFIG']._serialized_end=4214
  _globals['_STRINGLIST']._serialized_start=4216
  _globals['_STRINGLIST']._serialized_end=4248
  _globals['_SECURITY']._serialized_start=4251
  _globals['_SECURITY']._serialized_end=4398
  _globals['_SECURITY_SCHEMESENTRY']._serialized_start=4320
  _globals['_SECURITY_SCHEMESENTRY']._serialized_end=4398
  _globals['_SECURITYSCHEME']._serialized_start=4401
  _globals['_SECURITYSCHEME']._serialized_end=4887
  _globals['_APIKEYSECURITYSCHEME']._serialized_start=4889
  _globals['_APIKEYSECURITYSCHEME']._serialized_end=4993
  _globals['_HTTPAUTHSECURITYSCHEME']._serialized_start=4995
  _globals['_HTTPAUTHSECURITYSCHEME']._serialized_end=5114
  _globals['_OAUTH2SECURITYSCHEME']._serialized_start=5117
  _globals['_OAUTH2SECURITYSCHEME']._serialized_end=5263
  _globals['_OPENIDCONNECTSECURITYSCHEME']._serialized_start=5265
  _globals['_OPENIDCONNECTSECURITYSCHEME']._serialized_end=5375
  _globals['_MUTUALTLSSECURITYSCHEME']._serialized_start=5377
  _globals['_MUTUALTLSSECURITYSCHEME']._serialized_end=5436
  _globals['_OAUTHFLOWS']._serialized_start=5439
  _globals['_OAUTHFLOWS']._serialized_end=5743
  _globals['_AUTHORIZATIONCODEOAUTHFLOW']._serialized_start=5746
  _globals['_AUTHORIZATIONCODEOAUTHFLOW']._serialized_end=6012
  _globals['_AUTHORIZATIONCODEOAUTHFLOW_SCOPESENTRY']._serialized_start=5955
  _globals['_AUTHORIZATIONCODEOAUTHFLOW_SCOPESENTRY']._serialized_end=6012
  _globals['_CLIENTCREDENTIALSOAUTHFLOW']._serialized_start=6015
  _globals['_CLIENTCREDENTIALSOAUTHFLOW']._serialized_end=6236
  _globals['_CLIENTCREDENTIALSOAUTHFLOW_SCOPESENTRY']._serialized_start=5955
  _globals['_CLIENTCREDENTIALSOAUTHFLOW_SCOPESENTRY']._serialized_end=6012
  _globals['_IMPLICITOAUTHFLOW']._serialized_start=6239
  _globals['_IMPLICITOAUTHFLOW']._serialized_end=6458
  _globals['_IMPLICITOAUTHFLOW_SCOPESENTRY']._serialized_start=5955
  _globals['_IMPLICITOAUTHFLOW_SCOPESENTRY']._serialized_end=6012
  _globals['_PASSWORDOAUTHFLOW']._serialized_start=6461
  _globals['_PASSWORDOAUTHFLOW']._serialized_end=6664
  _globals['_PASSWORDOAUTHFLOW_SCOPESENTRY']._serialized_start=5955
  _globals['_PASSWORDOAUTHFLOW_SCOPESENTRY']._serialized_end=6012
  _globals['_SENDMESSAGEREQUEST']._serialized_start=6667
  _globals['_SENDMESSAGEREQUEST']._serialized_end=6860
  _globals['_GETTASKREQUEST']._serialized_start=6862
  _globals['_GETTASKREQUEST']._serialized_end=6942
  _globals['_CANCELTASKREQUEST']._serialized_start=6944
  _globals['_CANCELTASKREQUEST']._serialized_end=6983
  _globals['_GETTASKPUSHNOTIFICATIONCONFIGREQUEST']._serialized_start=6985
  _globals['_GETTASKPUSHNOTIFICATIONCONFIGREQUEST']._serialized_end=7043
  _globals['_DELETETASKPUSHNOTIFICATIONCONFIGREQUEST']._serialized_start=7045
  _globals['_DELETETASKPUSHNOTIFICATIONCONFIGREQUEST']._serialized_end=7106
  _globals['_CREATETASKPUSHNOTIFICATIONCONFIGREQUEST']._serialized_start=7109
  _globals['_CREATETASKPUSHNOTIFICATIONCONFIGREQUEST']._serialized_end=7278
  _globals['_TASKSUBSCRIPTIONREQUEST']._serialized_start=7280
  _globals['_TASKSUBSCRIPTIONREQUEST']._serialized_end=7325
  _globals['_LISTTASKPUSHNOTIFICATIONCONFIGREQUEST']._serialized_start=7327
  _globals['_LISTTASKPUSHNOTIFICATIONCONFIGREQUEST']._serialized_end=7450
  _globals['_GETAGENTCARDREQUEST']._serialized_start=7452
  _globals['_GETAGENTCARDREQUEST']._serialized_end=7473
  _globals['_SENDMESSAGERESPONSE']._serialized_start=7475
  _globals['_SENDMESSAGERESPONSE']._serialized_end=7584
  _globals['_STREAMRESPONSE']._serialized_start=7587
  _globals['_STREAMRESPONSE']._serialized_end=7837
  _globals['_LISTTASKPUSHNOTIFICATIONCONFIGRESPONSE']._serialized_start=7840
  _globals['_LISTTASKPUSHNOTIFICATIONCONFIGRESPONSE']._serialized_end=7982
  _globals['_A2ASERVICE']._serialized_start=8299
  _globals['_A2ASERVICE']._serialized_end=9637
# @@protoc_insertion_point(module_scope)



---
File: /a2a-python/src/a2a/server/agent_execution/__init__.py
---

"""Components for executing agent logic within the A2A server."""

from a2a.server.agent_execution.agent_executor import AgentExecutor
from a2a.server.agent_execution.context import RequestContext
from a2a.server.agent_execution.request_context_builder import (
    RequestContextBuilder,
)
from a2a.server.agent_execution.simple_request_context_builder import (
    SimpleRequestContextBuilder,
)


__all__ = [
    'AgentExecutor',
    'RequestContext',
    'RequestContextBuilder',
    'SimpleRequestContextBuilder',
]



---
File: /a2a-python/src/a2a/server/agent_execution/agent_executor.py
---

from abc import ABC, abstractmethod

from a2a.server.agent_execution.context import RequestContext
from a2a.server.events.event_queue import EventQueue


class AgentExecutor(ABC):
    """Agent Executor interface.

    Implementations of this interface contain the core logic of the agent,
    executing tasks based on requests and publishing updates to an event queue.
    """

    @abstractmethod
    async def execute(
        self, context: RequestContext, event_queue: EventQueue
    ) -> None:
        """Execute the agent's logic for a given request context.

        The agent should read necessary information from the `context` and
        publish `Task` or `Message` events, or `TaskStatusUpdateEvent` /
        `TaskArtifactUpdateEvent` to the `event_queue`. This method should
        return once the agent's execution for this request is complete or
        yields control (e.g., enters an input-required state).

        Args:
            context: The request context containing the message, task ID, etc.
            event_queue: The queue to publish events to.
        """

    @abstractmethod
    async def cancel(
        self, context: RequestContext, event_queue: EventQueue
    ) -> None:
        """Request the agent to cancel an ongoing task.

        The agent should attempt to stop the task identified by the task_id
        in the context and publish a `TaskStatusUpdateEvent` with state
        `TaskState.canceled` to the `event_queue`.

        Args:
            context: The request context containing the task ID to cancel.
            event_queue: The queue to publish the cancellation status update to.
        """



---
File: /a2a-python/src/a2a/server/agent_execution/context.py
---

import uuid

from typing import Any

from a2a.server.context import ServerCallContext
from a2a.types import (
    InvalidParamsError,
    Message,
    MessageSendConfiguration,
    MessageSendParams,
    Task,
)
from a2a.utils import get_message_text
from a2a.utils.errors import ServerError


class RequestContext:
    """Request Context.

    Holds information about the current request being processed by the server,
    including the incoming message, task and context identifiers, and related
    tasks.
    """

    def __init__(  # noqa: PLR0913
        self,
        request: MessageSendParams | None = None,
        task_id: str | None = None,
        context_id: str | None = None,
        task: Task | None = None,
        related_tasks: list[Task] | None = None,
        call_context: ServerCallContext | None = None,
    ):
        """Initializes the RequestContext.

        Args:
            request: The incoming `MessageSendParams` request payload.
            task_id: The ID of the task explicitly provided in the request or path.
            context_id: The ID of the context explicitly provided in the request or path.
            task: The existing `Task` object retrieved from the store, if any.
            related_tasks: A list of other tasks related to the current request (e.g., for tool use).
            call_context: The server call context associated with this request.
        """
        if related_tasks is None:
            related_tasks = []
        self._params = request
        self._task_id = task_id
        self._context_id = context_id
        self._current_task = task
        self._related_tasks = related_tasks
        self._call_context = call_context
        # If the task id and context id were provided, make sure they
        # match the request. Otherwise, create them
        if self._params:
            if task_id:
                self._params.message.task_id = task_id
                if task and task.id != task_id:
                    raise ServerError(InvalidParamsError(message='bad task id'))
            else:
                self._check_or_generate_task_id()
            if context_id:
                self._params.message.context_id = context_id
                if task and task.context_id != context_id:
                    raise ServerError(
                        InvalidParamsError(message='bad context id')
                    )
            else:
                self._check_or_generate_context_id()

    def get_user_input(self, delimiter: str = '\n') -> str:
        """Extracts text content from the user's message parts.

        Args:
            delimiter: The string to use when joining multiple text parts.

        Returns:
            A single string containing all text content from the user message,
            joined by the specified delimiter. Returns an empty string if no
            user message is present or if it contains no text parts.
        """
        if not self._params:
            return ''

        return get_message_text(self._params.message, delimiter)

    def attach_related_task(self, task: Task) -> None:
        """Attaches a related task to the context.

        This is useful for scenarios like tool execution where a new task
        might be spawned.

        Args:
            task: The `Task` object to attach.
        """
        self._related_tasks.append(task)

    @property
    def message(self) -> Message | None:
        """The incoming `Message` object from the request, if available."""
        return self._params.message if self._params else None

    @property
    def related_tasks(self) -> list[Task]:
        """A list of tasks related to the current request."""
        return self._related_tasks

    @property
    def current_task(self) -> Task | None:
        """The current `Task` object being processed."""
        return self._current_task

    @current_task.setter
    def current_task(self, task: Task) -> None:
        """Sets the current task object."""
        self._current_task = task

    @property
    def task_id(self) -> str | None:
        """The ID of the task associated with this context."""
        return self._task_id

    @property
    def context_id(self) -> str | None:
        """The ID of the conversation context associated with this task."""
        return self._context_id

    @property
    def configuration(self) -> MessageSendConfiguration | None:
        """The `MessageSendConfiguration` from the request, if available."""
        return self._params.configuration if self._params else None

    @property
    def call_context(self) -> ServerCallContext | None:
        """The server call context associated with this request."""
        return self._call_context

    @property
    def metadata(self) -> dict[str, Any]:
        """Metadata associated with the request, if available."""
        return self._params.metadata or {} if self._params else {}

    def add_activated_extension(self, uri: str) -> None:
        """Add an extension to the set of activated extensions for this request.

        This causes the extension to be indicated back to the client in the
        response.
        """
        if self._call_context:
            self._call_context.activated_extensions.add(uri)

    @property
    def requested_extensions(self) -> set[str]:
        """Extensions that the client requested to activate."""
        return (
            self._call_context.requested_extensions
            if self._call_context
            else set()
        )

    def _check_or_generate_task_id(self) -> None:
        """Ensures a task ID is present, generating one if necessary."""
        if not self._params:
            return

        if not self._task_id and not self._params.message.task_id:
            self._params.message.task_id = str(uuid.uuid4())
        if self._params.message.task_id:
            self._task_id = self._params.message.task_id

    def _check_or_generate_context_id(self) -> None:
        """Ensures a context ID is present, generating one if necessary."""
        if not self._params:
            return

        if not self._context_id and not self._params.message.context_id:
            self._params.message.context_id = str(uuid.uuid4())
        if self._params.message.context_id:
            self._context_id = self._params.message.context_id



---
File: /a2a-python/src/a2a/server/agent_execution/request_context_builder.py
---

from abc import ABC, abstractmethod

from a2a.server.agent_execution import RequestContext
from a2a.server.context import ServerCallContext
from a2a.types import MessageSendParams, Task


class RequestContextBuilder(ABC):
    """Builds request context to be supplied to agent executor."""

    @abstractmethod
    async def build(
        self,
        params: MessageSendParams | None = None,
        task_id: str | None = None,
        context_id: str | None = None,
        task: Task | None = None,
        context: ServerCallContext | None = None,
    ) -> RequestContext:
        pass



---
File: /a2a-python/src/a2a/server/agent_execution/simple_request_context_builder.py
---

import asyncio

from a2a.server.agent_execution import RequestContext, RequestContextBuilder
from a2a.server.context import ServerCallContext
from a2a.server.tasks import TaskStore
from a2a.types import MessageSendParams, Task


class SimpleRequestContextBuilder(RequestContextBuilder):
    """Builds request context and populates referred tasks."""

    def __init__(
        self,
        should_populate_referred_tasks: bool = False,
        task_store: TaskStore | None = None,
    ) -> None:
        """Initializes the SimpleRequestContextBuilder.

        Args:
            should_populate_referred_tasks: If True, the builder will fetch tasks
                referenced in `params.message.reference_task_ids` and populate the
                `related_tasks` field in the RequestContext. Defaults to False.
            task_store: The TaskStore instance to use for fetching referred tasks.
                Required if `should_populate_referred_tasks` is True.
        """
        self._task_store = task_store
        self._should_populate_referred_tasks = should_populate_referred_tasks

    async def build(
        self,
        params: MessageSendParams | None = None,
        task_id: str | None = None,
        context_id: str | None = None,
        task: Task | None = None,
        context: ServerCallContext | None = None,
    ) -> RequestContext:
        """Builds the request context for an agent execution.

        This method assembles the RequestContext object. If the builder was
        initialized with `should_populate_referred_tasks=True`, it fetches all tasks
        referenced in `params.message.reference_task_ids` from the `task_store`.

        Args:
            params: The parameters of the incoming message send request.
            task_id: The ID of the task being executed.
            context_id: The ID of the current execution context.
            task: The primary task object associated with the request.
            context: The server call context, containing metadata about the call.

        Returns:
            An instance of RequestContext populated with the provided information
            and potentially a list of related tasks.
        """
        related_tasks: list[Task] | None = None

        if (
            self._task_store
            and self._should_populate_referred_tasks
            and params
            and params.message.reference_task_ids
        ):
            tasks = await asyncio.gather(
                *[
                    self._task_store.get(task_id)
                    for task_id in params.message.reference_task_ids
                ]
            )
            related_tasks = [x for x in tasks if x is not None]

        return RequestContext(
            request=params,
            task_id=task_id,
            context_id=context_id,
            task=task,
            related_tasks=related_tasks,
            call_context=context,
        )



---
File: /a2a-python/src/a2a/server/apps/jsonrpc/__init__.py
---

"""A2A JSON-RPC Applications."""

from a2a.server.apps.jsonrpc.fastapi_app import A2AFastAPIApplication
from a2a.server.apps.jsonrpc.jsonrpc_app import (
    CallContextBuilder,
    DefaultCallContextBuilder,
    JSONRPCApplication,
    StarletteUserProxy,
)
from a2a.server.apps.jsonrpc.starlette_app import A2AStarletteApplication


__all__ = [
    'A2AFastAPIApplication',
    'A2AStarletteApplication',
    'CallContextBuilder',
    'DefaultCallContextBuilder',
    'JSONRPCApplication',
    'StarletteUserProxy',
]



---
File: /a2a-python/src/a2a/server/apps/jsonrpc/fastapi_app.py
---

import logging

from collections.abc import Callable
from typing import TYPE_CHECKING, Any


if TYPE_CHECKING:
    from fastapi import FastAPI

    _package_fastapi_installed = True
else:
    try:
        from fastapi import FastAPI

        _package_fastapi_installed = True
    except ImportError:
        FastAPI = Any

        _package_fastapi_installed = False

from a2a.server.apps.jsonrpc.jsonrpc_app import (
    CallContextBuilder,
    JSONRPCApplication,
)
from a2a.server.context import ServerCallContext
from a2a.server.request_handlers.jsonrpc_handler import RequestHandler
from a2a.types import A2ARequest, AgentCard
from a2a.utils.constants import (
    AGENT_CARD_WELL_KNOWN_PATH,
    DEFAULT_RPC_URL,
    EXTENDED_AGENT_CARD_PATH,
    PREV_AGENT_CARD_WELL_KNOWN_PATH,
)


logger = logging.getLogger(__name__)


class A2AFastAPI(FastAPI):
    """A FastAPI application that adds A2A-specific OpenAPI components."""

    _a2a_components_added: bool = False

    def openapi(self) -> dict[str, Any]:
        """Generates the OpenAPI schema for the application."""
        openapi_schema = super().openapi()
        if not self._a2a_components_added:
            a2a_request_schema = A2ARequest.model_json_schema(
                ref_template='#/components/schemas/{model}'
            )
            defs = a2a_request_schema.pop('$defs', {})
            component_schemas = openapi_schema.setdefault(
                'components', {}
            ).setdefault('schemas', {})
            component_schemas.update(defs)
            component_schemas['A2ARequest'] = a2a_request_schema
            self._a2a_components_added = True
        return openapi_schema


class A2AFastAPIApplication(JSONRPCApplication):
    """A FastAPI application implementing the A2A protocol server endpoints.

    Handles incoming JSON-RPC requests, routes them to the appropriate
    handler methods, and manages response generation including Server-Sent Events
    (SSE).
    """

    def __init__(  # noqa: PLR0913
        self,
        agent_card: AgentCard,
        http_handler: RequestHandler,
        extended_agent_card: AgentCard | None = None,
        context_builder: CallContextBuilder | None = None,
        card_modifier: Callable[[AgentCard], AgentCard] | None = None,
        extended_card_modifier: Callable[
            [AgentCard, ServerCallContext], AgentCard
        ]
        | None = None,
    ) -> None:
        """Initializes the A2AFastAPIApplication.

        Args:
            agent_card: The AgentCard describing the agent's capabilities.
            http_handler: The handler instance responsible for processing A2A
              requests via http.
            extended_agent_card: An optional, distinct AgentCard to be served
              at the authenticated extended card endpoint.
            context_builder: The CallContextBuilder used to construct the
              ServerCallContext passed to the http_handler. If None, no
              ServerCallContext is passed.
            card_modifier: An optional callback to dynamically modify the public
              agent card before it is served.
            extended_card_modifier: An optional callback to dynamically modify
              the extended agent card before it is served. It receives the
              call context.
        """
        if not _package_fastapi_installed:
            raise ImportError(
                'The `fastapi` package is required to use the `A2AFastAPIApplication`.'
                ' It can be added as a part of `a2a-sdk` optional dependencies,'
                ' `a2a-sdk[http-server]`.'
            )
        super().__init__(
            agent_card=agent_card,
            http_handler=http_handler,
            extended_agent_card=extended_agent_card,
            context_builder=context_builder,
            card_modifier=card_modifier,
            extended_card_modifier=extended_card_modifier,
        )

    def add_routes_to_app(
        self,
        app: FastAPI,
        agent_card_url: str = AGENT_CARD_WELL_KNOWN_PATH,
        rpc_url: str = DEFAULT_RPC_URL,
        extended_agent_card_url: str = EXTENDED_AGENT_CARD_PATH,
    ) -> None:
        """Adds the routes to the FastAPI application.

        Args:
            app: The FastAPI application to add the routes to.
            agent_card_url: The URL for the agent card endpoint.
            rpc_url: The URL for the A2A JSON-RPC endpoint.
            extended_agent_card_url: The URL for the authenticated extended agent card endpoint.
        """
        app.post(
            rpc_url,
            openapi_extra={
                'requestBody': {
                    'content': {
                        'application/json': {
                            'schema': {
                                '$ref': '#/components/schemas/A2ARequest'
                            }
                        }
                    },
                    'required': True,
                    'description': 'A2ARequest',
                }
            },
        )(self._handle_requests)
        app.get(agent_card_url)(self._handle_get_agent_card)

        if agent_card_url == AGENT_CARD_WELL_KNOWN_PATH:
            # For backward compatibility, serve the agent card at the deprecated path as well.
            # TODO: remove in a future release
            app.get(PREV_AGENT_CARD_WELL_KNOWN_PATH)(
                self._handle_get_agent_card
            )

        if self.agent_card.supports_authenticated_extended_card:
            app.get(extended_agent_card_url)(
                self._handle_get_authenticated_extended_agent_card
            )

    def build(
        self,
        agent_card_url: str = AGENT_CARD_WELL_KNOWN_PATH,
        rpc_url: str = DEFAULT_RPC_URL,
        extended_agent_card_url: str = EXTENDED_AGENT_CARD_PATH,
        **kwargs: Any,
    ) -> FastAPI:
        """Builds and returns the FastAPI application instance.

        Args:
            agent_card_url: The URL for the agent card endpoint.
            rpc_url: The URL for the A2A JSON-RPC endpoint.
            extended_agent_card_url: The URL for the authenticated extended agent card endpoint.
            **kwargs: Additional keyword arguments to pass to the FastAPI constructor.

        Returns:
            A configured FastAPI application instance.
        """
        app = A2AFastAPI(**kwargs)

        self.add_routes_to_app(
            app, agent_card_url, rpc_url, extended_agent_card_url
        )

        return app



---
File: /a2a-python/src/a2a/server/apps/jsonrpc/jsonrpc_app.py
---

import contextlib
import json
import logging
import traceback

from abc import ABC, abstractmethod
from collections.abc import AsyncGenerator, Callable
from typing import TYPE_CHECKING, Any

from pydantic import ValidationError

from a2a.auth.user import UnauthenticatedUser
from a2a.auth.user import User as A2AUser
from a2a.extensions.common import (
    HTTP_EXTENSION_HEADER,
    get_requested_extensions,
)
from a2a.server.context import ServerCallContext
from a2a.server.request_handlers.jsonrpc_handler import JSONRPCHandler
from a2a.server.request_handlers.request_handler import RequestHandler
from a2a.types import (
    A2AError,
    A2ARequest,
    AgentCard,
    CancelTaskRequest,
    DeleteTaskPushNotificationConfigRequest,
    GetAuthenticatedExtendedCardRequest,
    GetTaskPushNotificationConfigRequest,
    GetTaskRequest,
    InternalError,
    InvalidRequestError,
    JSONParseError,
    JSONRPCError,
    JSONRPCErrorResponse,
    JSONRPCRequest,
    JSONRPCResponse,
    ListTaskPushNotificationConfigRequest,
    SendMessageRequest,
    SendStreamingMessageRequest,
    SendStreamingMessageResponse,
    SetTaskPushNotificationConfigRequest,
    TaskResubscriptionRequest,
    UnsupportedOperationError,
)
from a2a.utils.constants import (
    AGENT_CARD_WELL_KNOWN_PATH,
    DEFAULT_RPC_URL,
    EXTENDED_AGENT_CARD_PATH,
    PREV_AGENT_CARD_WELL_KNOWN_PATH,
)
from a2a.utils.errors import MethodNotImplementedError


logger = logging.getLogger(__name__)

if TYPE_CHECKING:
    from fastapi import FastAPI
    from sse_starlette.sse import EventSourceResponse
    from starlette.applications import Starlette
    from starlette.authentication import BaseUser
    from starlette.exceptions import HTTPException
    from starlette.requests import Request
    from starlette.responses import JSONResponse, Response
    from starlette.status import HTTP_413_REQUEST_ENTITY_TOO_LARGE

    _package_starlette_installed = True
else:
    FastAPI = Any
    try:
        from sse_starlette.sse import EventSourceResponse
        from starlette.applications import Starlette
        from starlette.authentication import BaseUser
        from starlette.exceptions import HTTPException
        from starlette.requests import Request
        from starlette.responses import JSONResponse, Response
        from starlette.status import HTTP_413_REQUEST_ENTITY_TOO_LARGE

        _package_starlette_installed = True
    except ImportError:
        _package_starlette_installed = False
        # Provide placeholder types for runtime type hinting when dependencies are not installed.
        # These will not be used if the code path that needs them is guarded by _http_server_installed.
        EventSourceResponse = Any
        Starlette = Any
        BaseUser = Any
        HTTPException = Any
        Request = Any
        JSONResponse = Any
        Response = Any
        HTTP_413_REQUEST_ENTITY_TOO_LARGE = Any


class StarletteUserProxy(A2AUser):
    """Adapts the Starlette User class to the A2A user representation."""

    def __init__(self, user: BaseUser):
        self._user = user

    @property
    def is_authenticated(self) -> bool:
        """Returns whether the current user is authenticated."""
        return self._user.is_authenticated

    @property
    def user_name(self) -> str:
        """Returns the user name of the current user."""
        return self._user.display_name


class CallContextBuilder(ABC):
    """A class for building ServerCallContexts using the Starlette Request."""

    @abstractmethod
    def build(self, request: Request) -> ServerCallContext:
        """Builds a ServerCallContext from a Starlette Request."""


class DefaultCallContextBuilder(CallContextBuilder):
    """A default implementation of CallContextBuilder."""

    def build(self, request: Request) -> ServerCallContext:
        """Builds a ServerCallContext from a Starlette Request.

        Args:
            request: The incoming Starlette Request object.

        Returns:
            A ServerCallContext instance populated with user and state
            information from the request.
        """
        user: A2AUser = UnauthenticatedUser()
        state = {}
        with contextlib.suppress(Exception):
            user = StarletteUserProxy(request.user)
            state['auth'] = request.auth
        state['headers'] = dict(request.headers)
        return ServerCallContext(
            user=user,
            state=state,
            requested_extensions=get_requested_extensions(
                request.headers.getlist(HTTP_EXTENSION_HEADER)
            ),
        )


class JSONRPCApplication(ABC):
    """Base class for A2A JSONRPC applications.

    Handles incoming JSON-RPC requests, routes them to the appropriate
    handler methods, and manages response generation including Server-Sent Events
    (SSE).
    """

    def __init__(  # noqa: PLR0913
        self,
        agent_card: AgentCard,
        http_handler: RequestHandler,
        extended_agent_card: AgentCard | None = None,
        context_builder: CallContextBuilder | None = None,
        card_modifier: Callable[[AgentCard], AgentCard] | None = None,
        extended_card_modifier: Callable[
            [AgentCard, ServerCallContext], AgentCard
        ]
        | None = None,
    ) -> None:
        """Initializes the JSONRPCApplication.

        Args:
            agent_card: The AgentCard describing the agent's capabilities.
            http_handler: The handler instance responsible for processing A2A
              requests via http.
            extended_agent_card: An optional, distinct AgentCard to be served
              at the authenticated extended card endpoint.
            context_builder: The CallContextBuilder used to construct the
              ServerCallContext passed to the http_handler. If None, no
              ServerCallContext is passed.
            card_modifier: An optional callback to dynamically modify the public
              agent card before it is served.
            extended_card_modifier: An optional callback to dynamically modify
              the extended agent card before it is served. It receives the
              call context.
        """
        if not _package_starlette_installed:
            raise ImportError(
                'Packages `starlette` and `sse-starlette` are required to use the'
                ' `JSONRPCApplication`. They can be added as a part of `a2a-sdk`'
                ' optional dependencies, `a2a-sdk[http-server]`.'
            )
        self.agent_card = agent_card
        self.extended_agent_card = extended_agent_card
        self.card_modifier = card_modifier
        self.extended_card_modifier = extended_card_modifier
        self.handler = JSONRPCHandler(
            agent_card=agent_card,
            request_handler=http_handler,
            extended_agent_card=extended_agent_card,
            extended_card_modifier=extended_card_modifier,
        )
        if (
            self.agent_card.supports_authenticated_extended_card
            and self.extended_agent_card is None
            and self.extended_card_modifier is None
        ):
            logger.error(
                'AgentCard.supports_authenticated_extended_card is True, but no extended_agent_card was provided. The /agent/authenticatedExtendedCard endpoint will return 404.'
            )
        self._context_builder = context_builder or DefaultCallContextBuilder()

    def _generate_error_response(
        self, request_id: str | int | None, error: JSONRPCError | A2AError
    ) -> JSONResponse:
        """Creates a Starlette JSONResponse for a JSON-RPC error.

        Logs the error based on its type.

        Args:
            request_id: The ID of the request that caused the error.
            error: The `JSONRPCError` or `A2AError` object.

        Returns:
            A `JSONResponse` object formatted as a JSON-RPC error response.
        """
        error_resp = JSONRPCErrorResponse(
            id=request_id,
            error=error if isinstance(error, JSONRPCError) else error.root,
        )

        log_level = (
            logging.ERROR
            if not isinstance(error, A2AError)
            or isinstance(error.root, InternalError)
            else logging.WARNING
        )
        logger.log(
            log_level,
            f'Request Error (ID: {request_id}): '
            f"Code={error_resp.error.code}, Message='{error_resp.error.message}'"
            f'{", Data=" + str(error_resp.error.data) if error_resp.error.data else ""}',
        )
        return JSONResponse(
            error_resp.model_dump(mode='json', exclude_none=True),
            status_code=200,
        )

    async def _handle_requests(self, request: Request) -> Response:  # noqa: PLR0911
        """Handles incoming POST requests to the main A2A endpoint.

        Parses the request body as JSON, validates it against A2A request types,
        dispatches it to the appropriate handler method, and returns the response.
        Handles JSON parsing errors, validation errors, and other exceptions,
        returning appropriate JSON-RPC error responses.

        Args:
            request: The incoming Starlette Request object.

        Returns:
            A Starlette Response object (JSONResponse or EventSourceResponse).

        Raises:
            (Implicitly handled): Various exceptions are caught and converted
            into JSON-RPC error responses by this method.
        """
        request_id = None
        body = None

        try:
            body = await request.json()
            if isinstance(body, dict):
                request_id = body.get('id')

            # First, validate the basic JSON-RPC structure. This is crucial
            # because the A2ARequest model is a discriminated union where some
            # request types have default values for the 'method' field
            JSONRPCRequest.model_validate(body)

            a2a_request = A2ARequest.model_validate(body)

            call_context = self._context_builder.build(request)

            request_id = a2a_request.root.id
            request_obj = a2a_request.root

            if isinstance(
                request_obj,
                TaskResubscriptionRequest | SendStreamingMessageRequest,
            ):
                return await self._process_streaming_request(
                    request_id, a2a_request, call_context
                )

            return await self._process_non_streaming_request(
                request_id, a2a_request, call_context
            )
        except MethodNotImplementedError:
            traceback.print_exc()
            return self._generate_error_response(
                request_id, A2AError(root=UnsupportedOperationError())
            )
        except json.decoder.JSONDecodeError as e:
            traceback.print_exc()
            return self._generate_error_response(
                None, A2AError(root=JSONParseError(message=str(e)))
            )
        except ValidationError as e:
            traceback.print_exc()
            return self._generate_error_response(
                request_id,
                A2AError(root=InvalidRequestError(data=json.loads(e.json()))),
            )
        except HTTPException as e:
            if e.status_code == HTTP_413_REQUEST_ENTITY_TOO_LARGE:
                return self._generate_error_response(
                    request_id,
                    A2AError(
                        root=InvalidRequestError(message='Payload too large')
                    ),
                )
            raise e
        except Exception as e:
            logger.exception('Unhandled exception')
            return self._generate_error_response(
                request_id, A2AError(root=InternalError(message=str(e)))
            )

    async def _process_streaming_request(
        self,
        request_id: str | int | None,
        a2a_request: A2ARequest,
        context: ServerCallContext,
    ) -> Response:
        """Processes streaming requests (message/stream or tasks/resubscribe).

        Args:
            request_id: The ID of the request.
            a2a_request: The validated A2ARequest object.
            context: The ServerCallContext for the request.

        Returns:
            An `EventSourceResponse` object to stream results to the client.
        """
        request_obj = a2a_request.root
        handler_result: Any = None
        if isinstance(
            request_obj,
            SendStreamingMessageRequest,
        ):
            handler_result = self.handler.on_message_send_stream(
                request_obj, context
            )
        elif isinstance(request_obj, TaskResubscriptionRequest):
            handler_result = self.handler.on_resubscribe_to_task(
                request_obj, context
            )

        return self._create_response(context, handler_result)

    async def _process_non_streaming_request(
        self,
        request_id: str | int | None,
        a2a_request: A2ARequest,
        context: ServerCallContext,
    ) -> Response:
        """Processes non-streaming requests (message/send, tasks/get, tasks/cancel, tasks/pushNotificationConfig/*).

        Args:
            request_id: The ID of the request.
            a2a_request: The validated A2ARequest object.
            context: The ServerCallContext for the request.

        Returns:
            A `JSONResponse` object containing the result or error.
        """
        request_obj = a2a_request.root
        handler_result: Any = None
        match request_obj:
            case SendMessageRequest():
                handler_result = await self.handler.on_message_send(
                    request_obj, context
                )
            case CancelTaskRequest():
                handler_result = await self.handler.on_cancel_task(
                    request_obj, context
                )
            case GetTaskRequest():
                handler_result = await self.handler.on_get_task(
                    request_obj, context
                )
            case SetTaskPushNotificationConfigRequest():
                handler_result = (
                    await self.handler.set_push_notification_config(
                        request_obj,
                        context,
                    )
                )
            case GetTaskPushNotificationConfigRequest():
                handler_result = (
                    await self.handler.get_push_notification_config(
                        request_obj,
                        context,
                    )
                )
            case ListTaskPushNotificationConfigRequest():
                handler_result = (
                    await self.handler.list_push_notification_config(
                        request_obj,
                        context,
                    )
                )
            case DeleteTaskPushNotificationConfigRequest():
                handler_result = (
                    await self.handler.delete_push_notification_config(
                        request_obj,
                        context,
                    )
                )
            case GetAuthenticatedExtendedCardRequest():
                handler_result = (
                    await self.handler.get_authenticated_extended_card(
                        request_obj,
                        context,
                    )
                )
            case _:
                logger.error(
                    f'Unhandled validated request type: {type(request_obj)}'
                )
                error = UnsupportedOperationError(
                    message=f'Request type {type(request_obj).__name__} is unknown.'
                )
                handler_result = JSONRPCErrorResponse(
                    id=request_id, error=error
                )

        return self._create_response(context, handler_result)

    def _create_response(
        self,
        context: ServerCallContext,
        handler_result: (
            AsyncGenerator[SendStreamingMessageResponse]
            | JSONRPCErrorResponse
            | JSONRPCResponse
        ),
    ) -> Response:
        """Creates a Starlette Response based on the result from the request handler.

        Handles:
        - AsyncGenerator for Server-Sent Events (SSE).
        - JSONRPCErrorResponse for explicit errors returned by handlers.
        - Pydantic RootModels (like GetTaskResponse) containing success or error
        payloads.

        Args:
            context: The ServerCallContext provided to the request handler.
            handler_result: The result from a request handler method. Can be an
                async generator for streaming or a Pydantic model for non-streaming.

        Returns:
            A Starlette JSONResponse or EventSourceResponse.
        """
        headers = {}
        if exts := context.activated_extensions:
            headers[HTTP_EXTENSION_HEADER] = ', '.join(sorted(exts))
        if isinstance(handler_result, AsyncGenerator):
            # Result is a stream of SendStreamingMessageResponse objects
            async def event_generator(
                stream: AsyncGenerator[SendStreamingMessageResponse],
            ) -> AsyncGenerator[dict[str, str]]:
                async for item in stream:
                    yield {'data': item.root.model_dump_json(exclude_none=True)}

            return EventSourceResponse(
                event_generator(handler_result), headers=headers
            )
        if isinstance(handler_result, JSONRPCErrorResponse):
            return JSONResponse(
                handler_result.model_dump(
                    mode='json',
                    exclude_none=True,
                ),
                headers=headers,
            )

        return JSONResponse(
            handler_result.root.model_dump(mode='json', exclude_none=True),
            headers=headers,
        )

    async def _handle_get_agent_card(self, request: Request) -> JSONResponse:
        """Handles GET requests for the agent card endpoint.

        Args:
            request: The incoming Starlette Request object.

        Returns:
            A JSONResponse containing the agent card data.
        """
        if request.url.path == PREV_AGENT_CARD_WELL_KNOWN_PATH:
            logger.warning(
                f"Deprecated agent card endpoint '{PREV_AGENT_CARD_WELL_KNOWN_PATH}' accessed. "
                f"Please use '{AGENT_CARD_WELL_KNOWN_PATH}' instead. This endpoint will be removed in a future version."
            )

        card_to_serve = self.agent_card
        if self.card_modifier:
            card_to_serve = self.card_modifier(card_to_serve)

        return JSONResponse(
            card_to_serve.model_dump(
                exclude_none=True,
                by_alias=True,
            )
        )

    async def _handle_get_authenticated_extended_agent_card(
        self, request: Request
    ) -> JSONResponse:
        """Handles GET requests for the authenticated extended agent card."""
        logger.warning(
            'HTTP GET for authenticated extended card has been called by a client. '
            'This endpoint is deprecated in favor of agent/authenticatedExtendedCard JSON-RPC method and will be removed in a future release.'
        )
        if not self.agent_card.supports_authenticated_extended_card:
            return JSONResponse(
                {'error': 'Extended agent card not supported or not enabled.'},
                status_code=404,
            )

        card_to_serve = self.extended_agent_card

        if self.extended_card_modifier:
            context = self._context_builder.build(request)
            # If no base extended card is provided, pass the public card to the modifier
            base_card = card_to_serve if card_to_serve else self.agent_card
            card_to_serve = self.extended_card_modifier(base_card, context)

        if card_to_serve:
            return JSONResponse(
                card_to_serve.model_dump(
                    exclude_none=True,
                    by_alias=True,
                )
            )
        # If supports_authenticated_extended_card is true, but no
        # extended_agent_card was provided, and no modifier produced a card,
        # return a 404.
        return JSONResponse(
            {
                'error': 'Authenticated extended agent card is supported but not configured on the server.'
            },
            status_code=404,
        )

    @abstractmethod
    def build(
        self,
        agent_card_url: str = AGENT_CARD_WELL_KNOWN_PATH,
        rpc_url: str = DEFAULT_RPC_URL,
        extended_agent_card_url: str = EXTENDED_AGENT_CARD_PATH,
        **kwargs: Any,
    ) -> FastAPI | Starlette:
        """Builds and returns the JSONRPC application instance.

        Args:
            agent_card_url: The URL for the agent card endpoint.
            rpc_url: The URL for the A2A JSON-RPC endpoint.
            extended_agent_card_url: The URL for the authenticated extended
              agent card endpoint.
            **kwargs: Additional keyword arguments to pass to the FastAPI constructor.

        Returns:
            A configured JSONRPC application instance.
        """
        raise NotImplementedError(
            'Subclasses must implement the build method to create the application instance.'
        )



---
File: /a2a-python/src/a2a/server/apps/jsonrpc/starlette_app.py
---

import logging

from collections.abc import Callable
from typing import TYPE_CHECKING, Any


if TYPE_CHECKING:
    from starlette.applications import Starlette
    from starlette.routing import Route

    _package_starlette_installed = True

else:
    try:
        from starlette.applications import Starlette
        from starlette.routing import Route

        _package_starlette_installed = True
    except ImportError:
        Starlette = Any
        Route = Any

        _package_starlette_installed = False

from a2a.server.apps.jsonrpc.jsonrpc_app import (
    CallContextBuilder,
    JSONRPCApplication,
)
from a2a.server.context import ServerCallContext
from a2a.server.request_handlers.jsonrpc_handler import RequestHandler
from a2a.types import AgentCard
from a2a.utils.constants import (
    AGENT_CARD_WELL_KNOWN_PATH,
    DEFAULT_RPC_URL,
    EXTENDED_AGENT_CARD_PATH,
    PREV_AGENT_CARD_WELL_KNOWN_PATH,
)


logger = logging.getLogger(__name__)


class A2AStarletteApplication(JSONRPCApplication):
    """A Starlette application implementing the A2A protocol server endpoints.

    Handles incoming JSON-RPC requests, routes them to the appropriate
    handler methods, and manages response generation including Server-Sent Events
    (SSE).
    """

    def __init__(  # noqa: PLR0913
        self,
        agent_card: AgentCard,
        http_handler: RequestHandler,
        extended_agent_card: AgentCard | None = None,
        context_builder: CallContextBuilder | None = None,
        card_modifier: Callable[[AgentCard], AgentCard] | None = None,
        extended_card_modifier: Callable[
            [AgentCard, ServerCallContext], AgentCard
        ]
        | None = None,
    ) -> None:
        """Initializes the A2AStarletteApplication.

        Args:
            agent_card: The AgentCard describing the agent's capabilities.
            http_handler: The handler instance responsible for processing A2A
              requests via http.
            extended_agent_card: An optional, distinct AgentCard to be served
              at the authenticated extended card endpoint.
            context_builder: The CallContextBuilder used to construct the
              ServerCallContext passed to the http_handler. If None, no
              ServerCallContext is passed.
            card_modifier: An optional callback to dynamically modify the public
              agent card before it is served.
            extended_card_modifier: An optional callback to dynamically modify
              the extended agent card before it is served. It receives the
              call context.
        """
        if not _package_starlette_installed:
            raise ImportError(
                'Packages `starlette` and `sse-starlette` are required to use the'
                ' `A2AStarletteApplication`. It can be added as a part of `a2a-sdk`'
                ' optional dependencies, `a2a-sdk[http-server]`.'
            )
        super().__init__(
            agent_card=agent_card,
            http_handler=http_handler,
            extended_agent_card=extended_agent_card,
            context_builder=context_builder,
            card_modifier=card_modifier,
            extended_card_modifier=extended_card_modifier,
        )

    def routes(
        self,
        agent_card_url: str = AGENT_CARD_WELL_KNOWN_PATH,
        rpc_url: str = DEFAULT_RPC_URL,
        extended_agent_card_url: str = EXTENDED_AGENT_CARD_PATH,
    ) -> list[Route]:
        """Returns the Starlette Routes for handling A2A requests.

        Args:
            agent_card_url: The URL path for the agent card endpoint.
            rpc_url: The URL path for the A2A JSON-RPC endpoint (POST requests).
            extended_agent_card_url: The URL for the authenticated extended agent card endpoint.

        Returns:
            A list of Starlette Route objects.
        """
        app_routes = [
            Route(
                rpc_url,
                self._handle_requests,
                methods=['POST'],
                name='a2a_handler',
            ),
            Route(
                agent_card_url,
                self._handle_get_agent_card,
                methods=['GET'],
                name='agent_card',
            ),
        ]

        if agent_card_url == AGENT_CARD_WELL_KNOWN_PATH:
            # For backward compatibility, serve the agent card at the deprecated path as well.
            # TODO: remove in a future release
            app_routes.append(
                Route(
                    PREV_AGENT_CARD_WELL_KNOWN_PATH,
                    self._handle_get_agent_card,
                    methods=['GET'],
                    name='deprecated_agent_card',
                )
            )

        # TODO: deprecated endpoint to be removed in a future release
        if self.agent_card.supports_authenticated_extended_card:
            app_routes.append(
                Route(
                    extended_agent_card_url,
                    self._handle_get_authenticated_extended_agent_card,
                    methods=['GET'],
                    name='authenticated_extended_agent_card',
                )
            )
        return app_routes

    def add_routes_to_app(
        self,
        app: Starlette,
        agent_card_url: str = AGENT_CARD_WELL_KNOWN_PATH,
        rpc_url: str = DEFAULT_RPC_URL,
        extended_agent_card_url: str = EXTENDED_AGENT_CARD_PATH,
    ) -> None:
        """Adds the routes to the Starlette application.

        Args:
            app: The Starlette application to add the routes to.
            agent_card_url: The URL path for the agent card endpoint.
            rpc_url: The URL path for the A2A JSON-RPC endpoint (POST requests).
            extended_agent_card_url: The URL for the authenticated extended agent card endpoint.
        """
        routes = self.routes(
            agent_card_url=agent_card_url,
            rpc_url=rpc_url,
            extended_agent_card_url=extended_agent_card_url,
        )
        app.routes.extend(routes)

    def build(
        self,
        agent_card_url: str = AGENT_CARD_WELL_KNOWN_PATH,
        rpc_url: str = DEFAULT_RPC_URL,
        extended_agent_card_url: str = EXTENDED_AGENT_CARD_PATH,
        **kwargs: Any,
    ) -> Starlette:
        """Builds and returns the Starlette application instance.

        Args:
            agent_card_url: The URL path for the agent card endpoint.
            rpc_url: The URL path for the A2A JSON-RPC endpoint (POST requests).
            extended_agent_card_url: The URL for the authenticated extended agent card endpoint.
            **kwargs: Additional keyword arguments to pass to the Starlette constructor.

        Returns:
            A configured Starlette application instance.
        """
        app = Starlette(**kwargs)

        self.add_routes_to_app(
            app, agent_card_url, rpc_url, extended_agent_card_url
        )

        return app



---
File: /a2a-python/src/a2a/server/apps/rest/__init__.py
---

"""A2A REST Applications."""

from a2a.server.apps.rest.fastapi_app import A2ARESTFastAPIApplication


__all__ = [
    'A2ARESTFastAPIApplication',
]



---
File: /a2a-python/src/a2a/server/apps/rest/fastapi_app.py
---

import logging

from collections.abc import Callable
from typing import TYPE_CHECKING, Any


if TYPE_CHECKING:
    from fastapi import APIRouter, FastAPI, Request, Response
    from fastapi.responses import JSONResponse

    _package_fastapi_installed = True
else:
    try:
        from fastapi import APIRouter, FastAPI, Request, Response
        from fastapi.responses import JSONResponse

        _package_fastapi_installed = True
    except ImportError:
        APIRouter = Any
        FastAPI = Any
        Request = Any
        Response = Any

        _package_fastapi_installed = False


from a2a.server.apps.jsonrpc.jsonrpc_app import CallContextBuilder
from a2a.server.apps.rest.rest_adapter import RESTAdapter
from a2a.server.context import ServerCallContext
from a2a.server.request_handlers.request_handler import RequestHandler
from a2a.types import AgentCard
from a2a.utils.constants import AGENT_CARD_WELL_KNOWN_PATH


logger = logging.getLogger(__name__)


class A2ARESTFastAPIApplication:
    """A FastAPI application implementing the A2A protocol server REST endpoints.

    Handles incoming REST requests, routes them to the appropriate
    handler methods, and manages response generation including Server-Sent Events
    (SSE).
    """

    def __init__(  # noqa: PLR0913
        self,
        agent_card: AgentCard,
        http_handler: RequestHandler,
        extended_agent_card: AgentCard | None = None,
        context_builder: CallContextBuilder | None = None,
        card_modifier: Callable[[AgentCard], AgentCard] | None = None,
        extended_card_modifier: Callable[
            [AgentCard, ServerCallContext], AgentCard
        ]
        | None = None,
    ):
        """Initializes the A2ARESTFastAPIApplication.

        Args:
            agent_card: The AgentCard describing the agent's capabilities.
            http_handler: The handler instance responsible for processing A2A
              requests via http.
            extended_agent_card: An optional, distinct AgentCard to be served
              at the authenticated extended card endpoint.
            context_builder: The CallContextBuilder used to construct the
              ServerCallContext passed to the http_handler. If None, no
              ServerCallContext is passed.
            card_modifier: An optional callback to dynamically modify the public
              agent card before it is served.
            extended_card_modifier: An optional callback to dynamically modify
              the extended agent card before it is served. It receives the
              call context.
        """
        if not _package_fastapi_installed:
            raise ImportError(
                'The `fastapi` package is required to use the'
                ' `A2ARESTFastAPIApplication`. It can be added as a part of'
                ' `a2a-sdk` optional dependencies, `a2a-sdk[http-server]`.'
            )
        self._adapter = RESTAdapter(
            agent_card=agent_card,
            http_handler=http_handler,
            extended_agent_card=extended_agent_card,
            context_builder=context_builder,
            card_modifier=card_modifier,
            extended_card_modifier=extended_card_modifier,
        )

    def build(
        self,
        agent_card_url: str = AGENT_CARD_WELL_KNOWN_PATH,
        rpc_url: str = '',
        **kwargs: Any,
    ) -> FastAPI:
        """Builds and returns the FastAPI application instance.

        Args:
            agent_card_url: The URL for the agent card endpoint.
            rpc_url: The URL for the A2A JSON-RPC endpoint.
            extended_agent_card_url: The URL for the authenticated extended agent card endpoint.
            **kwargs: Additional keyword arguments to pass to the FastAPI constructor.

        Returns:
            A configured FastAPI application instance.
        """
        app = FastAPI(**kwargs)
        router = APIRouter()
        for route, callback in self._adapter.routes().items():
            router.add_api_route(
                f'{rpc_url}{route[0]}', callback, methods=[route[1]]
            )

        @router.get(f'{rpc_url}{agent_card_url}')
        async def get_agent_card(request: Request) -> Response:
            card = await self._adapter.handle_get_agent_card(request)
            return JSONResponse(card)

        app.include_router(router)
        return app



---
File: /a2a-python/src/a2a/server/apps/rest/rest_adapter.py
---

import functools
import logging

from collections.abc import AsyncIterable, AsyncIterator, Awaitable, Callable
from typing import TYPE_CHECKING, Any


if TYPE_CHECKING:
    from sse_starlette.sse import EventSourceResponse
    from starlette.requests import Request
    from starlette.responses import JSONResponse, Response

    _package_starlette_installed = True

else:
    try:
        from sse_starlette.sse import EventSourceResponse
        from starlette.requests import Request
        from starlette.responses import JSONResponse, Response

        _package_starlette_installed = True
    except ImportError:
        EventSourceResponse = Any
        Request = Any
        JSONResponse = Any
        Response = Any

        _package_starlette_installed = False

from a2a.server.apps.jsonrpc import (
    CallContextBuilder,
    DefaultCallContextBuilder,
)
from a2a.server.context import ServerCallContext
from a2a.server.request_handlers.request_handler import RequestHandler
from a2a.server.request_handlers.rest_handler import RESTHandler
from a2a.types import AgentCard, AuthenticatedExtendedCardNotConfiguredError
from a2a.utils.error_handlers import (
    rest_error_handler,
    rest_stream_error_handler,
)
from a2a.utils.errors import ServerError


logger = logging.getLogger(__name__)


class RESTAdapter:
    """Adapter to make RequestHandler work with RESTful API.

    Defines REST requests processors and the routes to attach them too, as well as
    manages response generation including Server-Sent Events (SSE).
    """

    def __init__(  # noqa: PLR0913
        self,
        agent_card: AgentCard,
        http_handler: RequestHandler,
        extended_agent_card: AgentCard | None = None,
        context_builder: CallContextBuilder | None = None,
        card_modifier: Callable[[AgentCard], AgentCard] | None = None,
        extended_card_modifier: Callable[
            [AgentCard, ServerCallContext], AgentCard
        ]
        | None = None,
    ):
        """Initializes the RESTApplication.

        Args:
            agent_card: The AgentCard describing the agent's capabilities.
            http_handler: The handler instance responsible for processing A2A
              requests via http.
            extended_agent_card: An optional, distinct AgentCard to be served
              at the authenticated extended card endpoint.
            context_builder: The CallContextBuilder used to construct the
              ServerCallContext passed to the http_handler. If None, no
              ServerCallContext is passed.
            card_modifier: An optional callback to dynamically modify the public
              agent card before it is served.
            extended_card_modifier: An optional callback to dynamically modify
              the extended agent card before it is served. It receives the
              call context.
        """
        if not _package_starlette_installed:
            raise ImportError(
                'Packages `starlette` and `sse-starlette` are required to use'
                ' the `RESTAdapter`. They can be added as a part of `a2a-sdk`'
                ' optional dependencies, `a2a-sdk[http-server]`.'
            )
        self.agent_card = agent_card
        self.extended_agent_card = extended_agent_card
        self.card_modifier = card_modifier
        self.extended_card_modifier = extended_card_modifier
        self.handler = RESTHandler(
            agent_card=agent_card, request_handler=http_handler
        )
        if (
            self.agent_card.supports_authenticated_extended_card
            and self.extended_agent_card is None
            and self.extended_card_modifier is None
        ):
            logger.error(
                'AgentCard.supports_authenticated_extended_card is True, but no extended_agent_card was provided. The /agent/authenticatedExtendedCard endpoint will return 404.'
            )
        self._context_builder = context_builder or DefaultCallContextBuilder()

    @rest_error_handler
    async def _handle_request(
        self,
        method: Callable[[Request, ServerCallContext], Awaitable[Any]],
        request: Request,
    ) -> Response:
        call_context = self._context_builder.build(request)
        response = await method(request, call_context)
        return JSONResponse(content=response)

    @rest_stream_error_handler
    async def _handle_streaming_request(
        self,
        method: Callable[[Request, ServerCallContext], AsyncIterable[Any]],
        request: Request,
    ) -> EventSourceResponse:
        call_context = self._context_builder.build(request)

        async def event_generator(
            stream: AsyncIterable[Any],
        ) -> AsyncIterator[dict[str, dict[str, Any]]]:
            async for item in stream:
                yield {'data': item}

        return EventSourceResponse(
            event_generator(method(request, call_context))
        )

    async def handle_get_agent_card(
        self, request: Request, call_context: ServerCallContext | None = None
    ) -> dict[str, Any]:
        """Handles GET requests for the agent card endpoint.

        Args:
            request: The incoming Starlette Request object.
            call_context: ServerCallContext

        Returns:
            A JSONResponse containing the agent card data.
        """
        card_to_serve = self.agent_card
        if self.card_modifier:
            card_to_serve = self.card_modifier(card_to_serve)

        return card_to_serve.model_dump(mode='json', exclude_none=True)

    async def handle_authenticated_agent_card(
        self, request: Request, call_context: ServerCallContext | None = None
    ) -> dict[str, Any]:
        """Hook for per credential agent card response.

        If a dynamic card is needed based on the credentials provided in the request
        override this method and return the customized content.

        Args:
            request: The incoming Starlette Request  object.
            call_context: ServerCallContext

        Returns:
            A JSONResponse containing the authenticated card.
        """
        if not self.agent_card.supports_authenticated_extended_card:
            raise ServerError(
                error=AuthenticatedExtendedCardNotConfiguredError(
                    message='Authenticated card not supported'
                )
            )
        card_to_serve = self.extended_agent_card

        if not card_to_serve:
            card_to_serve = self.agent_card

        if self.extended_card_modifier:
            context = self._context_builder.build(request)
            # If no base extended card is provided, pass the public card to the modifier
            base_card = card_to_serve if card_to_serve else self.agent_card
            card_to_serve = self.extended_card_modifier(base_card, context)

        return card_to_serve.model_dump(mode='json', exclude_none=True)

    def routes(self) -> dict[tuple[str, str], Callable[[Request], Any]]:
        """Constructs a dictionary of API routes and their corresponding handlers.

        This method maps URL paths and HTTP methods to the appropriate handler
        functions from the RESTHandler. It can be used by a web framework
        (like Starlette or FastAPI) to set up the application's endpoints.

        Returns:
            A dictionary where each key is a tuple of (path, http_method) and
            the value is the callable handler for that route.
        """
        routes: dict[tuple[str, str], Callable[[Request], Any]] = {
            ('/v1/message:send', 'POST'): functools.partial(
                self._handle_request, self.handler.on_message_send
            ),
            ('/v1/message:stream', 'POST'): functools.partial(
                self._handle_streaming_request,
                self.handler.on_message_send_stream,
            ),
            ('/v1/tasks/{id}:cancel', 'POST'): functools.partial(
                self._handle_request, self.handler.on_cancel_task
            ),
            ('/v1/tasks/{id}:subscribe', 'GET'): functools.partial(
                self._handle_streaming_request,
                self.handler.on_resubscribe_to_task,
            ),
            ('/v1/tasks/{id}', 'GET'): functools.partial(
                self._handle_request, self.handler.on_get_task
            ),
            (
                '/v1/tasks/{id}/pushNotificationConfigs/{push_id}',
                'GET',
            ): functools.partial(
                self._handle_request, self.handler.get_push_notification
            ),
            (
                '/v1/tasks/{id}/pushNotificationConfigs',
                'POST',
            ): functools.partial(
                self._handle_request, self.handler.set_push_notification
            ),
            (
                '/v1/tasks/{id}/pushNotificationConfigs',
                'GET',
            ): functools.partial(
                self._handle_request, self.handler.list_push_notifications
            ),
            ('/v1/tasks', 'GET'): functools.partial(
                self._handle_request, self.handler.list_tasks
            ),
        }
        if self.agent_card.supports_authenticated_extended_card:
            routes[('/v1/card', 'GET')] = functools.partial(
                self._handle_request, self.handle_authenticated_agent_card
            )

        return routes



---
File: /a2a-python/src/a2a/server/apps/__init__.py
---

"""HTTP application components for the A2A server."""

from a2a.server.apps.jsonrpc import (
    A2AFastAPIApplication,
    A2AStarletteApplication,
    CallContextBuilder,
    JSONRPCApplication,
)
from a2a.server.apps.rest import A2ARESTFastAPIApplication


__all__ = [
    'A2AFastAPIApplication',
    'A2ARESTFastAPIApplication',
    'A2AStarletteApplication',
    'CallContextBuilder',
    'JSONRPCApplication',
]



---
File: /a2a-python/src/a2a/server/events/__init__.py
---

"""Event handling components for the A2A server."""

from a2a.server.events.event_consumer import EventConsumer
from a2a.server.events.event_queue import Event, EventQueue
from a2a.server.events.in_memory_queue_manager import InMemoryQueueManager
from a2a.server.events.queue_manager import (
    NoTaskQueue,
    QueueManager,
    TaskQueueExists,
)


__all__ = [
    'Event',
    'EventConsumer',
    'EventQueue',
    'InMemoryQueueManager',
    'NoTaskQueue',
    'QueueManager',
    'TaskQueueExists',
]



---
File: /a2a-python/src/a2a/server/events/event_consumer.py
---

import asyncio
import logging
import sys

from collections.abc import AsyncGenerator

from pydantic import ValidationError

from a2a.server.events.event_queue import Event, EventQueue
from a2a.types import (
    InternalError,
    Message,
    Task,
    TaskState,
    TaskStatusUpdateEvent,
)
from a2a.utils.errors import ServerError
from a2a.utils.telemetry import SpanKind, trace_class


# This is an alias to the exception for closed queue
QueueClosed: type[Exception] = asyncio.QueueEmpty

# When using python 3.13 or higher, the closed queue signal is QueueShutdown
if sys.version_info >= (3, 13):
    QueueClosed = asyncio.QueueShutDown

logger = logging.getLogger(__name__)


@trace_class(kind=SpanKind.SERVER)
class EventConsumer:
    """Consumer to read events from the agent event queue."""

    def __init__(self, queue: EventQueue):
        """Initializes the EventConsumer.

        Args:
            queue: The `EventQueue` instance to consume events from.
        """
        self.queue = queue
        self._timeout = 0.5
        self._exception: BaseException | None = None
        logger.debug('EventConsumer initialized')

    async def consume_one(self) -> Event:
        """Consume one event from the agent event queue non-blocking.

        Returns:
            The next event from the queue.

        Raises:
            ServerError: If the queue is empty when attempting to dequeue
                immediately.
        """
        logger.debug('Attempting to consume one event.')
        try:
            event = await self.queue.dequeue_event(no_wait=True)
        except asyncio.QueueEmpty as e:
            logger.warning('Event queue was empty in consume_one.')
            raise ServerError(
                InternalError(message='Agent did not return any response')
            ) from e

        logger.debug(f'Dequeued event of type: {type(event)} in consume_one.')

        self.queue.task_done()

        return event

    async def consume_all(self) -> AsyncGenerator[Event]:
        """Consume all the generated streaming events from the agent.

        This method yields events as they become available from the queue
        until a final event is received or the queue is closed. It also
        monitors for exceptions set by the `agent_task_callback`.

        Yields:
            Events dequeued from the queue.

        Raises:
            BaseException: If an exception was set by the `agent_task_callback`.
        """
        logger.debug('Starting to consume all events from the queue.')
        while True:
            if self._exception:
                raise self._exception
            try:
                # We use a timeout when waiting for an event from the queue.
                # This is required because it allows the loop to check if
                # `self._exception` has been set by the `agent_task_callback`.
                # Without the timeout, loop might hang indefinitely if no events are
                # enqueued by the agent and the agent simply threw an exception
                event = await asyncio.wait_for(
                    self.queue.dequeue_event(), timeout=self._timeout
                )
                logger.debug(
                    f'Dequeued event of type: {type(event)} in consume_all.'
                )
                self.queue.task_done()
                logger.debug(
                    'Marked task as done in event queue in consume_all'
                )

                is_final_event = (
                    (isinstance(event, TaskStatusUpdateEvent) and event.final)
                    or isinstance(event, Message)
                    or (
                        isinstance(event, Task)
                        and event.status.state
                        in (
                            TaskState.completed,
                            TaskState.canceled,
                            TaskState.failed,
                            TaskState.rejected,
                            TaskState.unknown,
                            TaskState.input_required,
                        )
                    )
                )

                # Make sure the yield is after the close events, otherwise
                # the caller may end up in a blocked state where this
                # generator isn't called again to close things out and the
                # other part is waiting for an event or a closed queue.
                if is_final_event:
                    logger.debug('Stopping event consumption in consume_all.')
                    await self.queue.close()
                    yield event
                    break
                yield event
            except TimeoutError:
                # continue polling until there is a final event
                continue
            except asyncio.TimeoutError:  # pyright: ignore [reportUnusedExcept]
                # This class was made an alias of build-in TimeoutError after 3.11
                continue
            except QueueClosed:
                # Confirm that the queue is closed, e.g. we aren't on
                # python 3.12 and get a queue empty error on an open queue
                if self.queue.is_closed():
                    break
            except ValidationError:
                logger.exception('Invalid event format received')
                continue
            except Exception as e:
                logger.exception('Stopping event consumption due to exception')
                self._exception = e
                continue

    def agent_task_callback(self, agent_task: asyncio.Task[None]) -> None:
        """Callback to handle exceptions from the agent's execution task.

        If the agent's asyncio task raises an exception, this callback is
        invoked, and the exception is stored to be re-raised by the consumer loop.

        Args:
            agent_task: The asyncio.Task that completed.
        """
        logger.debug('Agent task callback triggered.')
        if not agent_task.cancelled() and agent_task.done():
            self._exception = agent_task.exception()



---
File: /a2a-python/src/a2a/server/events/event_queue.py
---

import asyncio
import logging
import sys

from a2a.types import (
    Message,
    Task,
    TaskArtifactUpdateEvent,
    TaskStatusUpdateEvent,
)
from a2a.utils.telemetry import SpanKind, trace_class


logger = logging.getLogger(__name__)


Event = Message | Task | TaskStatusUpdateEvent | TaskArtifactUpdateEvent
"""Type alias for events that can be enqueued."""

DEFAULT_MAX_QUEUE_SIZE = 1024


@trace_class(kind=SpanKind.SERVER)
class EventQueue:
    """Event queue for A2A responses from agent.

    Acts as a buffer between the agent's asynchronous execution and the
    server's response handling (e.g., streaming via SSE). Supports tapping
    to create child queues that receive the same events.
    """

    def __init__(self, max_queue_size: int = DEFAULT_MAX_QUEUE_SIZE) -> None:
        """Initializes the EventQueue."""
        # Make sure the `asyncio.Queue` is bounded.
        # If it's unbounded (maxsize=0), then `queue.put()` never needs to wait,
        # and so the streaming won't work correctly.
        if max_queue_size <= 0:
            raise ValueError('max_queue_size must be greater than 0')

        self.queue: asyncio.Queue[Event] = asyncio.Queue(maxsize=max_queue_size)
        self._children: list[EventQueue] = []
        self._is_closed = False
        self._lock = asyncio.Lock()
        logger.debug('EventQueue initialized.')

    async def enqueue_event(self, event: Event) -> None:
        """Enqueues an event to this queue and all its children.

        Args:
            event: The event object to enqueue.
        """
        async with self._lock:
            if self._is_closed:
                logger.warning('Queue is closed. Event will not be enqueued.')
                return

        logger.debug(f'Enqueuing event of type: {type(event)}')

        # Make sure to use put instead of put_nowait to avoid blocking the event loop.
        await self.queue.put(event)
        for child in self._children:
            await child.enqueue_event(event)

    async def dequeue_event(self, no_wait: bool = False) -> Event:
        """Dequeues an event from the queue.

        This implementation expects that dequeue to raise an exception when
        the queue has been closed. In python 3.13+ this is naturally provided
        by the QueueShutDown exception generated when the queue has closed and
        the user is awaiting the queue.get method. Python<=3.12 this needs to
        manage this lifecycle itself. The current implementation can lead to
        blocking if the dequeue_event is called before the EventQueue has been
        closed but when there are no events on the queue. Two ways to avoid this
        are to call this with no_wait = True which won't block, but is the
        callers responsibility to retry as appropriate. Alternatively, one can
        use a async Task management solution to cancel the get task if the queue
        has closed or some other condition is met. The implementation of the
        EventConsumer uses an async.wait with a timeout to abort the
        dequeue_event call and retry, when it will return with a closed error.

        Args:
            no_wait: If True, retrieve an event immediately or raise `asyncio.QueueEmpty`.
                     If False (default), wait until an event is available.

        Returns:
            The next event from the queue.

        Raises:
            asyncio.QueueEmpty: If `no_wait` is True and the queue is empty.
            asyncio.QueueShutDown: If the queue has been closed and is empty.
        """
        async with self._lock:
            if self._is_closed and self.queue.empty():
                logger.warning('Queue is closed. Event will not be dequeued.')
                raise asyncio.QueueEmpty('Queue is closed.')

        if no_wait:
            logger.debug('Attempting to dequeue event (no_wait=True).')
            event = self.queue.get_nowait()
            logger.debug(
                f'Dequeued event (no_wait=True) of type: {type(event)}'
            )
            return event

        logger.debug('Attempting to dequeue event (waiting).')
        event = await self.queue.get()
        logger.debug(f'Dequeued event (waited) of type: {type(event)}')
        return event

    def task_done(self) -> None:
        """Signals that a formerly enqueued task is complete.

        Used in conjunction with `dequeue_event` to track processed items.
        """
        logger.debug('Marking task as done in EventQueue.')
        self.queue.task_done()

    def tap(self) -> 'EventQueue':
        """Taps the event queue to create a new child queue that receives all future events.

        Returns:
            A new `EventQueue` instance that will receive all events enqueued
            to this parent queue from this point forward.
        """
        logger.debug('Tapping EventQueue to create a child queue.')
        queue = EventQueue()
        self._children.append(queue)
        return queue

    async def close(self) -> None:
        """Closes the queue for future push events.

        Once closed, `dequeue_event` will eventually raise `asyncio.QueueShutDown`
        when the queue is empty. Also closes all child queues.
        """
        logger.debug('Closing EventQueue.')
        async with self._lock:
            # If already closed, just return.
            if self._is_closed:
                return
            self._is_closed = True
        # If using python 3.13 or higher, use the shutdown method
        if sys.version_info >= (3, 13):
            self.queue.shutdown()
            for child in self._children:
                await child.close()
        # Otherwise, join the queue
        else:
            tasks = [asyncio.create_task(self.queue.join())]
            tasks.extend(
                asyncio.create_task(child.close()) for child in self._children
            )
            await asyncio.wait(tasks, return_when=asyncio.ALL_COMPLETED)

    def is_closed(self) -> bool:
        """Checks if the queue is closed."""
        return self._is_closed



---
File: /a2a-python/src/a2a/server/events/in_memory_queue_manager.py
---

import asyncio

from a2a.server.events.event_queue import EventQueue
from a2a.server.events.queue_manager import (
    NoTaskQueue,
    QueueManager,
    TaskQueueExists,
)
from a2a.utils.telemetry import SpanKind, trace_class


@trace_class(kind=SpanKind.SERVER)
class InMemoryQueueManager(QueueManager):
    """InMemoryQueueManager is used for a single binary management.

    This implements the `QueueManager` interface using in-memory storage for event
    queues. It requires all incoming interactions for a given task ID to hit the
    same binary instance.

    This implementation is suitable for single-instance deployments but needs
    a distributed approach for scalable deployments.
    """

    def __init__(self) -> None:
        """Initializes the InMemoryQueueManager."""
        self._task_queue: dict[str, EventQueue] = {}
        self._lock = asyncio.Lock()

    async def add(self, task_id: str, queue: EventQueue) -> None:
        """Adds a new event queue for a task ID.

        Raises:
            TaskQueueExists: If a queue for the given `task_id` already exists.
        """
        async with self._lock:
            if task_id in self._task_queue:
                raise TaskQueueExists
            self._task_queue[task_id] = queue

    async def get(self, task_id: str) -> EventQueue | None:
        """Retrieves the event queue for a task ID.

        Returns:
            The `EventQueue` instance for the `task_id`, or `None` if not found.
        """
        async with self._lock:
            if task_id not in self._task_queue:
                return None
            return self._task_queue[task_id]

    async def tap(self, task_id: str) -> EventQueue | None:
        """Taps the event queue for a task ID to create a child queue.

        Returns:
            A new child `EventQueue` instance, or `None` if the task ID is not found.
        """
        async with self._lock:
            if task_id not in self._task_queue:
                return None
            return self._task_queue[task_id].tap()

    async def close(self, task_id: str) -> None:
        """Closes and removes the event queue for a task ID.

        Raises:
            NoTaskQueue: If no queue exists for the given `task_id`.
        """
        async with self._lock:
            if task_id not in self._task_queue:
                raise NoTaskQueue
            queue = self._task_queue.pop(task_id)
            await queue.close()

    async def create_or_tap(self, task_id: str) -> EventQueue:
        """Creates a new event queue for a task ID if one doesn't exist, otherwise taps the existing one.

        Returns:
            A new or child `EventQueue` instance for the `task_id`.
        """
        async with self._lock:
            if task_id not in self._task_queue:
                queue = EventQueue()
                self._task_queue[task_id] = queue
                return queue
            return self._task_queue[task_id].tap()



---
File: /a2a-python/src/a2a/server/events/queue_manager.py
---

from abc import ABC, abstractmethod

from a2a.server.events.event_queue import EventQueue


class QueueManager(ABC):
    """Interface for managing the event queue lifecycles per task."""

    @abstractmethod
    async def add(self, task_id: str, queue: EventQueue) -> None:
        """Adds a new event queue associated with a task ID."""

    @abstractmethod
    async def get(self, task_id: str) -> EventQueue | None:
        """Retrieves the event queue for a task ID."""

    @abstractmethod
    async def tap(self, task_id: str) -> EventQueue | None:
        """Creates a child event queue (tap) for an existing task ID."""

    @abstractmethod
    async def close(self, task_id: str) -> None:
        """Closes and removes the event queue for a task ID."""

    @abstractmethod
    async def create_or_tap(self, task_id: str) -> EventQueue:
        """Creates a queue if one doesn't exist, otherwise taps the existing one."""


class TaskQueueExists(Exception):  # noqa: N818
    """Exception raised when attempting to add a queue for a task ID that already exists."""


class NoTaskQueue(Exception):  # noqa: N818
    """Exception raised when attempting to access or close a queue for a task ID that does not exist."""



---
File: /a2a-python/src/a2a/server/request_handlers/__init__.py
---

"""Request handler components for the A2A server."""

import logging

from a2a.server.request_handlers.default_request_handler import (
    DefaultRequestHandler,
)
from a2a.server.request_handlers.jsonrpc_handler import JSONRPCHandler
from a2a.server.request_handlers.request_handler import RequestHandler
from a2a.server.request_handlers.response_helpers import (
    build_error_response,
    prepare_response_object,
)
from a2a.server.request_handlers.rest_handler import RESTHandler


logger = logging.getLogger(__name__)

try:
    from a2a.server.request_handlers.grpc_handler import (
        GrpcHandler,  # type: ignore
    )
except ImportError as e:
    _original_error = e
    logger.debug(
        'GrpcHandler not loaded. This is expected if gRPC dependencies are not installed. Error: %s',
        _original_error,
    )

    class GrpcHandler:  # type: ignore
        """Placeholder for GrpcHandler when dependencies are not installed."""

        def __init__(self, *args, **kwargs):
            raise ImportError(
                'To use GrpcHandler, its dependencies must be installed. '
                'You can install them with \'pip install "a2a-sdk[grpc]"\''
            ) from _original_error


__all__ = [
    'DefaultRequestHandler',
    'GrpcHandler',
    'JSONRPCHandler',
    'RESTHandler',
    'RequestHandler',
    'build_error_response',
    'prepare_response_object',
]



---
File: /a2a-python/src/a2a/server/request_handlers/default_request_handler.py
---

import asyncio
import logging

from collections.abc import AsyncGenerator
from typing import cast

from a2a.server.agent_execution import (
    AgentExecutor,
    RequestContext,
    RequestContextBuilder,
    SimpleRequestContextBuilder,
)
from a2a.server.context import ServerCallContext
from a2a.server.events import (
    Event,
    EventConsumer,
    EventQueue,
    InMemoryQueueManager,
    QueueManager,
)
from a2a.server.request_handlers.request_handler import RequestHandler
from a2a.server.tasks import (
    PushNotificationConfigStore,
    PushNotificationSender,
    ResultAggregator,
    TaskManager,
    TaskStore,
)
from a2a.types import (
    DeleteTaskPushNotificationConfigParams,
    GetTaskPushNotificationConfigParams,
    InternalError,
    InvalidParamsError,
    ListTaskPushNotificationConfigParams,
    Message,
    MessageSendParams,
    Task,
    TaskIdParams,
    TaskNotFoundError,
    TaskPushNotificationConfig,
    TaskQueryParams,
    TaskState,
    UnsupportedOperationError,
)
from a2a.utils.errors import ServerError
from a2a.utils.telemetry import SpanKind, trace_class


logger = logging.getLogger(__name__)

TERMINAL_TASK_STATES = {
    TaskState.completed,
    TaskState.canceled,
    TaskState.failed,
    TaskState.rejected,
}


@trace_class(kind=SpanKind.SERVER)
class DefaultRequestHandler(RequestHandler):
    """Default request handler for all incoming requests.

    This handler provides default implementations for all A2A JSON-RPC methods,
    coordinating between the `AgentExecutor`, `TaskStore`, `QueueManager`,
    and optional `PushNotifier`.
    """

    _running_agents: dict[str, asyncio.Task]

    def __init__(  # noqa: PLR0913
        self,
        agent_executor: AgentExecutor,
        task_store: TaskStore,
        queue_manager: QueueManager | None = None,
        push_config_store: PushNotificationConfigStore | None = None,
        push_sender: PushNotificationSender | None = None,
        request_context_builder: RequestContextBuilder | None = None,
    ) -> None:
        """Initializes the DefaultRequestHandler.

        Args:
            agent_executor: The `AgentExecutor` instance to run agent logic.
            task_store: The `TaskStore` instance to manage task persistence.
            queue_manager: The `QueueManager` instance to manage event queues. Defaults to `InMemoryQueueManager`.
            push_config_store: The `PushNotificationConfigStore` instance for managing push notification configurations. Defaults to None.
            push_sender: The `PushNotificationSender` instance for sending push notifications. Defaults to None.
            request_context_builder: The `RequestContextBuilder` instance used
              to build request contexts. Defaults to `SimpleRequestContextBuilder`.
        """
        self.agent_executor = agent_executor
        self.task_store = task_store
        self._queue_manager = queue_manager or InMemoryQueueManager()
        self._push_config_store = push_config_store
        self._push_sender = push_sender
        self._request_context_builder = (
            request_context_builder
            or SimpleRequestContextBuilder(
                should_populate_referred_tasks=False, task_store=self.task_store
            )
        )
        # TODO: Likely want an interface for managing this, like AgentExecutionManager.
        self._running_agents = {}
        self._running_agents_lock = asyncio.Lock()

    async def on_get_task(
        self,
        params: TaskQueryParams,
        context: ServerCallContext | None = None,
    ) -> Task | None:
        """Default handler for 'tasks/get'."""
        task: Task | None = await self.task_store.get(params.id)
        if not task:
            raise ServerError(error=TaskNotFoundError())
        return task

    async def on_cancel_task(
        self, params: TaskIdParams, context: ServerCallContext | None = None
    ) -> Task | None:
        """Default handler for 'tasks/cancel'.

        Attempts to cancel the task managed by the `AgentExecutor`.
        """
        task: Task | None = await self.task_store.get(params.id)
        if not task:
            raise ServerError(error=TaskNotFoundError())

        task_manager = TaskManager(
            task_id=task.id,
            context_id=task.context_id,
            task_store=self.task_store,
            initial_message=None,
        )
        result_aggregator = ResultAggregator(task_manager)

        queue = await self._queue_manager.tap(task.id)
        if not queue:
            queue = EventQueue()

        await self.agent_executor.cancel(
            RequestContext(
                None,
                task_id=task.id,
                context_id=task.context_id,
                task=task,
            ),
            queue,
        )
        # Cancel the ongoing task, if one exists.
        if producer_task := self._running_agents.get(task.id):
            producer_task.cancel()

        consumer = EventConsumer(queue)
        result = await result_aggregator.consume_all(consumer)
        if isinstance(result, Task):
            return result

        raise ServerError(
            error=InternalError(
                message='Agent did not return valid response for cancel'
            )
        )

    async def _run_event_stream(
        self, request: RequestContext, queue: EventQueue
    ) -> None:
        """Runs the agent's `execute` method and closes the queue afterwards.

        Args:
            request: The request context for the agent.
            queue: The event queue for the agent to publish to.
        """
        await self.agent_executor.execute(request, queue)
        await queue.close()

    async def _setup_message_execution(
        self,
        params: MessageSendParams,
        context: ServerCallContext | None = None,
    ) -> tuple[TaskManager, str, EventQueue, ResultAggregator, asyncio.Task]:
        """Common setup logic for both streaming and non-streaming message handling.

        Returns:
            A tuple of (task_manager, task_id, queue, result_aggregator, producer_task)
        """
        # Create task manager and validate existing task
        task_manager = TaskManager(
            task_id=params.message.task_id,
            context_id=params.message.context_id,
            task_store=self.task_store,
            initial_message=params.message,
        )
        task: Task | None = await task_manager.get_task()

        if task:
            if task.status.state in TERMINAL_TASK_STATES:
                raise ServerError(
                    error=InvalidParamsError(
                        message=f'Task {task.id} is in terminal state: {task.status.state.value}'
                    )
                )

            task = task_manager.update_with_message(params.message, task)
        elif params.message.task_id:
            raise ServerError(
                error=TaskNotFoundError(
                    message=f'Task {params.message.task_id} was specified but does not exist'
                )
            )

        # Build request context
        request_context = await self._request_context_builder.build(
            params=params,
            task_id=task.id if task else None,
            context_id=params.message.context_id,
            task=task,
            context=context,
        )

        task_id = cast('str', request_context.task_id)
        # Always assign a task ID. We may not actually upgrade to a task, but
        # dictating the task ID at this layer is useful for tracking running
        # agents.

        if (
            self._push_config_store
            and params.configuration
            and params.configuration.push_notification_config
        ):
            await self._push_config_store.set_info(
                task_id, params.configuration.push_notification_config
            )

        queue = await self._queue_manager.create_or_tap(task_id)
        result_aggregator = ResultAggregator(task_manager)
        # TODO: to manage the non-blocking flows.
        producer_task = asyncio.create_task(
            self._run_event_stream(request_context, queue)
        )
        await self._register_producer(task_id, producer_task)

        return task_manager, task_id, queue, result_aggregator, producer_task

    def _validate_task_id_match(self, task_id: str, event_task_id: str) -> None:
        """Validates that agent-generated task ID matches the expected task ID."""
        if task_id != event_task_id:
            logger.error(
                f'Agent generated task_id={event_task_id} does not match the RequestContext task_id={task_id}.'
            )
            raise ServerError(
                InternalError(message='Task ID mismatch in agent response')
            )

    async def _send_push_notification_if_needed(
        self, task_id: str, result_aggregator: ResultAggregator
    ) -> None:
        """Sends push notification if configured and task is available."""
        if self._push_sender and task_id:
            latest_task = await result_aggregator.current_result
            if isinstance(latest_task, Task):
                await self._push_sender.send_notification(latest_task)

    async def on_message_send(
        self,
        params: MessageSendParams,
        context: ServerCallContext | None = None,
    ) -> Message | Task:
        """Default handler for 'message/send' interface (non-streaming).

        Starts the agent execution for the message and waits for the final
        result (Task or Message).
        """
        (
            task_manager,
            task_id,
            queue,
            result_aggregator,
            producer_task,
        ) = await self._setup_message_execution(params, context)

        consumer = EventConsumer(queue)
        producer_task.add_done_callback(consumer.agent_task_callback)

        blocking = True  # Default to blocking behavior
        if params.configuration and params.configuration.blocking is False:
            blocking = False

        interrupted_or_non_blocking = False
        try:
            (
                result,
                interrupted_or_non_blocking,
            ) = await result_aggregator.consume_and_break_on_interrupt(
                consumer, blocking=blocking
            )
            if not result:
                raise ServerError(error=InternalError())  # noqa: TRY301

            if isinstance(result, Task):
                self._validate_task_id_match(task_id, result.id)

            await self._send_push_notification_if_needed(
                task_id, result_aggregator
            )

        except Exception:
            logger.exception('Agent execution failed')
            raise
        finally:
            if interrupted_or_non_blocking:
                # TODO: Track this disconnected cleanup task.
                asyncio.create_task(  # noqa: RUF006
                    self._cleanup_producer(producer_task, task_id)
                )
            else:
                await self._cleanup_producer(producer_task, task_id)

        return result

    async def on_message_send_stream(
        self,
        params: MessageSendParams,
        context: ServerCallContext | None = None,
    ) -> AsyncGenerator[Event]:
        """Default handler for 'message/stream' (streaming).

        Starts the agent execution and yields events as they are produced
        by the agent.
        """
        (
            task_manager,
            task_id,
            queue,
            result_aggregator,
            producer_task,
        ) = await self._setup_message_execution(params, context)

        try:
            consumer = EventConsumer(queue)
            producer_task.add_done_callback(consumer.agent_task_callback)
            async for event in result_aggregator.consume_and_emit(consumer):
                if isinstance(event, Task):
                    self._validate_task_id_match(task_id, event.id)

                await self._send_push_notification_if_needed(
                    task_id, result_aggregator
                )
                yield event
        finally:
            await self._cleanup_producer(producer_task, task_id)

    async def _register_producer(
        self, task_id: str, producer_task: asyncio.Task
    ) -> None:
        """Registers the agent execution task with the handler."""
        async with self._running_agents_lock:
            self._running_agents[task_id] = producer_task

    async def _cleanup_producer(
        self,
        producer_task: asyncio.Task,
        task_id: str,
    ) -> None:
        """Cleans up the agent execution task and queue manager entry."""
        await producer_task
        await self._queue_manager.close(task_id)
        async with self._running_agents_lock:
            self._running_agents.pop(task_id, None)

    async def on_set_task_push_notification_config(
        self,
        params: TaskPushNotificationConfig,
        context: ServerCallContext | None = None,
    ) -> TaskPushNotificationConfig:
        """Default handler for 'tasks/pushNotificationConfig/set'.

        Requires a `PushNotifier` to be configured.
        """
        if not self._push_config_store:
            raise ServerError(error=UnsupportedOperationError())

        task: Task | None = await self.task_store.get(params.task_id)
        if not task:
            raise ServerError(error=TaskNotFoundError())

        await self._push_config_store.set_info(
            params.task_id,
            params.push_notification_config,
        )

        return params

    async def on_get_task_push_notification_config(
        self,
        params: TaskIdParams | GetTaskPushNotificationConfigParams,
        context: ServerCallContext | None = None,
    ) -> TaskPushNotificationConfig:
        """Default handler for 'tasks/pushNotificationConfig/get'.

        Requires a `PushConfigStore` to be configured.
        """
        if not self._push_config_store:
            raise ServerError(error=UnsupportedOperationError())

        task: Task | None = await self.task_store.get(params.id)
        if not task:
            raise ServerError(error=TaskNotFoundError())

        push_notification_config = await self._push_config_store.get_info(
            params.id
        )
        if not push_notification_config or not push_notification_config[0]:
            raise ServerError(
                error=InternalError(
                    message='Push notification config not found'
                )
            )

        return TaskPushNotificationConfig(
            task_id=params.id,
            push_notification_config=push_notification_config[0],
        )

    async def on_resubscribe_to_task(
        self,
        params: TaskIdParams,
        context: ServerCallContext | None = None,
    ) -> AsyncGenerator[Event]:
        """Default handler for 'tasks/resubscribe'.

        Allows a client to re-attach to a running streaming task's event stream.
        Requires the task and its queue to still be active.
        """
        task: Task | None = await self.task_store.get(params.id)
        if not task:
            raise ServerError(error=TaskNotFoundError())

        if task.status.state in TERMINAL_TASK_STATES:
            raise ServerError(
                error=InvalidParamsError(
                    message=f'Task {task.id} is in terminal state: {task.status.state.value}'
                )
            )

        task_manager = TaskManager(
            task_id=task.id,
            context_id=task.context_id,
            task_store=self.task_store,
            initial_message=None,
        )

        result_aggregator = ResultAggregator(task_manager)

        queue = await self._queue_manager.tap(task.id)
        if not queue:
            raise ServerError(error=TaskNotFoundError())

        consumer = EventConsumer(queue)
        async for event in result_aggregator.consume_and_emit(consumer):
            yield event

    async def on_list_task_push_notification_config(
        self,
        params: ListTaskPushNotificationConfigParams,
        context: ServerCallContext | None = None,
    ) -> list[TaskPushNotificationConfig]:
        """Default handler for 'tasks/pushNotificationConfig/list'.

        Requires a `PushConfigStore` to be configured.
        """
        if not self._push_config_store:
            raise ServerError(error=UnsupportedOperationError())

        task: Task | None = await self.task_store.get(params.id)
        if not task:
            raise ServerError(error=TaskNotFoundError())

        push_notification_config_list = await self._push_config_store.get_info(
            params.id
        )

        return [
            TaskPushNotificationConfig(
                task_id=params.id, push_notification_config=config
            )
            for config in push_notification_config_list
        ]

    async def on_delete_task_push_notification_config(
        self,
        params: DeleteTaskPushNotificationConfigParams,
        context: ServerCallContext | None = None,
    ) -> None:
        """Default handler for 'tasks/pushNotificationConfig/delete'.

        Requires a `PushConfigStore` to be configured.
        """
        if not self._push_config_store:
            raise ServerError(error=UnsupportedOperationError())

        task: Task | None = await self.task_store.get(params.id)
        if not task:
            raise ServerError(error=TaskNotFoundError())

        await self._push_config_store.delete_info(
            params.id, params.push_notification_config_id
        )



---
File: /a2a-python/src/a2a/server/request_handlers/grpc_handler.py
---

# ruff: noqa: N802
import contextlib
import logging

from abc import ABC, abstractmethod
from collections.abc import AsyncIterable, Sequence


try:
    import grpc
    import grpc.aio

    from grpc.aio import Metadata
except ImportError as e:
    raise ImportError(
        'GrpcHandler requires grpcio and grpcio-tools to be installed. '
        'Install with: '
        "'pip install a2a-sdk[grpc]'"
    ) from e

from collections.abc import Callable

import a2a.grpc.a2a_pb2_grpc as a2a_grpc

from a2a import types
from a2a.auth.user import UnauthenticatedUser
from a2a.extensions.common import (
    HTTP_EXTENSION_HEADER,
    get_requested_extensions,
)
from a2a.grpc import a2a_pb2
from a2a.server.context import ServerCallContext
from a2a.server.request_handlers.request_handler import RequestHandler
from a2a.types import AgentCard, TaskNotFoundError
from a2a.utils import proto_utils
from a2a.utils.errors import ServerError
from a2a.utils.helpers import validate, validate_async_generator


logger = logging.getLogger(__name__)

# For now we use a trivial wrapper on the grpc context object


class CallContextBuilder(ABC):
    """A class for building ServerCallContexts using the Starlette Request."""

    @abstractmethod
    def build(self, context: grpc.aio.ServicerContext) -> ServerCallContext:
        """Builds a ServerCallContext from a gRPC Request."""


def _get_metadata_value(
    context: grpc.aio.ServicerContext, key: str
) -> list[str]:
    md = context.invocation_metadata
    raw_values: list[str | bytes] = []
    if isinstance(md, Metadata):
        raw_values = md.get_all(key)
    elif isinstance(md, Sequence):
        lower_key = key.lower()
        raw_values = [e for (k, e) in md if k.lower() == lower_key]
    return [e if isinstance(e, str) else e.decode('utf-8') for e in raw_values]


class DefaultCallContextBuilder(CallContextBuilder):
    """A default implementation of CallContextBuilder."""

    def build(self, context: grpc.aio.ServicerContext) -> ServerCallContext:
        """Builds the ServerCallContext."""
        user = UnauthenticatedUser()
        state = {}
        with contextlib.suppress(Exception):
            state['grpc_context'] = context
        return ServerCallContext(
            user=user,
            state=state,
            requested_extensions=get_requested_extensions(
                _get_metadata_value(context, HTTP_EXTENSION_HEADER)
            ),
        )


class GrpcHandler(a2a_grpc.A2AServiceServicer):
    """Maps incoming gRPC requests to the appropriate request handler method."""

    def __init__(
        self,
        agent_card: AgentCard,
        request_handler: RequestHandler,
        context_builder: CallContextBuilder | None = None,
        card_modifier: Callable[[AgentCard], AgentCard] | None = None,
    ):
        """Initializes the GrpcHandler.

        Args:
            agent_card: The AgentCard describing the agent's capabilities.
            request_handler: The underlying `RequestHandler` instance to
                             delegate requests to.
            context_builder: The CallContextBuilder object. If none the
                             DefaultCallContextBuilder is used.
            card_modifier: An optional callback to dynamically modify the public
              agent card before it is served.
        """
        self.agent_card = agent_card
        self.request_handler = request_handler
        self.context_builder = context_builder or DefaultCallContextBuilder()
        self.card_modifier = card_modifier

    async def SendMessage(
        self,
        request: a2a_pb2.SendMessageRequest,
        context: grpc.aio.ServicerContext,
    ) -> a2a_pb2.SendMessageResponse:
        """Handles the 'SendMessage' gRPC method.

        Args:
            request: The incoming `SendMessageRequest` object.
            context: Context provided by the server.

        Returns:
            A `SendMessageResponse` object containing the result (Task or
            Message) or throws an error response if a `ServerError` is raised
            by the handler.
        """
        try:
            # Construct the server context object
            server_context = self.context_builder.build(context)
            # Transform the proto object to the python internal objects
            a2a_request = proto_utils.FromProto.message_send_params(
                request,
            )
            task_or_message = await self.request_handler.on_message_send(
                a2a_request, server_context
            )
            self._set_extension_metadata(context, server_context)
            return proto_utils.ToProto.task_or_message(task_or_message)
        except ServerError as e:
            await self.abort_context(e, context)
        return a2a_pb2.SendMessageResponse()

    @validate_async_generator(
        lambda self: self.agent_card.capabilities.streaming,
        'Streaming is not supported by the agent',
    )
    async def SendStreamingMessage(
        self,
        request: a2a_pb2.SendMessageRequest,
        context: grpc.aio.ServicerContext,
    ) -> AsyncIterable[a2a_pb2.StreamResponse]:
        """Handles the 'StreamMessage' gRPC method.

        Yields response objects as they are produced by the underlying handler's
        stream.

        Args:
            request: The incoming `SendMessageRequest` object.
            context: Context provided by the server.

        Yields:
            `StreamResponse` objects containing streaming events
            (Task, Message, TaskStatusUpdateEvent, TaskArtifactUpdateEvent)
            or gRPC error responses if a `ServerError` is raised.
        """
        server_context = self.context_builder.build(context)
        # Transform the proto object to the python internal objects
        a2a_request = proto_utils.FromProto.message_send_params(
            request,
        )
        try:
            async for event in self.request_handler.on_message_send_stream(
                a2a_request, server_context
            ):
                yield proto_utils.ToProto.stream_response(event)
            self._set_extension_metadata(context, server_context)
        except ServerError as e:
            await self.abort_context(e, context)
        return

    async def CancelTask(
        self,
        request: a2a_pb2.CancelTaskRequest,
        context: grpc.aio.ServicerContext,
    ) -> a2a_pb2.Task:
        """Handles the 'CancelTask' gRPC method.

        Args:
            request: The incoming `CancelTaskRequest` object.
            context: Context provided by the server.

        Returns:
            A `Task` object containing the updated Task or a gRPC error.
        """
        try:
            server_context = self.context_builder.build(context)
            task_id_params = proto_utils.FromProto.task_id_params(request)
            task = await self.request_handler.on_cancel_task(
                task_id_params, server_context
            )
            if task:
                return proto_utils.ToProto.task(task)
            await self.abort_context(
                ServerError(error=TaskNotFoundError()), context
            )
        except ServerError as e:
            await self.abort_context(e, context)
        return a2a_pb2.Task()

    @validate_async_generator(
        lambda self: self.agent_card.capabilities.streaming,
        'Streaming is not supported by the agent',
    )
    async def TaskSubscription(
        self,
        request: a2a_pb2.TaskSubscriptionRequest,
        context: grpc.aio.ServicerContext,
    ) -> AsyncIterable[a2a_pb2.StreamResponse]:
        """Handles the 'TaskSubscription' gRPC method.

        Yields response objects as they are produced by the underlying handler's
        stream.

        Args:
            request: The incoming `TaskSubscriptionRequest` object.
            context: Context provided by the server.

        Yields:
            `StreamResponse` objects containing streaming events
        """
        try:
            server_context = self.context_builder.build(context)
            async for event in self.request_handler.on_resubscribe_to_task(
                proto_utils.FromProto.task_id_params(request),
                server_context,
            ):
                yield proto_utils.ToProto.stream_response(event)
        except ServerError as e:
            await self.abort_context(e, context)

    async def GetTaskPushNotificationConfig(
        self,
        request: a2a_pb2.GetTaskPushNotificationConfigRequest,
        context: grpc.aio.ServicerContext,
    ) -> a2a_pb2.TaskPushNotificationConfig:
        """Handles the 'GetTaskPushNotificationConfig' gRPC method.

        Args:
            request: The incoming `GetTaskPushNotificationConfigRequest` object.
            context: Context provided by the server.

        Returns:
            A `TaskPushNotificationConfig` object containing the config.
        """
        try:
            server_context = self.context_builder.build(context)
            config = (
                await self.request_handler.on_get_task_push_notification_config(
                    proto_utils.FromProto.task_id_params(request),
                    server_context,
                )
            )
            return proto_utils.ToProto.task_push_notification_config(config)
        except ServerError as e:
            await self.abort_context(e, context)
        return a2a_pb2.TaskPushNotificationConfig()

    @validate(
        lambda self: self.agent_card.capabilities.push_notifications,
        'Push notifications are not supported by the agent',
    )
    async def CreateTaskPushNotificationConfig(
        self,
        request: a2a_pb2.CreateTaskPushNotificationConfigRequest,
        context: grpc.aio.ServicerContext,
    ) -> a2a_pb2.TaskPushNotificationConfig:
        """Handles the 'CreateTaskPushNotificationConfig' gRPC method.

        Requires the agent to support push notifications.

        Args:
            request: The incoming `CreateTaskPushNotificationConfigRequest` object.
            context: Context provided by the server.

        Returns:
            A `TaskPushNotificationConfig` object

        Raises:
            ServerError: If push notifications are not supported by the agent
                (due to the `@validate` decorator).
        """
        try:
            server_context = self.context_builder.build(context)
            config = (
                await self.request_handler.on_set_task_push_notification_config(
                    proto_utils.FromProto.task_push_notification_config_request(
                        request,
                    ),
                    server_context,
                )
            )
            return proto_utils.ToProto.task_push_notification_config(config)
        except ServerError as e:
            await self.abort_context(e, context)
        return a2a_pb2.TaskPushNotificationConfig()

    async def GetTask(
        self,
        request: a2a_pb2.GetTaskRequest,
        context: grpc.aio.ServicerContext,
    ) -> a2a_pb2.Task:
        """Handles the 'GetTask' gRPC method.

        Args:
            request: The incoming `GetTaskRequest` object.
            context: Context provided by the server.

        Returns:
            A `Task` object.
        """
        try:
            server_context = self.context_builder.build(context)
            task = await self.request_handler.on_get_task(
                proto_utils.FromProto.task_query_params(request), server_context
            )
            if task:
                return proto_utils.ToProto.task(task)
            await self.abort_context(
                ServerError(error=TaskNotFoundError()), context
            )
        except ServerError as e:
            await self.abort_context(e, context)
        return a2a_pb2.Task()

    async def GetAgentCard(
        self,
        request: a2a_pb2.GetAgentCardRequest,
        context: grpc.aio.ServicerContext,
    ) -> a2a_pb2.AgentCard:
        """Get the agent card for the agent served."""
        card_to_serve = self.agent_card
        if self.card_modifier:
            card_to_serve = self.card_modifier(card_to_serve)
        return proto_utils.ToProto.agent_card(card_to_serve)

    async def abort_context(
        self, error: ServerError, context: grpc.aio.ServicerContext
    ) -> None:
        """Sets the grpc errors appropriately in the context."""
        match error.error:
            case types.JSONParseError():
                await context.abort(
                    grpc.StatusCode.INTERNAL,
                    f'JSONParseError: {error.error.message}',
                )
            case types.InvalidRequestError():
                await context.abort(
                    grpc.StatusCode.INVALID_ARGUMENT,
                    f'InvalidRequestError: {error.error.message}',
                )
            case types.MethodNotFoundError():
                await context.abort(
                    grpc.StatusCode.NOT_FOUND,
                    f'MethodNotFoundError: {error.error.message}',
                )
            case types.InvalidParamsError():
                await context.abort(
                    grpc.StatusCode.INVALID_ARGUMENT,
                    f'InvalidParamsError: {error.error.message}',
                )
            case types.InternalError():
                await context.abort(
                    grpc.StatusCode.INTERNAL,
                    f'InternalError: {error.error.message}',
                )
            case types.TaskNotFoundError():
                await context.abort(
                    grpc.StatusCode.NOT_FOUND,
                    f'TaskNotFoundError: {error.error.message}',
                )
            case types.TaskNotCancelableError():
                await context.abort(
                    grpc.StatusCode.UNIMPLEMENTED,
                    f'TaskNotCancelableError: {error.error.message}',
                )
            case types.PushNotificationNotSupportedError():
                await context.abort(
                    grpc.StatusCode.UNIMPLEMENTED,
                    f'PushNotificationNotSupportedError: {error.error.message}',
                )
            case types.UnsupportedOperationError():
                await context.abort(
                    grpc.StatusCode.UNIMPLEMENTED,
                    f'UnsupportedOperationError: {error.error.message}',
                )
            case types.ContentTypeNotSupportedError():
                await context.abort(
                    grpc.StatusCode.UNIMPLEMENTED,
                    f'ContentTypeNotSupportedError: {error.error.message}',
                )
            case types.InvalidAgentResponseError():
                await context.abort(
                    grpc.StatusCode.INTERNAL,
                    f'InvalidAgentResponseError: {error.error.message}',
                )
            case _:
                await context.abort(
                    grpc.StatusCode.UNKNOWN,
                    f'Unknown error type: {error.error}',
                )

    def _set_extension_metadata(
        self,
        context: grpc.aio.ServicerContext,
        server_context: ServerCallContext,
    ) -> None:
        if server_context.activated_extensions:
            context.set_trailing_metadata(
                [
                    (HTTP_EXTENSION_HEADER, e)
                    for e in sorted(server_context.activated_extensions)
                ]
            )



---
File: /a2a-python/src/a2a/server/request_handlers/jsonrpc_handler.py
---

import logging

from collections.abc import AsyncIterable, Callable

from a2a.server.context import ServerCallContext
from a2a.server.request_handlers.request_handler import RequestHandler
from a2a.server.request_handlers.response_helpers import prepare_response_object
from a2a.types import (
    AgentCard,
    AuthenticatedExtendedCardNotConfiguredError,
    CancelTaskRequest,
    CancelTaskResponse,
    CancelTaskSuccessResponse,
    DeleteTaskPushNotificationConfigRequest,
    DeleteTaskPushNotificationConfigResponse,
    DeleteTaskPushNotificationConfigSuccessResponse,
    GetAuthenticatedExtendedCardRequest,
    GetAuthenticatedExtendedCardResponse,
    GetAuthenticatedExtendedCardSuccessResponse,
    GetTaskPushNotificationConfigRequest,
    GetTaskPushNotificationConfigResponse,
    GetTaskPushNotificationConfigSuccessResponse,
    GetTaskRequest,
    GetTaskResponse,
    GetTaskSuccessResponse,
    InternalError,
    JSONRPCErrorResponse,
    ListTaskPushNotificationConfigRequest,
    ListTaskPushNotificationConfigResponse,
    ListTaskPushNotificationConfigSuccessResponse,
    Message,
    SendMessageRequest,
    SendMessageResponse,
    SendMessageSuccessResponse,
    SendStreamingMessageRequest,
    SendStreamingMessageResponse,
    SendStreamingMessageSuccessResponse,
    SetTaskPushNotificationConfigRequest,
    SetTaskPushNotificationConfigResponse,
    SetTaskPushNotificationConfigSuccessResponse,
    Task,
    TaskArtifactUpdateEvent,
    TaskNotFoundError,
    TaskPushNotificationConfig,
    TaskResubscriptionRequest,
    TaskStatusUpdateEvent,
)
from a2a.utils.errors import ServerError
from a2a.utils.helpers import validate
from a2a.utils.telemetry import SpanKind, trace_class


logger = logging.getLogger(__name__)


@trace_class(kind=SpanKind.SERVER)
class JSONRPCHandler:
    """Maps incoming JSON-RPC requests to the appropriate request handler method and formats responses."""

    def __init__(
        self,
        agent_card: AgentCard,
        request_handler: RequestHandler,
        extended_agent_card: AgentCard | None = None,
        extended_card_modifier: Callable[
            [AgentCard, ServerCallContext], AgentCard
        ]
        | None = None,
    ):
        """Initializes the JSONRPCHandler.

        Args:
            agent_card: The AgentCard describing the agent's capabilities.
            request_handler: The underlying `RequestHandler` instance to delegate requests to.
            extended_agent_card: An optional, distinct Extended AgentCard to be served
            extended_card_modifier: An optional callback to dynamically modify
              the extended agent card before it is served. It receives the
              call context.
        """
        self.agent_card = agent_card
        self.request_handler = request_handler
        self.extended_agent_card = extended_agent_card
        self.extended_card_modifier = extended_card_modifier

    async def on_message_send(
        self,
        request: SendMessageRequest,
        context: ServerCallContext | None = None,
    ) -> SendMessageResponse:
        """Handles the 'message/send' JSON-RPC method.

        Args:
            request: The incoming `SendMessageRequest` object.
            context: Context provided by the server.

        Returns:
            A `SendMessageResponse` object containing the result (Task or Message)
            or a JSON-RPC error response if a `ServerError` is raised by the handler.
        """
        # TODO: Wrap in error handler to return error states
        try:
            task_or_message = await self.request_handler.on_message_send(
                request.params, context
            )
            return prepare_response_object(
                request.id,
                task_or_message,
                (Task, Message),
                SendMessageSuccessResponse,
                SendMessageResponse,
            )
        except ServerError as e:
            return SendMessageResponse(
                root=JSONRPCErrorResponse(
                    id=request.id, error=e.error if e.error else InternalError()
                )
            )

    @validate(
        lambda self: self.agent_card.capabilities.streaming,
        'Streaming is not supported by the agent',
    )
    async def on_message_send_stream(
        self,
        request: SendStreamingMessageRequest,
        context: ServerCallContext | None = None,
    ) -> AsyncIterable[SendStreamingMessageResponse]:
        """Handles the 'message/stream' JSON-RPC method.

        Yields response objects as they are produced by the underlying handler's stream.

        Args:
            request: The incoming `SendStreamingMessageRequest` object.
            context: Context provided by the server.

        Yields:
            `SendStreamingMessageResponse` objects containing streaming events
            (Task, Message, TaskStatusUpdateEvent, TaskArtifactUpdateEvent)
            or JSON-RPC error responses if a `ServerError` is raised.
        """
        try:
            async for event in self.request_handler.on_message_send_stream(
                request.params, context
            ):
                yield prepare_response_object(
                    request.id,
                    event,
                    (
                        Task,
                        Message,
                        TaskArtifactUpdateEvent,
                        TaskStatusUpdateEvent,
                    ),
                    SendStreamingMessageSuccessResponse,
                    SendStreamingMessageResponse,
                )
        except ServerError as e:
            yield SendStreamingMessageResponse(
                root=JSONRPCErrorResponse(
                    id=request.id, error=e.error if e.error else InternalError()
                )
            )

    async def on_cancel_task(
        self,
        request: CancelTaskRequest,
        context: ServerCallContext | None = None,
    ) -> CancelTaskResponse:
        """Handles the 'tasks/cancel' JSON-RPC method.

        Args:
            request: The incoming `CancelTaskRequest` object.
            context: Context provided by the server.

        Returns:
            A `CancelTaskResponse` object containing the updated Task or a JSON-RPC error.
        """
        try:
            task = await self.request_handler.on_cancel_task(
                request.params, context
            )
            if task:
                return prepare_response_object(
                    request.id,
                    task,
                    (Task,),
                    CancelTaskSuccessResponse,
                    CancelTaskResponse,
                )
            raise ServerError(error=TaskNotFoundError())  # noqa: TRY301
        except ServerError as e:
            return CancelTaskResponse(
                root=JSONRPCErrorResponse(
                    id=request.id, error=e.error if e.error else InternalError()
                )
            )

    async def on_resubscribe_to_task(
        self,
        request: TaskResubscriptionRequest,
        context: ServerCallContext | None = None,
    ) -> AsyncIterable[SendStreamingMessageResponse]:
        """Handles the 'tasks/resubscribe' JSON-RPC method.

        Yields response objects as they are produced by the underlying handler's stream.

        Args:
            request: The incoming `TaskResubscriptionRequest` object.
            context: Context provided by the server.

        Yields:
            `SendStreamingMessageResponse` objects containing streaming events
            or JSON-RPC error responses if a `ServerError` is raised.
        """
        try:
            async for event in self.request_handler.on_resubscribe_to_task(
                request.params, context
            ):
                yield prepare_response_object(
                    request.id,
                    event,
                    (
                        Task,
                        Message,
                        TaskArtifactUpdateEvent,
                        TaskStatusUpdateEvent,
                    ),
                    SendStreamingMessageSuccessResponse,
                    SendStreamingMessageResponse,
                )
        except ServerError as e:
            yield SendStreamingMessageResponse(
                root=JSONRPCErrorResponse(
                    id=request.id, error=e.error if e.error else InternalError()
                )
            )

    async def get_push_notification_config(
        self,
        request: GetTaskPushNotificationConfigRequest,
        context: ServerCallContext | None = None,
    ) -> GetTaskPushNotificationConfigResponse:
        """Handles the 'tasks/pushNotificationConfig/get' JSON-RPC method.

        Args:
            request: The incoming `GetTaskPushNotificationConfigRequest` object.
            context: Context provided by the server.

        Returns:
            A `GetTaskPushNotificationConfigResponse` object containing the config or a JSON-RPC error.
        """
        try:
            config = (
                await self.request_handler.on_get_task_push_notification_config(
                    request.params, context
                )
            )
            return prepare_response_object(
                request.id,
                config,
                (TaskPushNotificationConfig,),
                GetTaskPushNotificationConfigSuccessResponse,
                GetTaskPushNotificationConfigResponse,
            )
        except ServerError as e:
            return GetTaskPushNotificationConfigResponse(
                root=JSONRPCErrorResponse(
                    id=request.id, error=e.error if e.error else InternalError()
                )
            )

    @validate(
        lambda self: self.agent_card.capabilities.push_notifications,
        'Push notifications are not supported by the agent',
    )
    async def set_push_notification_config(
        self,
        request: SetTaskPushNotificationConfigRequest,
        context: ServerCallContext | None = None,
    ) -> SetTaskPushNotificationConfigResponse:
        """Handles the 'tasks/pushNotificationConfig/set' JSON-RPC method.

        Requires the agent to support push notifications.

        Args:
            request: The incoming `SetTaskPushNotificationConfigRequest` object.
            context: Context provided by the server.

        Returns:
            A `SetTaskPushNotificationConfigResponse` object containing the config or a JSON-RPC error.

        Raises:
            ServerError: If push notifications are not supported by the agent
                (due to the `@validate` decorator).
        """
        try:
            config = (
                await self.request_handler.on_set_task_push_notification_config(
                    request.params, context
                )
            )
            return prepare_response_object(
                request.id,
                config,
                (TaskPushNotificationConfig,),
                SetTaskPushNotificationConfigSuccessResponse,
                SetTaskPushNotificationConfigResponse,
            )
        except ServerError as e:
            return SetTaskPushNotificationConfigResponse(
                root=JSONRPCErrorResponse(
                    id=request.id, error=e.error if e.error else InternalError()
                )
            )

    async def on_get_task(
        self,
        request: GetTaskRequest,
        context: ServerCallContext | None = None,
    ) -> GetTaskResponse:
        """Handles the 'tasks/get' JSON-RPC method.

        Args:
            request: The incoming `GetTaskRequest` object.
            context: Context provided by the server.

        Returns:
            A `GetTaskResponse` object containing the Task or a JSON-RPC error.
        """
        try:
            task = await self.request_handler.on_get_task(
                request.params, context
            )
            if task:
                return prepare_response_object(
                    request.id,
                    task,
                    (Task,),
                    GetTaskSuccessResponse,
                    GetTaskResponse,
                )
            raise ServerError(error=TaskNotFoundError())  # noqa: TRY301
        except ServerError as e:
            return GetTaskResponse(
                root=JSONRPCErrorResponse(
                    id=request.id, error=e.error if e.error else InternalError()
                )
            )

    async def list_push_notification_config(
        self,
        request: ListTaskPushNotificationConfigRequest,
        context: ServerCallContext | None = None,
    ) -> ListTaskPushNotificationConfigResponse:
        """Handles the 'tasks/pushNotificationConfig/list' JSON-RPC method.

        Args:
            request: The incoming `ListTaskPushNotificationConfigRequest` object.
            context: Context provided by the server.

        Returns:
            A `ListTaskPushNotificationConfigResponse` object containing the config or a JSON-RPC error.
        """
        try:
            config = await self.request_handler.on_list_task_push_notification_config(
                request.params, context
            )
            return prepare_response_object(
                request.id,
                config,
                (list,),
                ListTaskPushNotificationConfigSuccessResponse,
                ListTaskPushNotificationConfigResponse,
            )
        except ServerError as e:
            return ListTaskPushNotificationConfigResponse(
                root=JSONRPCErrorResponse(
                    id=request.id, error=e.error if e.error else InternalError()
                )
            )

    async def delete_push_notification_config(
        self,
        request: DeleteTaskPushNotificationConfigRequest,
        context: ServerCallContext | None = None,
    ) -> DeleteTaskPushNotificationConfigResponse:
        """Handles the 'tasks/pushNotificationConfig/list' JSON-RPC method.

        Args:
            request: The incoming `DeleteTaskPushNotificationConfigRequest` object.
            context: Context provided by the server.

        Returns:
            A `DeleteTaskPushNotificationConfigResponse` object containing the config or a JSON-RPC error.
        """
        try:
            (
                await self.request_handler.on_delete_task_push_notification_config(
                    request.params, context
                )
            )
            return DeleteTaskPushNotificationConfigResponse(
                root=DeleteTaskPushNotificationConfigSuccessResponse(
                    id=request.id, result=None
                )
            )
        except ServerError as e:
            return DeleteTaskPushNotificationConfigResponse(
                root=JSONRPCErrorResponse(
                    id=request.id, error=e.error if e.error else InternalError()
                )
            )

    async def get_authenticated_extended_card(
        self,
        request: GetAuthenticatedExtendedCardRequest,
        context: ServerCallContext | None = None,
    ) -> GetAuthenticatedExtendedCardResponse:
        """Handles the 'agent/authenticatedExtendedCard' JSON-RPC method.

        Args:
            request: The incoming `GetAuthenticatedExtendedCardRequest` object.
            context: Context provided by the server.

        Returns:
            A `GetAuthenticatedExtendedCardResponse` object containing the config or a JSON-RPC error.
        """
        if (
            self.extended_agent_card is None
            and self.extended_card_modifier is None
        ):
            return GetAuthenticatedExtendedCardResponse(
                root=JSONRPCErrorResponse(
                    id=request.id,
                    error=AuthenticatedExtendedCardNotConfiguredError(),
                )
            )

        base_card = self.extended_agent_card
        if base_card is None:
            base_card = self.agent_card

        card_to_serve = base_card
        if self.extended_card_modifier and context:
            card_to_serve = self.extended_card_modifier(base_card, context)

        return GetAuthenticatedExtendedCardResponse(
            root=GetAuthenticatedExtendedCardSuccessResponse(
                id=request.id, result=card_to_serve
            )
        )



---
File: /a2a-python/src/a2a/server/request_handlers/request_handler.py
---

from abc import ABC, abstractmethod
from collections.abc import AsyncGenerator

from a2a.server.context import ServerCallContext
from a2a.server.events.event_queue import Event
from a2a.types import (
    DeleteTaskPushNotificationConfigParams,
    GetTaskPushNotificationConfigParams,
    ListTaskPushNotificationConfigParams,
    Message,
    MessageSendParams,
    Task,
    TaskIdParams,
    TaskPushNotificationConfig,
    TaskQueryParams,
    UnsupportedOperationError,
)
from a2a.utils.errors import ServerError


class RequestHandler(ABC):
    """A2A request handler interface.

    This interface defines the methods that an A2A server implementation must
    provide to handle incoming JSON-RPC requests.
    """

    @abstractmethod
    async def on_get_task(
        self,
        params: TaskQueryParams,
        context: ServerCallContext | None = None,
    ) -> Task | None:
        """Handles the 'tasks/get' method.

        Retrieves the state and history of a specific task.

        Args:
            params: Parameters specifying the task ID and optionally history length.
            context: Context provided by the server.

        Returns:
            The `Task` object if found, otherwise `None`.
        """

    @abstractmethod
    async def on_cancel_task(
        self,
        params: TaskIdParams,
        context: ServerCallContext | None = None,
    ) -> Task | None:
        """Handles the 'tasks/cancel' method.

        Requests the agent to cancel an ongoing task.

        Args:
            params: Parameters specifying the task ID.
            context: Context provided by the server.

        Returns:
            The `Task` object with its status updated to canceled, or `None` if the task was not found.
        """

    @abstractmethod
    async def on_message_send(
        self,
        params: MessageSendParams,
        context: ServerCallContext | None = None,
    ) -> Task | Message:
        """Handles the 'message/send' method (non-streaming).

        Sends a message to the agent to create, continue, or restart a task,
        and waits for the final result (Task or Message).

        Args:
            params: Parameters including the message and configuration.
            context: Context provided by the server.

        Returns:
            The final `Task` object or a final `Message` object.
        """

    @abstractmethod
    async def on_message_send_stream(
        self,
        params: MessageSendParams,
        context: ServerCallContext | None = None,
    ) -> AsyncGenerator[Event]:
        """Handles the 'message/stream' method (streaming).

        Sends a message to the agent and yields stream events as they are
        produced (Task updates, Message chunks, Artifact updates).

        Args:
            params: Parameters including the message and configuration.
            context: Context provided by the server.

        Yields:
            `Event` objects from the agent's execution.

        Raises:
             ServerError(UnsupportedOperationError): By default, if not implemented.
        """
        raise ServerError(error=UnsupportedOperationError())
        yield

    @abstractmethod
    async def on_set_task_push_notification_config(
        self,
        params: TaskPushNotificationConfig,
        context: ServerCallContext | None = None,
    ) -> TaskPushNotificationConfig:
        """Handles the 'tasks/pushNotificationConfig/set' method.

        Sets or updates the push notification configuration for a task.

        Args:
            params: Parameters including the task ID and push notification configuration.
            context: Context provided by the server.

        Returns:
            The provided `TaskPushNotificationConfig` upon success.
        """

    @abstractmethod
    async def on_get_task_push_notification_config(
        self,
        params: TaskIdParams | GetTaskPushNotificationConfigParams,
        context: ServerCallContext | None = None,
    ) -> TaskPushNotificationConfig:
        """Handles the 'tasks/pushNotificationConfig/get' method.

        Retrieves the current push notification configuration for a task.

        Args:
            params: Parameters including the task ID.
            context: Context provided by the server.

        Returns:
            The `TaskPushNotificationConfig` for the task.
        """

    @abstractmethod
    async def on_resubscribe_to_task(
        self,
        params: TaskIdParams,
        context: ServerCallContext | None = None,
    ) -> AsyncGenerator[Event]:
        """Handles the 'tasks/resubscribe' method.

        Allows a client to re-subscribe to a running streaming task's event stream.

        Args:
            params: Parameters including the task ID.
            context: Context provided by the server.

        Yields:
             `Event` objects from the agent's ongoing execution for the specified task.

        Raises:
             ServerError(UnsupportedOperationError): By default, if not implemented.
        """
        raise ServerError(error=UnsupportedOperationError())
        yield

    @abstractmethod
    async def on_list_task_push_notification_config(
        self,
        params: ListTaskPushNotificationConfigParams,
        context: ServerCallContext | None = None,
    ) -> list[TaskPushNotificationConfig]:
        """Handles the 'tasks/pushNotificationConfig/list' method.

        Retrieves the current push notification configurations for a task.

        Args:
            params: Parameters including the task ID.
            context: Context provided by the server.

        Returns:
            The `list[TaskPushNotificationConfig]` for the task.
        """

    @abstractmethod
    async def on_delete_task_push_notification_config(
        self,
        params: DeleteTaskPushNotificationConfigParams,
        context: ServerCallContext | None = None,
    ) -> None:
        """Handles the 'tasks/pushNotificationConfig/delete' method.

        Deletes a push notification configuration associated with a task.

        Args:
            params: Parameters including the task ID.
            context: Context provided by the server.

        Returns:
            None
        """



---
File: /a2a-python/src/a2a/server/request_handlers/response_helpers.py
---

"""Helper functions for building A2A JSON-RPC responses."""

# response types
from typing import TypeVar

from a2a.types import (
    A2AError,
    CancelTaskResponse,
    CancelTaskSuccessResponse,
    DeleteTaskPushNotificationConfigResponse,
    DeleteTaskPushNotificationConfigSuccessResponse,
    GetTaskPushNotificationConfigResponse,
    GetTaskPushNotificationConfigSuccessResponse,
    GetTaskResponse,
    GetTaskSuccessResponse,
    InvalidAgentResponseError,
    JSONRPCError,
    JSONRPCErrorResponse,
    ListTaskPushNotificationConfigResponse,
    ListTaskPushNotificationConfigSuccessResponse,
    Message,
    SendMessageResponse,
    SendMessageSuccessResponse,
    SendStreamingMessageResponse,
    SendStreamingMessageSuccessResponse,
    SetTaskPushNotificationConfigResponse,
    SetTaskPushNotificationConfigSuccessResponse,
    Task,
    TaskArtifactUpdateEvent,
    TaskPushNotificationConfig,
    TaskStatusUpdateEvent,
)


RT = TypeVar(
    'RT',
    GetTaskResponse,
    CancelTaskResponse,
    SendMessageResponse,
    SetTaskPushNotificationConfigResponse,
    GetTaskPushNotificationConfigResponse,
    SendStreamingMessageResponse,
    ListTaskPushNotificationConfigResponse,
    DeleteTaskPushNotificationConfigResponse,
)
"""Type variable for RootModel response types."""

# success types
SPT = TypeVar(
    'SPT',
    GetTaskSuccessResponse,
    CancelTaskSuccessResponse,
    SendMessageSuccessResponse,
    SetTaskPushNotificationConfigSuccessResponse,
    GetTaskPushNotificationConfigSuccessResponse,
    SendStreamingMessageSuccessResponse,
    ListTaskPushNotificationConfigSuccessResponse,
    DeleteTaskPushNotificationConfigSuccessResponse,
)
"""Type variable for SuccessResponse types."""

# result types
EventTypes = (
    Task
    | Message
    | TaskArtifactUpdateEvent
    | TaskStatusUpdateEvent
    | TaskPushNotificationConfig
    | A2AError
    | JSONRPCError
    | list[TaskPushNotificationConfig]
)
"""Type alias for possible event types produced by handlers."""


def build_error_response(
    request_id: str | int | None,
    error: A2AError | JSONRPCError,
    response_wrapper_type: type[RT],
) -> RT:
    """Helper method to build a JSONRPCErrorResponse wrapped in the appropriate response type.

    Args:
        request_id: The ID of the request that caused the error.
        error: The A2AError or JSONRPCError object.
        response_wrapper_type: The Pydantic RootModel type that wraps the response
                                for the specific RPC method (e.g., `SendMessageResponse`).

    Returns:
        A Pydantic model representing the JSON-RPC error response,
        wrapped in the specified response type.
    """
    return response_wrapper_type(
        JSONRPCErrorResponse(
            id=request_id,
            error=error.root if isinstance(error, A2AError) else error,
        )
    )


def prepare_response_object(
    request_id: str | int | None,
    response: EventTypes,
    success_response_types: tuple[type, ...],
    success_payload_type: type[SPT],
    response_type: type[RT],
) -> RT:
    """Helper method to build appropriate JSONRPCResponse object for RPC methods.

    Based on the type of the `response` object received from the handler,
    it constructs either a success response wrapped in the appropriate payload type
    or an error response.

    Args:
        request_id: The ID of the request.
        response: The object received from the request handler.
        success_response_types: A tuple of expected Pydantic model types for a successful result.
        success_payload_type: The Pydantic model type for the success payload
                                (e.g., `SendMessageSuccessResponse`).
        response_type: The Pydantic RootModel type that wraps the final response
                       (e.g., `SendMessageResponse`).

    Returns:
        A Pydantic model representing the final JSON-RPC response (success or error).
    """
    if isinstance(response, success_response_types):
        return response_type(
            root=success_payload_type(id=request_id, result=response)  # type:ignore
        )

    if isinstance(response, A2AError | JSONRPCError):
        return build_error_response(request_id, response, response_type)

    # If consumer_data is not an expected success type and not an error,
    # it's an invalid type of response from the agent for this specific method.
    response = A2AError(
        root=InvalidAgentResponseError(
            message='Agent returned invalid type response for this method'
        )
    )

    return build_error_response(request_id, response, response_type)



---
File: /a2a-python/src/a2a/server/request_handlers/rest_handler.py
---

import logging

from collections.abc import AsyncIterable, AsyncIterator
from typing import TYPE_CHECKING, Any

from google.protobuf.json_format import MessageToDict, MessageToJson, Parse


if TYPE_CHECKING:
    from starlette.requests import Request
else:
    try:
        from starlette.requests import Request
    except ImportError:
        Request = Any


from a2a.grpc import a2a_pb2
from a2a.server.context import ServerCallContext
from a2a.server.request_handlers.request_handler import RequestHandler
from a2a.types import (
    AgentCard,
    GetTaskPushNotificationConfigParams,
    TaskIdParams,
    TaskNotFoundError,
    TaskQueryParams,
)
from a2a.utils import proto_utils
from a2a.utils.errors import ServerError
from a2a.utils.helpers import validate
from a2a.utils.telemetry import SpanKind, trace_class


logger = logging.getLogger(__name__)


@trace_class(kind=SpanKind.SERVER)
class RESTHandler:
    """Maps incoming REST-like (JSON+HTTP) requests to the appropriate request handler method and formats responses.

    This uses the protobuf definitions of the gRPC service as the source of truth. By
    doing this, it ensures that this implementation and the gRPC transcoding
    (via Envoy) are equivalent. This handler should be used if using the gRPC handler
    with Envoy is not feasible for a given deployment solution. Use this handler
    and a related application if you desire to ONLY server the RESTful API.
    """

    def __init__(
        self,
        agent_card: AgentCard,
        request_handler: RequestHandler,
    ):
        """Initializes the RESTHandler.

        Args:
          agent_card: The AgentCard describing the agent's capabilities.
          request_handler: The underlying `RequestHandler` instance to delegate requests to.
        """
        self.agent_card = agent_card
        self.request_handler = request_handler

    async def on_message_send(
        self,
        request: Request,
        context: ServerCallContext,
    ) -> dict[str, Any]:
        """Handles the 'message/send' REST method.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Returns:
            A `dict` containing the result (Task or Message)
        """
        body = await request.body()
        params = a2a_pb2.SendMessageRequest()
        Parse(body, params)
        # Transform the proto object to the python internal objects
        a2a_request = proto_utils.FromProto.message_send_params(
            params,
        )
        task_or_message = await self.request_handler.on_message_send(
            a2a_request, context
        )
        return MessageToDict(
            proto_utils.ToProto.task_or_message(task_or_message)
        )

    @validate(
        lambda self: self.agent_card.capabilities.streaming,
        'Streaming is not supported by the agent',
    )
    async def on_message_send_stream(
        self,
        request: Request,
        context: ServerCallContext,
    ) -> AsyncIterator[str]:
        """Handles the 'message/stream' REST method.

        Yields response objects as they are produced by the underlying handler's stream.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Yields:
            JSON serialized objects containing streaming events
            (Task, Message, TaskStatusUpdateEvent, TaskArtifactUpdateEvent) as JSON
        """
        body = await request.body()
        params = a2a_pb2.SendMessageRequest()
        Parse(body, params)
        # Transform the proto object to the python internal objects
        a2a_request = proto_utils.FromProto.message_send_params(
            params,
        )
        async for event in self.request_handler.on_message_send_stream(
            a2a_request, context
        ):
            response = proto_utils.ToProto.stream_response(event)
            yield MessageToJson(response)

    async def on_cancel_task(
        self,
        request: Request,
        context: ServerCallContext,
    ) -> dict[str, Any]:
        """Handles the 'tasks/cancel' REST method.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Returns:
            A `dict` containing the updated Task
        """
        task_id = request.path_params['id']
        task = await self.request_handler.on_cancel_task(
            TaskIdParams(id=task_id), context
        )
        if task:
            return MessageToDict(proto_utils.ToProto.task(task))
        raise ServerError(error=TaskNotFoundError())

    @validate(
        lambda self: self.agent_card.capabilities.streaming,
        'Streaming is not supported by the agent',
    )
    async def on_resubscribe_to_task(
        self,
        request: Request,
        context: ServerCallContext,
    ) -> AsyncIterable[str]:
        """Handles the 'tasks/resubscribe' REST method.

        Yields response objects as they are produced by the underlying handler's stream.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Yields:
            JSON serialized objects containing streaming events
        """
        task_id = request.path_params['id']
        async for event in self.request_handler.on_resubscribe_to_task(
            TaskIdParams(id=task_id), context
        ):
            yield MessageToJson(proto_utils.ToProto.stream_response(event))

    async def get_push_notification(
        self,
        request: Request,
        context: ServerCallContext,
    ) -> dict[str, Any]:
        """Handles the 'tasks/pushNotificationConfig/get' REST method.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Returns:
            A `dict` containing the config
        """
        task_id = request.path_params['id']
        push_id = request.path_params['push_id']
        params = GetTaskPushNotificationConfigParams(
            id=task_id, push_notification_config_id=push_id
        )
        config = (
            await self.request_handler.on_get_task_push_notification_config(
                params, context
            )
        )
        return MessageToDict(
            proto_utils.ToProto.task_push_notification_config(config)
        )

    @validate(
        lambda self: self.agent_card.capabilities.push_notifications,
        'Push notifications are not supported by the agent',
    )
    async def set_push_notification(
        self,
        request: Request,
        context: ServerCallContext,
    ) -> dict[str, Any]:
        """Handles the 'tasks/pushNotificationConfig/set' REST method.

        Requires the agent to support push notifications.

        Args:
            request: The incoming `TaskPushNotificationConfig` object.
            context: Context provided by the server.

        Returns:
            A `dict` containing the config object.

        Raises:
            ServerError: If push notifications are not supported by the agent
                (due to the `@validate` decorator), A2AError if processing error is
                found.
        """
        task_id = request.path_params['id']
        body = await request.body()
        params = a2a_pb2.CreateTaskPushNotificationConfigRequest()
        Parse(body, params)
        a2a_request = (
            proto_utils.FromProto.task_push_notification_config_request(
                params,
            )
        )
        a2a_request.task_id = task_id
        config = (
            await self.request_handler.on_set_task_push_notification_config(
                a2a_request, context
            )
        )
        return MessageToDict(
            proto_utils.ToProto.task_push_notification_config(config)
        )

    async def on_get_task(
        self,
        request: Request,
        context: ServerCallContext,
    ) -> dict[str, Any]:
        """Handles the 'v1/tasks/{id}' REST method.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Returns:
            A `Task` object containing the Task.
        """
        task_id = request.path_params['id']
        history_length_str = request.query_params.get('historyLength')
        history_length = int(history_length_str) if history_length_str else None
        params = TaskQueryParams(id=task_id, history_length=history_length)
        task = await self.request_handler.on_get_task(params, context)
        if task:
            return MessageToDict(proto_utils.ToProto.task(task))
        raise ServerError(error=TaskNotFoundError())

    async def list_push_notifications(
        self,
        request: Request,
        context: ServerCallContext,
    ) -> dict[str, Any]:
        """Handles the 'tasks/pushNotificationConfig/list' REST method.

        This method is currently not implemented.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Returns:
            A list of `dict` representing the `TaskPushNotificationConfig` objects.

        Raises:
            NotImplementedError: This method is not yet implemented.
        """
        raise NotImplementedError('list notifications not implemented')

    async def list_tasks(
        self,
        request: Request,
        context: ServerCallContext,
    ) -> dict[str, Any]:
        """Handles the 'tasks/list' REST method.

        This method is currently not implemented.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Returns:
            A list of dict representing the`Task` objects.

        Raises:
            NotImplementedError: This method is not yet implemented.
        """
        raise NotImplementedError('list tasks not implemented')



---
File: /a2a-python/src/a2a/server/tasks/__init__.py
---

"""Components for managing tasks within the A2A server."""

import logging

from a2a.server.tasks.base_push_notification_sender import (
    BasePushNotificationSender,
)
from a2a.server.tasks.inmemory_push_notification_config_store import (
    InMemoryPushNotificationConfigStore,
)
from a2a.server.tasks.inmemory_task_store import InMemoryTaskStore
from a2a.server.tasks.push_notification_config_store import (
    PushNotificationConfigStore,
)
from a2a.server.tasks.push_notification_sender import PushNotificationSender
from a2a.server.tasks.result_aggregator import ResultAggregator
from a2a.server.tasks.task_manager import TaskManager
from a2a.server.tasks.task_store import TaskStore
from a2a.server.tasks.task_updater import TaskUpdater


logger = logging.getLogger(__name__)

try:
    from a2a.server.tasks.database_task_store import (
        DatabaseTaskStore,  # type: ignore
    )
except ImportError as e:
    _original_error = e
    # If the database task store is not available, we can still use in-memory stores.
    logger.debug(
        'DatabaseTaskStore not loaded. This is expected if database dependencies are not installed. Error: %s',
        e,
    )

    class DatabaseTaskStore:  # type: ignore
        """Placeholder for DatabaseTaskStore when dependencies are not installed."""

        def __init__(self, *args, **kwargs):
            raise ImportError(
                'To use DatabaseTaskStore, its dependencies must be installed. '
                'You can install them with \'pip install "a2a-sdk[sql]"\''
            ) from _original_error


try:
    from a2a.server.tasks.database_push_notification_config_store import (
        DatabasePushNotificationConfigStore,  # type: ignore
    )
except ImportError as e:
    _original_error = e
    # If the database push notification config store is not available, we can still use in-memory stores.
    logger.debug(
        'DatabasePushNotificationConfigStore not loaded. This is expected if database dependencies are not installed. Error: %s',
        e,
    )

    class DatabasePushNotificationConfigStore:  # type: ignore
        """Placeholder for DatabasePushNotificationConfigStore when dependencies are not installed."""

        def __init__(self, *args, **kwargs):
            raise ImportError(
                'To use DatabasePushNotificationConfigStore, its dependencies must be installed. '
                'You can install them with \'pip install "a2a-sdk[sql]"\''
            ) from _original_error


__all__ = [
    'BasePushNotificationSender',
    'DatabasePushNotificationConfigStore',
    'DatabaseTaskStore',
    'InMemoryPushNotificationConfigStore',
    'InMemoryTaskStore',
    'PushNotificationConfigStore',
    'PushNotificationSender',
    'ResultAggregator',
    'TaskManager',
    'TaskStore',
    'TaskUpdater',
]



---
File: /a2a-python/src/a2a/server/tasks/base_push_notification_sender.py
---

import asyncio
import logging

import httpx

from a2a.server.tasks.push_notification_config_store import (
    PushNotificationConfigStore,
)
from a2a.server.tasks.push_notification_sender import PushNotificationSender
from a2a.types import PushNotificationConfig, Task


logger = logging.getLogger(__name__)


class BasePushNotificationSender(PushNotificationSender):
    """Base implementation of PushNotificationSender interface."""

    def __init__(
        self,
        httpx_client: httpx.AsyncClient,
        config_store: PushNotificationConfigStore,
    ) -> None:
        """Initializes the BasePushNotificationSender.

        Args:
            httpx_client: An async HTTP client instance to send notifications.
            config_store: A PushNotificationConfigStore instance to retrieve configurations.
        """
        self._client = httpx_client
        self._config_store = config_store

    async def send_notification(self, task: Task) -> None:
        """Sends a push notification for a task if configuration exists."""
        push_configs = await self._config_store.get_info(task.id)
        if not push_configs:
            return

        awaitables = [
            self._dispatch_notification(task, push_info)
            for push_info in push_configs
        ]
        results = await asyncio.gather(*awaitables)

        if not all(results):
            logger.warning(
                f'Some push notifications failed to send for task_id={task.id}'
            )

    async def _dispatch_notification(
        self, task: Task, push_info: PushNotificationConfig
    ) -> bool:
        url = push_info.url
        try:
            headers = None
            if push_info.token:
                headers = {'X-A2A-Notification-Token': push_info.token}
            response = await self._client.post(
                url,
                json=task.model_dump(mode='json', exclude_none=True),
                headers=headers,
            )
            response.raise_for_status()
            logger.info(
                f'Push-notification sent for task_id={task.id} to URL: {url}'
            )
        except Exception:
            logger.exception(
                f'Error sending push-notification for task_id={task.id} to URL: {url}.'
            )
            return False
        return True



---
File: /a2a-python/src/a2a/server/tasks/database_push_notification_config_store.py
---

# ruff: noqa: PLC0415
import json
import logging

from typing import TYPE_CHECKING

from pydantic import ValidationError


try:
    from sqlalchemy import (
        Table,
        delete,
        select,
    )
    from sqlalchemy.ext.asyncio import (
        AsyncEngine,
        AsyncSession,
        async_sessionmaker,
    )
    from sqlalchemy.orm import class_mapper
except ImportError as e:
    raise ImportError(
        'DatabasePushNotificationConfigStore requires SQLAlchemy and a database driver. '
        'Install with one of: '
        "'pip install a2a-sdk[postgresql]', "
        "'pip install a2a-sdk[mysql]', "
        "'pip install a2a-sdk[sqlite]', "
        "or 'pip install a2a-sdk[sql]'"
    ) from e

from a2a.server.models import (
    Base,
    PushNotificationConfigModel,
    create_push_notification_config_model,
)
from a2a.server.tasks.push_notification_config_store import (
    PushNotificationConfigStore,
)
from a2a.types import PushNotificationConfig


if TYPE_CHECKING:
    from cryptography.fernet import Fernet


logger = logging.getLogger(__name__)


class DatabasePushNotificationConfigStore(PushNotificationConfigStore):
    """SQLAlchemy-based implementation of PushNotificationConfigStore.

    Stores push notification configurations in a database supported by SQLAlchemy.
    """

    engine: AsyncEngine
    async_session_maker: async_sessionmaker[AsyncSession]
    create_table: bool
    _initialized: bool
    config_model: type[PushNotificationConfigModel]
    _fernet: 'Fernet | None'

    def __init__(
        self,
        engine: AsyncEngine,
        create_table: bool = True,
        table_name: str = 'push_notification_configs',
        encryption_key: str | bytes | None = None,
    ) -> None:
        """Initializes the DatabasePushNotificationConfigStore.

        Args:
            engine: An existing SQLAlchemy AsyncEngine to be used by the store.
            create_table: If true, create the table on initialization.
            table_name: Name of the database table. Defaults to 'push_notification_configs'.
            encryption_key: A key for encrypting sensitive configuration data.
                If provided, `config_data` will be encrypted in the database.
                The key must be a URL-safe base64-encoded 32-byte key.
        """
        logger.debug(
            f'Initializing DatabasePushNotificationConfigStore with existing engine, table: {table_name}'
        )
        self.engine = engine
        self.async_session_maker = async_sessionmaker(
            self.engine, expire_on_commit=False
        )
        self.create_table = create_table
        self._initialized = False
        self.config_model = (
            PushNotificationConfigModel
            if table_name == 'push_notification_configs'
            else create_push_notification_config_model(table_name)
        )
        self._fernet = None

        if encryption_key:
            try:
                from cryptography.fernet import Fernet
            except ImportError as e:
                raise ImportError(
                    "DatabasePushNotificationConfigStore with encryption requires the 'cryptography' "
                    'library. Install with: '
                    "'pip install a2a-sdk[encryption]'"
                ) from e

            if isinstance(encryption_key, str):
                encryption_key = encryption_key.encode('utf-8')
            self._fernet = Fernet(encryption_key)
            logger.debug(
                'Encryption enabled for push notification config store.'
            )

    async def initialize(self) -> None:
        """Initialize the database and create the table if needed."""
        if self._initialized:
            return

        logger.debug(
            'Initializing database schema for push notification configs...'
        )
        if self.create_table:
            async with self.engine.begin() as conn:
                mapper = class_mapper(self.config_model)
                tables_to_create = [
                    table for table in mapper.tables if isinstance(table, Table)
                ]
                await conn.run_sync(
                    Base.metadata.create_all, tables=tables_to_create
                )
        self._initialized = True
        logger.debug(
            'Database schema for push notification configs initialized.'
        )

    async def _ensure_initialized(self) -> None:
        """Ensure the database connection is initialized."""
        if not self._initialized:
            await self.initialize()

    def _to_orm(
        self, task_id: str, config: PushNotificationConfig
    ) -> PushNotificationConfigModel:
        """Maps a Pydantic PushNotificationConfig to a SQLAlchemy model instance.

        The config data is serialized to JSON bytes, and encrypted if a key is configured.
        """
        json_payload = config.model_dump_json().encode('utf-8')

        if self._fernet:
            data_to_store = self._fernet.encrypt(json_payload)
        else:
            data_to_store = json_payload

        return self.config_model(
            task_id=task_id,
            config_id=config.id,
            config_data=data_to_store,
        )

    def _from_orm(
        self, model_instance: PushNotificationConfigModel
    ) -> PushNotificationConfig:
        """Maps a SQLAlchemy model instance to a Pydantic PushNotificationConfig.

        Handles decryption if a key is configured, with a fallback to plain JSON.
        """
        payload = model_instance.config_data

        if self._fernet:
            from cryptography.fernet import InvalidToken

            try:
                decrypted_payload = self._fernet.decrypt(payload)
                return PushNotificationConfig.model_validate_json(
                    decrypted_payload
                )
            except (json.JSONDecodeError, ValidationError) as e:
                logger.exception(
                    'Failed to parse decrypted push notification config for task %s, config %s. '
                    'Data is corrupted or not valid JSON after decryption.',
                    model_instance.task_id,
                    model_instance.config_id,
                )
                raise ValueError(
                    'Failed to parse decrypted push notification config data'
                ) from e
            except InvalidToken:
                # Decryption failed. This could be because the data is not encrypted.
                # We'll log a warning and try to parse it as plain JSON as a fallback.
                logger.warning(
                    'Failed to decrypt push notification config for task %s, config %s. '
                    'Attempting to parse as unencrypted JSON. '
                    'This may indicate an incorrect encryption key or unencrypted data in the database.',
                    model_instance.task_id,
                    model_instance.config_id,
                )
                # Fall through to the unencrypted parsing logic below.

        # Try to parse as plain JSON.
        try:
            return PushNotificationConfig.model_validate_json(payload)
        except (json.JSONDecodeError, ValidationError) as e:
            if self._fernet:
                logger.exception(
                    'Failed to parse push notification config for task %s, config %s. '
                    'Decryption failed and the data is not valid JSON. '
                    'This likely indicates the data is corrupted or encrypted with a different key.',
                    model_instance.task_id,
                    model_instance.config_id,
                )
            else:
                # if no key is configured and the payload is not valid JSON.
                logger.exception(
                    'Failed to parse push notification config for task %s, config %s. '
                    'Data is not valid JSON and no encryption key is configured.',
                    model_instance.task_id,
                    model_instance.config_id,
                )
            raise ValueError(
                'Failed to parse push notification config data. '
                'Data is not valid JSON, or it is encrypted with the wrong key.'
            ) from e

    async def set_info(
        self, task_id: str, notification_config: PushNotificationConfig
    ) -> None:
        """Sets or updates the push notification configuration for a task."""
        await self._ensure_initialized()

        config_to_save = notification_config.model_copy()
        if config_to_save.id is None:
            config_to_save.id = task_id

        db_config = self._to_orm(task_id, config_to_save)
        async with self.async_session_maker.begin() as session:
            await session.merge(db_config)
            logger.debug(
                f'Push notification config for task {task_id} with config id {config_to_save.id} saved/updated.'
            )

    async def get_info(self, task_id: str) -> list[PushNotificationConfig]:
        """Retrieves all push notification configurations for a task."""
        await self._ensure_initialized()
        async with self.async_session_maker() as session:
            stmt = select(self.config_model).where(
                self.config_model.task_id == task_id
            )
            result = await session.execute(stmt)
            models = result.scalars().all()

            configs = []
            for model in models:
                try:
                    configs.append(self._from_orm(model))
                except ValueError:  # noqa: PERF203
                    logger.exception(
                        'Could not deserialize push notification config for task %s, config %s',
                        model.task_id,
                        model.config_id,
                    )
            return configs

    async def delete_info(
        self, task_id: str, config_id: str | None = None
    ) -> None:
        """Deletes push notification configurations for a task.

        If config_id is provided, only that specific configuration is deleted.
        If config_id is None, all configurations for the task are deleted.
        """
        await self._ensure_initialized()
        async with self.async_session_maker.begin() as session:
            stmt = delete(self.config_model).where(
                self.config_model.task_id == task_id
            )
            if config_id is not None:
                stmt = stmt.where(self.config_model.config_id == config_id)

            result = await session.execute(stmt)

            if result.rowcount > 0:
                logger.info(
                    f'Deleted {result.rowcount} push notification config(s) for task {task_id}.'
                )
            else:
                logger.warning(
                    f'Attempted to delete push notification config for task {task_id} with config_id: {config_id} that does not exist.'
                )



---
File: /a2a-python/src/a2a/server/tasks/database_task_store.py
---

import logging


try:
    from sqlalchemy import Table, delete, select
    from sqlalchemy.ext.asyncio import (
        AsyncEngine,
        AsyncSession,
        async_sessionmaker,
    )
    from sqlalchemy.orm import class_mapper
except ImportError as e:
    raise ImportError(
        'DatabaseTaskStore requires SQLAlchemy and a database driver. '
        'Install with one of: '
        "'pip install a2a-sdk[postgresql]', "
        "'pip install a2a-sdk[mysql]', "
        "'pip install a2a-sdk[sqlite]', "
        "or 'pip install a2a-sdk[sql]'"
    ) from e

from a2a.server.models import Base, TaskModel, create_task_model
from a2a.server.tasks.task_store import TaskStore
from a2a.types import Task  # Task is the Pydantic model


logger = logging.getLogger(__name__)


class DatabaseTaskStore(TaskStore):
    """SQLAlchemy-based implementation of TaskStore.

    Stores task objects in a database supported by SQLAlchemy.
    """

    engine: AsyncEngine
    async_session_maker: async_sessionmaker[AsyncSession]
    create_table: bool
    _initialized: bool
    task_model: type[TaskModel]

    def __init__(
        self,
        engine: AsyncEngine,
        create_table: bool = True,
        table_name: str = 'tasks',
    ) -> None:
        """Initializes the DatabaseTaskStore.

        Args:
            engine: An existing SQLAlchemy AsyncEngine to be used by Task Store
            create_table: If true, create tasks table on initialization.
            table_name: Name of the database table. Defaults to 'tasks'.
        """
        logger.debug(
            f'Initializing DatabaseTaskStore with existing engine, table: {table_name}'
        )
        self.engine = engine
        self.async_session_maker = async_sessionmaker(
            self.engine, expire_on_commit=False
        )
        self.create_table = create_table
        self._initialized = False

        self.task_model = (
            TaskModel
            if table_name == 'tasks'
            else create_task_model(table_name)
        )

    async def initialize(self) -> None:
        """Initialize the database and create the table if needed."""
        if self._initialized:
            return

        logger.debug('Initializing database schema...')
        if self.create_table:
            async with self.engine.begin() as conn:
                mapper = class_mapper(self.task_model)
                tables_to_create = [
                    table for table in mapper.tables if isinstance(table, Table)
                ]
                await conn.run_sync(
                    Base.metadata.create_all, tables=tables_to_create
                )
        self._initialized = True
        logger.debug('Database schema initialized.')

    async def _ensure_initialized(self) -> None:
        """Ensure the database connection is initialized."""
        if not self._initialized:
            await self.initialize()

    def _to_orm(self, task: Task) -> TaskModel:
        """Maps a Pydantic Task to a SQLAlchemy TaskModel instance."""
        return self.task_model(
            id=task.id,
            context_id=task.context_id,
            kind=task.kind,
            status=task.status,
            artifacts=task.artifacts,
            history=task.history,
            task_metadata=task.metadata,
        )

    def _from_orm(self, task_model: TaskModel) -> Task:
        """Maps a SQLAlchemy TaskModel to a Pydantic Task instance."""
        # Map database columns to Pydantic model fields
        task_data_from_db = {
            'id': task_model.id,
            'context_id': task_model.context_id,
            'kind': task_model.kind,
            'status': task_model.status,
            'artifacts': task_model.artifacts,
            'history': task_model.history,
            'metadata': task_model.task_metadata,  # Map task_metadata column to metadata field
        }
        # Pydantic's model_validate will parse the nested dicts/lists from JSON
        return Task.model_validate(task_data_from_db)

    async def save(self, task: Task) -> None:
        """Saves or updates a task in the database."""
        await self._ensure_initialized()
        db_task = self._to_orm(task)
        async with self.async_session_maker.begin() as session:
            await session.merge(db_task)
            logger.debug(f'Task {task.id} saved/updated successfully.')

    async def get(self, task_id: str) -> Task | None:
        """Retrieves a task from the database by ID."""
        await self._ensure_initialized()
        async with self.async_session_maker() as session:
            stmt = select(self.task_model).where(self.task_model.id == task_id)
            result = await session.execute(stmt)
            task_model = result.scalar_one_or_none()
            if task_model:
                task = self._from_orm(task_model)
                logger.debug(f'Task {task_id} retrieved successfully.')
                return task

            logger.debug(f'Task {task_id} not found in store.')
            return None

    async def delete(self, task_id: str) -> None:
        """Deletes a task from the database by ID."""
        await self._ensure_initialized()

        async with self.async_session_maker.begin() as session:
            stmt = delete(self.task_model).where(self.task_model.id == task_id)
            result = await session.execute(stmt)
            # Commit is automatic when using session.begin()

            if result.rowcount > 0:
                logger.info(f'Task {task_id} deleted successfully.')
            else:
                logger.warning(
                    f'Attempted to delete nonexistent task with id: {task_id}'
                )



---
File: /a2a-python/src/a2a/server/tasks/inmemory_push_notification_config_store.py
---

import asyncio
import logging

from a2a.server.tasks.push_notification_config_store import (
    PushNotificationConfigStore,
)
from a2a.types import PushNotificationConfig


logger = logging.getLogger(__name__)


class InMemoryPushNotificationConfigStore(PushNotificationConfigStore):
    """In-memory implementation of PushNotificationConfigStore interface.

    Stores push notification configurations in memory
    """

    def __init__(self) -> None:
        """Initializes the InMemoryPushNotificationConfigStore."""
        self.lock = asyncio.Lock()
        self._push_notification_infos: dict[
            str, list[PushNotificationConfig]
        ] = {}

    async def set_info(
        self, task_id: str, notification_config: PushNotificationConfig
    ) -> None:
        """Sets or updates the push notification configuration for a task in memory."""
        async with self.lock:
            if task_id not in self._push_notification_infos:
                self._push_notification_infos[task_id] = []

            if notification_config.id is None:
                notification_config.id = task_id

            for config in self._push_notification_infos[task_id]:
                if config.id == notification_config.id:
                    self._push_notification_infos[task_id].remove(config)
                    break

            self._push_notification_infos[task_id].append(notification_config)

    async def get_info(self, task_id: str) -> list[PushNotificationConfig]:
        """Retrieves the push notification configuration for a task from memory."""
        async with self.lock:
            return self._push_notification_infos.get(task_id) or []

    async def delete_info(
        self, task_id: str, config_id: str | None = None
    ) -> None:
        """Deletes the push notification configuration for a task from memory."""
        async with self.lock:
            if config_id is None:
                config_id = task_id

            if task_id in self._push_notification_infos:
                configurations = self._push_notification_infos[task_id]
                if not configurations:
                    return

                for config in configurations:
                    if config.id == config_id:
                        configurations.remove(config)
                        break

                if len(configurations) == 0:
                    del self._push_notification_infos[task_id]



---
File: /a2a-python/src/a2a/server/tasks/inmemory_task_store.py
---

import asyncio
import logging

from a2a.server.tasks.task_store import TaskStore
from a2a.types import Task


logger = logging.getLogger(__name__)


class InMemoryTaskStore(TaskStore):
    """In-memory implementation of TaskStore.

    Stores task objects in a dictionary in memory. Task data is lost when the
    server process stops.
    """

    def __init__(self) -> None:
        """Initializes the InMemoryTaskStore."""
        logger.debug('Initializing InMemoryTaskStore')
        self.tasks: dict[str, Task] = {}
        self.lock = asyncio.Lock()

    async def save(self, task: Task) -> None:
        """Saves or updates a task in the in-memory store."""
        async with self.lock:
            self.tasks[task.id] = task
            logger.debug('Task %s saved successfully.', task.id)

    async def get(self, task_id: str) -> Task | None:
        """Retrieves a task from the in-memory store by ID."""
        async with self.lock:
            logger.debug('Attempting to get task with id: %s', task_id)
            task = self.tasks.get(task_id)
            if task:
                logger.debug('Task %s retrieved successfully.', task_id)
            else:
                logger.debug('Task %s not found in store.', task_id)
            return task

    async def delete(self, task_id: str) -> None:
        """Deletes a task from the in-memory store by ID."""
        async with self.lock:
            logger.debug('Attempting to delete task with id: %s', task_id)
            if task_id in self.tasks:
                del self.tasks[task_id]
                logger.debug('Task %s deleted successfully.', task_id)
            else:
                logger.warning(
                    'Attempted to delete nonexistent task with id: %s', task_id
                )



---
File: /a2a-python/src/a2a/server/tasks/push_notification_config_store.py
---

from abc import ABC, abstractmethod

from a2a.types import PushNotificationConfig


class PushNotificationConfigStore(ABC):
    """Interface for storing and retrieving push notification configurations for tasks."""

    @abstractmethod
    async def set_info(
        self, task_id: str, notification_config: PushNotificationConfig
    ) -> None:
        """Sets or updates the push notification configuration for a task."""

    @abstractmethod
    async def get_info(self, task_id: str) -> list[PushNotificationConfig]:
        """Retrieves the push notification configuration for a task."""

    @abstractmethod
    async def delete_info(
        self, task_id: str, config_id: str | None = None
    ) -> None:
        """Deletes the push notification configuration for a task."""



---
File: /a2a-python/src/a2a/server/tasks/push_notification_sender.py
---

from abc import ABC, abstractmethod

from a2a.types import Task


class PushNotificationSender(ABC):
    """Interface for sending push notifications for tasks."""

    @abstractmethod
    async def send_notification(self, task: Task) -> None:
        """Sends a push notification containing the latest task state."""



---
File: /a2a-python/src/a2a/server/tasks/result_aggregator.py
---

import asyncio
import logging

from collections.abc import AsyncGenerator, AsyncIterator

from a2a.server.events import Event, EventConsumer
from a2a.server.tasks.task_manager import TaskManager
from a2a.types import Message, Task, TaskState, TaskStatusUpdateEvent


logger = logging.getLogger(__name__)


class ResultAggregator:
    """ResultAggregator is used to process the event streams from an AgentExecutor.

    There are three main ways to use the ResultAggregator:
    1) As part of a processing pipe. consume_and_emit will construct the updated
       task as the events arrive, and re-emit those events for another consumer
    2) As part of a blocking call. consume_all will process the entire stream and
       return the final Task or Message object
    3) As part of a push solution where the latest Task is emitted after processing an event.
       consume_and_emit_task will consume the Event stream, process the events to the current
       Task object and emit that Task object.
    """

    def __init__(self, task_manager: TaskManager):
        """Initializes the ResultAggregator.

        Args:
            task_manager: The `TaskManager` instance to use for processing events
                          and managing the task state.
        """
        self.task_manager = task_manager
        self._message: Message | None = None

    @property
    async def current_result(self) -> Task | Message | None:
        """Returns the current aggregated result (Task or Message).

        This is the latest state processed from the event stream.

        Returns:
            The current `Task` object managed by the `TaskManager`, or the final
            `Message` if one was received, or `None` if no result has been produced yet.
        """
        if self._message:
            return self._message
        return await self.task_manager.get_task()

    async def consume_and_emit(
        self, consumer: EventConsumer
    ) -> AsyncGenerator[Event]:
        """Processes the event stream from the consumer, updates the task state, and re-emits the same events.

        Useful for streaming scenarios where the server needs to observe and
        process events (e.g., save task state, send push notifications) while
        forwarding them to the client.

        Args:
            consumer: The `EventConsumer` to read events from.

        Yields:
            The `Event` objects consumed from the `EventConsumer`.
        """
        async for event in consumer.consume_all():
            await self.task_manager.process(event)
            yield event

    async def consume_all(
        self, consumer: EventConsumer
    ) -> Task | Message | None:
        """Processes the entire event stream from the consumer and returns the final result.

        Blocks until the event stream ends (queue is closed after final event or exception).

        Args:
            consumer: The `EventConsumer` to read events from.

        Returns:
            The final `Task` object or `Message` object after the stream is exhausted.
            Returns `None` if the stream ends without producing a final result.

        Raises:
            BaseException: If the `EventConsumer` raises an exception during consumption.
        """
        async for event in consumer.consume_all():
            if isinstance(event, Message):
                self._message = event
                return event
            await self.task_manager.process(event)
        return await self.task_manager.get_task()

    async def consume_and_break_on_interrupt(
        self, consumer: EventConsumer, blocking: bool = True
    ) -> tuple[Task | Message | None, bool]:
        """Processes the event stream until completion or an interruptable state is encountered.

        If `blocking` is False, it returns after the first event that creates a Task or Message.
        If `blocking` is True, it waits for completion unless an `auth_required`
        state is encountered, which is always an interruption.
        If interrupted, consumption continues in a background task.

        Args:
            consumer: The `EventConsumer` to read events from.
            blocking: If `False`, the method returns as soon as a task/message
                      is available. If `True`, it waits for a terminal state.

        Returns:
            A tuple containing:
            - The current aggregated result (`Task` or `Message`) at the point of completion or interruption.
            - A boolean indicating whether the consumption was interrupted (`True`) or completed naturally (`False`).

        Raises:
            BaseException: If the `EventConsumer` raises an exception during consumption.
        """
        event_stream = consumer.consume_all()
        interrupted = False
        async for event in event_stream:
            if isinstance(event, Message):
                self._message = event
                return event, False
            await self.task_manager.process(event)

            should_interrupt = False
            is_auth_required = (
                isinstance(event, Task | TaskStatusUpdateEvent)
                and event.status.state == TaskState.auth_required
            )

            # Always interrupt on auth_required, as it needs external action.
            if is_auth_required:
                # auth-required is a special state: the message should be
                # escalated back to the caller, but the agent is expected to
                # continue producing events once the authorization is received
                # out-of-band. This is in contrast to input-required, where a
                # new request is expected in order for the agent to make progress,
                # so the agent should exit.
                logger.debug(
                    'Encountered an auth-required task: breaking synchronous message/send flow.'
                )
                should_interrupt = True
            # For non-blocking calls, interrupt as soon as a task is available.
            elif not blocking:
                logger.debug(
                    'Non-blocking call: returning task after first event.'
                )
                should_interrupt = True

            if should_interrupt:
                # Continue consuming the rest of the events in the background.
                # TODO: We should track all outstanding tasks to ensure they eventually complete.
                asyncio.create_task(self._continue_consuming(event_stream))  # noqa: RUF006
                interrupted = True
                break
        return await self.task_manager.get_task(), interrupted

    async def _continue_consuming(
        self, event_stream: AsyncIterator[Event]
    ) -> None:
        """Continues processing an event stream in a background task.

        Used after an interruptable state (like auth_required) is encountered
        in the synchronous consumption flow.

        Args:
            event_stream: The remaining `AsyncIterator` of events from the consumer.
        """
        async for event in event_stream:
            await self.task_manager.process(event)



---
File: /a2a-python/src/a2a/server/tasks/task_manager.py
---

import logging

from a2a.server.events.event_queue import Event
from a2a.server.tasks.task_store import TaskStore
from a2a.types import (
    InvalidParamsError,
    Message,
    Task,
    TaskArtifactUpdateEvent,
    TaskState,
    TaskStatus,
    TaskStatusUpdateEvent,
)
from a2a.utils import append_artifact_to_task
from a2a.utils.errors import ServerError


logger = logging.getLogger(__name__)


class TaskManager:
    """Helps manage a task's lifecycle during execution of a request.

    Responsible for retrieving, saving, and updating the `Task` object based on
    events received from the agent.
    """

    def __init__(
        self,
        task_id: str | None,
        context_id: str | None,
        task_store: TaskStore,
        initial_message: Message | None,
    ):
        """Initializes the TaskManager.

        Args:
            task_id: The ID of the task, if known from the request.
            context_id: The ID of the context, if known from the request.
            task_store: The `TaskStore` instance for persistence.
            initial_message: The `Message` that initiated the task, if any.
                             Used when creating a new task object.
        """
        if task_id is not None and not (isinstance(task_id, str) and task_id):
            raise ValueError('Task ID must be a non-empty string')

        self.task_id = task_id
        self.context_id = context_id
        self.task_store = task_store
        self._initial_message = initial_message
        self._current_task: Task | None = None
        logger.debug(
            'TaskManager initialized with task_id: %s, context_id: %s',
            task_id,
            context_id,
        )

    async def get_task(self) -> Task | None:
        """Retrieves the current task object, either from memory or the store.

        If `task_id` is set, it first checks the in-memory `_current_task`,
        then attempts to load it from the `task_store`.

        Returns:
            The `Task` object if found, otherwise `None`.
        """
        if not self.task_id:
            logger.debug('task_id is not set, cannot get task.')
            return None

        if self._current_task:
            return self._current_task

        logger.debug(
            'Attempting to get task from store with id: %s', self.task_id
        )
        self._current_task = await self.task_store.get(self.task_id)
        if self._current_task:
            logger.debug('Task %s retrieved successfully.', self.task_id)
        else:
            logger.debug('Task %s not found.', self.task_id)
        return self._current_task

    async def save_task_event(
        self, event: Task | TaskStatusUpdateEvent | TaskArtifactUpdateEvent
    ) -> Task | None:
        """Processes a task-related event (Task, Status, Artifact) and saves the updated task state.

        Ensures task and context IDs match or are set from the event.

        Args:
            event: The task-related event (`Task`, `TaskStatusUpdateEvent`, or `TaskArtifactUpdateEvent`).

        Returns:
            The updated `Task` object after processing the event.

        Raises:
            ServerError: If the task ID in the event conflicts with the TaskManager's ID
                         when the TaskManager's ID is already set.
        """
        task_id_from_event = (
            event.id if isinstance(event, Task) else event.task_id
        )
        # If task id is known, make sure it is matched
        if self.task_id and self.task_id != task_id_from_event:
            raise ServerError(
                error=InvalidParamsError(
                    message=f"Task in event doesn't match TaskManager {self.task_id} : {task_id_from_event}"
                )
            )
        if not self.task_id:
            self.task_id = task_id_from_event
        if self.context_id and self.context_id != event.context_id:
            raise ServerError(
                error=InvalidParamsError(
                    message=f"Context in event doesn't match TaskManager {self.context_id} : {event.context_id}"
                )
            )
        if not self.context_id:
            self.context_id = event.context_id

        logger.debug(
            'Processing save of task event of type %s for task_id: %s',
            type(event).__name__,
            task_id_from_event,
        )
        if isinstance(event, Task):
            await self._save_task(event)
            return event

        task: Task = await self.ensure_task(event)

        if isinstance(event, TaskStatusUpdateEvent):
            logger.debug(
                'Updating task %s status to: %s', task.id, event.status.state
            )
            if task.status.message:
                if not task.history:
                    task.history = [task.status.message]
                else:
                    task.history.append(task.status.message)
            if event.metadata:
                if not task.metadata:
                    task.metadata = {}
                task.metadata.update(event.metadata)
            task.status = event.status
        else:
            logger.debug('Appending artifact to task %s', task.id)
            append_artifact_to_task(task, event)

        await self._save_task(task)
        return task

    async def ensure_task(
        self, event: TaskStatusUpdateEvent | TaskArtifactUpdateEvent
    ) -> Task:
        """Ensures a Task object exists in memory, loading from store or creating new if needed.

        Args:
            event: The task-related event triggering the need for a Task object.

        Returns:
            An existing or newly created `Task` object.
        """
        task: Task | None = self._current_task
        if not task and self.task_id:
            logger.debug(
                'Attempting to retrieve existing task with id: %s', self.task_id
            )
            task = await self.task_store.get(self.task_id)

        if not task:
            logger.info(
                'Task not found or task_id not set. Creating new task for event (task_id: %s, context_id: %s).',
                event.task_id,
                event.context_id,
            )
            # streaming agent did not previously stream task object.
            # Create a task object with the available information and persist the event
            task = self._init_task_obj(event.task_id, event.context_id)
            await self._save_task(task)

        return task

    async def process(self, event: Event) -> Event:
        """Processes an event, updates the task state if applicable, stores it, and returns the event.

        If the event is task-related (`Task`, `TaskStatusUpdateEvent`, `TaskArtifactUpdateEvent`),
        the internal task state is updated and persisted.

        Args:
            event: The event object received from the agent.

        Returns:
            The same event object that was processed.
        """
        if isinstance(
            event, Task | TaskStatusUpdateEvent | TaskArtifactUpdateEvent
        ):
            await self.save_task_event(event)

        return event

    def _init_task_obj(self, task_id: str, context_id: str) -> Task:
        """Initializes a new task object in memory.

        Args:
            task_id: The ID for the new task.
            context_id: The context ID for the new task.

        Returns:
            A new `Task` object with initial status and potentially the initial message in history.
        """
        logger.debug(
            'Initializing new Task object with task_id: %s, context_id: %s',
            task_id,
            context_id,
        )
        history = [self._initial_message] if self._initial_message else []
        return Task(
            id=task_id,
            context_id=context_id,
            status=TaskStatus(state=TaskState.submitted),
            history=history,
        )

    async def _save_task(self, task: Task) -> None:
        """Saves the given task to the task store and updates the in-memory `_current_task`.

        Args:
            task: The `Task` object to save.
        """
        logger.debug('Saving task with id: %s', task.id)
        await self.task_store.save(task)
        self._current_task = task
        if not self.task_id:
            logger.info('New task created with id: %s', task.id)
            self.task_id = task.id
            self.context_id = task.context_id

    def update_with_message(self, message: Message, task: Task) -> Task:
        """Updates a task object in memory by adding a new message to its history.

        If the task has a message in its current status, that message is moved
        to the history first.

        Args:
            message: The new `Message` to add to the history.
            task: The `Task` object to update.

        Returns:
            The updated `Task` object (updated in-place).
        """
        if task.status.message:
            if task.history:
                task.history.append(task.status.message)
            else:
                task.history = [task.status.message]
            task.status.message = None
        if task.history:
            task.history.append(message)
        else:
            task.history = [message]
        self._current_task = task
        return task



---
File: /a2a-python/src/a2a/server/tasks/task_store.py
---

from abc import ABC, abstractmethod

from a2a.types import Task


class TaskStore(ABC):
    """Agent Task Store interface.

    Defines the methods for persisting and retrieving `Task` objects.
    """

    @abstractmethod
    async def save(self, task: Task) -> None:
        """Saves or updates a task in the store."""

    @abstractmethod
    async def get(self, task_id: str) -> Task | None:
        """Retrieves a task from the store by ID."""

    @abstractmethod
    async def delete(self, task_id: str) -> None:
        """Deletes a task from the store by ID."""



---
File: /a2a-python/src/a2a/server/tasks/task_updater.py
---

import asyncio
import uuid

from datetime import datetime, timezone
from typing import Any

from a2a.server.events import EventQueue
from a2a.types import (
    Artifact,
    Message,
    Part,
    Role,
    TaskArtifactUpdateEvent,
    TaskState,
    TaskStatus,
    TaskStatusUpdateEvent,
)


class TaskUpdater:
    """Helper class for agents to publish updates to a task's event queue.

    Simplifies the process of creating and enqueueing standard task events.
    """

    def __init__(self, event_queue: EventQueue, task_id: str, context_id: str):
        """Initializes the TaskUpdater.

        Args:
            event_queue: The `EventQueue` associated with the task.
            task_id: The ID of the task.
            context_id: The context ID of the task.
        """
        self.event_queue = event_queue
        self.task_id = task_id
        self.context_id = context_id
        self._lock = asyncio.Lock()
        self._terminal_state_reached = False
        self._terminal_states = {
            TaskState.completed,
            TaskState.canceled,
            TaskState.failed,
            TaskState.rejected,
        }

    async def update_status(
        self,
        state: TaskState,
        message: Message | None = None,
        final: bool = False,
        timestamp: str | None = None,
        metadata: dict[str, Any] | None = None,
    ) -> None:
        """Updates the status of the task and publishes a `TaskStatusUpdateEvent`.

        Args:
            state: The new state of the task.
            message: An optional message associated with the status update.
            final: If True, indicates this is the final status update for the task.
            timestamp: Optional ISO 8601 datetime string. Defaults to current time.
            metadata: Optional metadata for extensions.
        """
        async with self._lock:
            if self._terminal_state_reached:
                raise RuntimeError(
                    f'Task {self.task_id} is already in a terminal state.'
                )
            if state in self._terminal_states:
                self._terminal_state_reached = True
                final = True

            current_timestamp = (
                timestamp
                if timestamp
                else datetime.now(timezone.utc).isoformat()
            )
            await self.event_queue.enqueue_event(
                TaskStatusUpdateEvent(
                    task_id=self.task_id,
                    context_id=self.context_id,
                    final=final,
                    metadata=metadata,
                    status=TaskStatus(
                        state=state,
                        message=message,
                        timestamp=current_timestamp,
                    ),
                )
            )

    async def add_artifact(  # noqa: PLR0913
        self,
        parts: list[Part],
        artifact_id: str | None = None,
        name: str | None = None,
        metadata: dict[str, Any] | None = None,
        append: bool | None = None,
        last_chunk: bool | None = None,
    ) -> None:
        """Adds an artifact chunk to the task and publishes a `TaskArtifactUpdateEvent`.

        Args:
            parts: A list of `Part` objects forming the artifact chunk.
            artifact_id: The ID of the artifact. A new UUID is generated if not provided.
            name: Optional name for the artifact.
            metadata: Optional metadata for the artifact.
            append: Optional boolean indicating if this chunk appends to a previous one.
            last_chunk: Optional boolean indicating if this is the last chunk.
        """
        if not artifact_id:
            artifact_id = str(uuid.uuid4())

        await self.event_queue.enqueue_event(
            TaskArtifactUpdateEvent(
                task_id=self.task_id,
                context_id=self.context_id,
                artifact=Artifact(
                    artifact_id=artifact_id,
                    name=name,
                    parts=parts,
                    metadata=metadata,
                ),
                append=append,
                last_chunk=last_chunk,
            )
        )

    async def complete(self, message: Message | None = None) -> None:
        """Marks the task as completed and publishes a final status update."""
        await self.update_status(
            TaskState.completed,
            message=message,
            final=True,
        )

    async def failed(self, message: Message | None = None) -> None:
        """Marks the task as failed and publishes a final status update."""
        await self.update_status(TaskState.failed, message=message, final=True)

    async def reject(self, message: Message | None = None) -> None:
        """Marks the task as rejected and publishes a final status update."""
        await self.update_status(
            TaskState.rejected, message=message, final=True
        )

    async def submit(self, message: Message | None = None) -> None:
        """Marks the task as submitted and publishes a status update."""
        await self.update_status(
            TaskState.submitted,
            message=message,
        )

    async def start_work(self, message: Message | None = None) -> None:
        """Marks the task as working and publishes a status update."""
        await self.update_status(
            TaskState.working,
            message=message,
        )

    async def cancel(self, message: Message | None = None) -> None:
        """Marks the task as cancelled and publishes a finalstatus update."""
        await self.update_status(
            TaskState.canceled, message=message, final=True
        )

    async def requires_input(
        self, message: Message | None = None, final: bool = False
    ) -> None:
        """Marks the task as input required and publishes a status update."""
        await self.update_status(
            TaskState.input_required,
            message=message,
            final=final,
        )

    async def requires_auth(
        self, message: Message | None = None, final: bool = False
    ) -> None:
        """Marks the task as auth required and publishes a status update."""
        await self.update_status(
            TaskState.auth_required, message=message, final=final
        )

    def new_agent_message(
        self,
        parts: list[Part],
        metadata: dict[str, Any] | None = None,
    ) -> Message:
        """Creates a new message object sent by the agent for this task/context.

        Note: This method only *creates* the message object. It does not
              automatically enqueue it.

        Args:
            parts: A list of `Part` objects for the message content.
            metadata: Optional metadata for the message.

        Returns:
            A new `Message` object.
        """
        return Message(
            role=Role.agent,
            task_id=self.task_id,
            context_id=self.context_id,
            message_id=str(uuid.uuid4()),
            metadata=metadata,
            parts=parts,
        )



---
File: /a2a-python/src/a2a/server/__init__.py
---

"""Server-side components for implementing an A2A agent."""



---
File: /a2a-python/src/a2a/server/context.py
---

"""Defines the ServerCallContext class."""

import collections.abc
import typing

from pydantic import BaseModel, ConfigDict, Field

from a2a.auth.user import UnauthenticatedUser, User


State = collections.abc.MutableMapping[str, typing.Any]


class ServerCallContext(BaseModel):
    """A context passed when calling a server method.

    This class allows storing arbitrary user data in the state attribute.
    """

    model_config = ConfigDict(arbitrary_types_allowed=True)

    state: State = Field(default={})
    user: User = Field(default=UnauthenticatedUser())
    requested_extensions: set[str] = Field(default_factory=set)
    activated_extensions: set[str] = Field(default_factory=set)



---
File: /a2a-python/src/a2a/server/models.py
---

from typing import TYPE_CHECKING, Any, Generic, TypeVar


if TYPE_CHECKING:
    from typing_extensions import override
else:

    def override(func):  # noqa: ANN001, ANN201
        """Override decorator."""
        return func


from pydantic import BaseModel

from a2a.types import Artifact, Message, TaskStatus


try:
    from sqlalchemy import JSON, Dialect, LargeBinary, String
    from sqlalchemy.orm import (
        DeclarativeBase,
        Mapped,
        declared_attr,
        mapped_column,
    )
    from sqlalchemy.types import TypeDecorator
except ImportError as e:
    raise ImportError(
        'Database models require SQLAlchemy. '
        'Install with one of: '
        "'pip install a2a-sdk[postgresql]', "
        "'pip install a2a-sdk[mysql]', "
        "'pip install a2a-sdk[sqlite]', "
        "or 'pip install a2a-sdk[sql]'"
    ) from e


T = TypeVar('T', bound=BaseModel)


class PydanticType(TypeDecorator[T], Generic[T]):
    """SQLAlchemy type that handles Pydantic model serialization."""

    impl = JSON
    cache_ok = True

    def __init__(self, pydantic_type: type[T], **kwargs: dict[str, Any]):
        """Initialize the PydanticType.

        Args:
            pydantic_type: The Pydantic model type to handle.
            **kwargs: Additional arguments for TypeDecorator.
        """
        self.pydantic_type = pydantic_type
        super().__init__(**kwargs)

    def process_bind_param(
        self, value: T | None, dialect: Dialect
    ) -> dict[str, Any] | None:
        """Convert Pydantic model to a JSON-serializable dictionary for the database."""
        if value is None:
            return None
        return (
            value.model_dump(mode='json')
            if isinstance(value, BaseModel)
            else value
        )

    def process_result_value(
        self, value: dict[str, Any] | None, dialect: Dialect
    ) -> T | None:
        """Convert a JSON-like dictionary from the database back to a Pydantic model."""
        if value is None:
            return None
        return self.pydantic_type.model_validate(value)


class PydanticListType(TypeDecorator, Generic[T]):
    """SQLAlchemy type that handles lists of Pydantic models."""

    impl = JSON
    cache_ok = True

    def __init__(self, pydantic_type: type[T], **kwargs: dict[str, Any]):
        """Initialize the PydanticListType.

        Args:
            pydantic_type: The Pydantic model type for items in the list.
            **kwargs: Additional arguments for TypeDecorator.
        """
        self.pydantic_type = pydantic_type
        super().__init__(**kwargs)

    def process_bind_param(
        self, value: list[T] | None, dialect: Dialect
    ) -> list[dict[str, Any]] | None:
        """Convert a list of Pydantic models to a JSON-serializable list for the DB."""
        if value is None:
            return None
        return [
            item.model_dump(mode='json')
            if isinstance(item, BaseModel)
            else item
            for item in value
        ]

    def process_result_value(
        self, value: list[dict[str, Any]] | None, dialect: Dialect
    ) -> list[T] | None:
        """Convert a JSON-like list from the DB back to a list of Pydantic models."""
        if value is None:
            return None
        return [self.pydantic_type.model_validate(item) for item in value]


# Base class for all database models
class Base(DeclarativeBase):
    """Base class for declarative models in A2A SDK."""


# TaskMixin that can be used with any table name
class TaskMixin:
    """Mixin providing standard task columns with proper type handling."""

    id: Mapped[str] = mapped_column(String(36), primary_key=True, index=True)
    context_id: Mapped[str] = mapped_column(String(36), nullable=False)
    kind: Mapped[str] = mapped_column(
        String(16), nullable=False, default='task'
    )

    # Properly typed Pydantic fields with automatic serialization
    status: Mapped[TaskStatus] = mapped_column(PydanticType(TaskStatus))
    artifacts: Mapped[list[Artifact] | None] = mapped_column(
        PydanticListType(Artifact), nullable=True
    )
    history: Mapped[list[Message] | None] = mapped_column(
        PydanticListType(Message), nullable=True
    )

    # Using declared_attr to avoid conflict with Pydantic's metadata
    @declared_attr
    @classmethod
    def task_metadata(cls) -> Mapped[dict[str, Any] | None]:
        """Define the 'metadata' column, avoiding name conflicts with Pydantic."""
        return mapped_column(JSON, nullable=True, name='metadata')

    @override
    def __repr__(self) -> str:
        """Return a string representation of the task."""
        repr_template = (
            '<{CLS}(id="{ID}", context_id="{CTX_ID}", status="{STATUS}")>'
        )
        return repr_template.format(
            CLS=self.__class__.__name__,
            ID=self.id,
            CTX_ID=self.context_id,
            STATUS=self.status,
        )


def create_task_model(
    table_name: str = 'tasks', base: type[DeclarativeBase] = Base
) -> type:
    """Create a TaskModel class with a configurable table name.

    Args:
        table_name: Name of the database table. Defaults to 'tasks'.
        base: Base declarative class to use. Defaults to the SDK's Base class.

    Returns:
        TaskModel class with the specified table name.

    Example:
        # Create a task model with default table name
        TaskModel = create_task_model()

        # Create a task model with custom table name
        CustomTaskModel = create_task_model('my_tasks')

        # Use with a custom base
        from myapp.database import Base as MyBase
        TaskModel = create_task_model('tasks', MyBase)
    """

    class TaskModel(TaskMixin, base):  # type: ignore
        __tablename__ = table_name

        @override
        def __repr__(self) -> str:
            """Return a string representation of the task."""
            repr_template = '<TaskModel[{TABLE}](id="{ID}", context_id="{CTX_ID}", status="{STATUS}")>'
            return repr_template.format(
                TABLE=table_name,
                ID=self.id,
                CTX_ID=self.context_id,
                STATUS=self.status,
            )

    # Set a dynamic name for better debugging
    TaskModel.__name__ = f'TaskModel_{table_name}'
    TaskModel.__qualname__ = f'TaskModel_{table_name}'

    return TaskModel


# Default TaskModel for backward compatibility
class TaskModel(TaskMixin, Base):
    """Default task model with standard table name."""

    __tablename__ = 'tasks'


# PushNotificationConfigMixin that can be used with any table name
class PushNotificationConfigMixin:
    """Mixin providing standard push notification config columns."""

    task_id: Mapped[str] = mapped_column(String(36), primary_key=True)
    config_id: Mapped[str] = mapped_column(String(255), primary_key=True)
    config_data: Mapped[bytes] = mapped_column(LargeBinary, nullable=False)

    @override
    def __repr__(self) -> str:
        """Return a string representation of the push notification config."""
        repr_template = '<{CLS}(task_id="{TID}", config_id="{CID}")>'
        return repr_template.format(
            CLS=self.__class__.__name__,
            TID=self.task_id,
            CID=self.config_id,
        )


def create_push_notification_config_model(
    table_name: str = 'push_notification_configs',
    base: type[DeclarativeBase] = Base,
) -> type:
    """Create a PushNotificationConfigModel class with a configurable table name."""

    class PushNotificationConfigModel(PushNotificationConfigMixin, base):  # type: ignore
        __tablename__ = table_name

        @override
        def __repr__(self) -> str:
            """Return a string representation of the push notification config."""
            repr_template = '<PushNotificationConfigModel[{TABLE}](task_id="{TID}", config_id="{CID}")>'
            return repr_template.format(
                TABLE=table_name,
                TID=self.task_id,
                CID=self.config_id,
            )

    PushNotificationConfigModel.__name__ = (
        f'PushNotificationConfigModel_{table_name}'
    )
    PushNotificationConfigModel.__qualname__ = (
        f'PushNotificationConfigModel_{table_name}'
    )

    return PushNotificationConfigModel


# Default PushNotificationConfigModel for backward compatibility
class PushNotificationConfigModel(PushNotificationConfigMixin, Base):
    """Default push notification config model with standard table name."""

    __tablename__ = 'push_notification_configs'



---
File: /a2a-python/src/a2a/utils/__init__.py
---

"""Utility functions for the A2A Python SDK."""

from a2a.utils.artifact import (
    new_artifact,
    new_data_artifact,
    new_text_artifact,
)
from a2a.utils.constants import (
    AGENT_CARD_WELL_KNOWN_PATH,
    DEFAULT_RPC_URL,
    EXTENDED_AGENT_CARD_PATH,
    PREV_AGENT_CARD_WELL_KNOWN_PATH,
)
from a2a.utils.helpers import (
    append_artifact_to_task,
    are_modalities_compatible,
    build_text_artifact,
    create_task_obj,
)
from a2a.utils.message import (
    get_data_parts,
    get_file_parts,
    get_message_text,
    get_text_parts,
    new_agent_parts_message,
    new_agent_text_message,
)
from a2a.utils.task import (
    completed_task,
    new_task,
)


__all__ = [
    'AGENT_CARD_WELL_KNOWN_PATH',
    'DEFAULT_RPC_URL',
    'EXTENDED_AGENT_CARD_PATH',
    'PREV_AGENT_CARD_WELL_KNOWN_PATH',
    'append_artifact_to_task',
    'are_modalities_compatible',
    'build_text_artifact',
    'completed_task',
    'create_task_obj',
    'get_data_parts',
    'get_file_parts',
    'get_message_text',
    'get_text_parts',
    'new_agent_parts_message',
    'new_agent_text_message',
    'new_artifact',
    'new_data_artifact',
    'new_task',
    'new_text_artifact',
]



---
File: /a2a-python/src/a2a/utils/artifact.py
---

"""Utility functions for creating A2A Artifact objects."""

import uuid

from typing import Any

from a2a.types import Artifact, DataPart, Part, TextPart


def new_artifact(
    parts: list[Part], name: str, description: str = ''
) -> Artifact:
    """Creates a new Artifact object.

    Args:
        parts: The list of `Part` objects forming the artifact's content.
        name: The human-readable name of the artifact.
        description: An optional description of the artifact.

    Returns:
        A new `Artifact` object with a generated artifact_id.
    """
    return Artifact(
        artifact_id=str(uuid.uuid4()),
        parts=parts,
        name=name,
        description=description,
    )


def new_text_artifact(
    name: str,
    text: str,
    description: str = '',
) -> Artifact:
    """Creates a new Artifact object containing only a single TextPart.

    Args:
        name: The human-readable name of the artifact.
        text: The text content of the artifact.
        description: An optional description of the artifact.

    Returns:
        A new `Artifact` object with a generated artifact_id.
    """
    return new_artifact(
        [Part(root=TextPart(text=text))],
        name,
        description,
    )


def new_data_artifact(
    name: str,
    data: dict[str, Any],
    description: str = '',
) -> Artifact:
    """Creates a new Artifact object containing only a single DataPart.

    Args:
        name: The human-readable name of the artifact.
        data: The structured data content of the artifact.
        description: An optional description of the artifact.

    Returns:
        A new `Artifact` object with a generated artifact_id.
    """
    return new_artifact(
        [Part(root=DataPart(data=data))],
        name,
        description,
    )



---
File: /a2a-python/src/a2a/utils/constants.py
---

"""Constants for well-known URIs used throughout the A2A Python SDK."""

AGENT_CARD_WELL_KNOWN_PATH = '/.well-known/agent-card.json'
PREV_AGENT_CARD_WELL_KNOWN_PATH = '/.well-known/agent.json'
EXTENDED_AGENT_CARD_PATH = '/agent/authenticatedExtendedCard'
DEFAULT_RPC_URL = '/'



---
File: /a2a-python/src/a2a/utils/error_handlers.py
---

import functools
import logging

from collections.abc import Awaitable, Callable, Coroutine
from typing import TYPE_CHECKING, Any


if TYPE_CHECKING:
    from starlette.responses import JSONResponse, Response
else:
    try:
        from starlette.responses import JSONResponse, Response
    except ImportError:
        JSONResponse = Any
        Response = Any


from a2a._base import A2ABaseModel
from a2a.types import (
    AuthenticatedExtendedCardNotConfiguredError,
    ContentTypeNotSupportedError,
    InternalError,
    InvalidAgentResponseError,
    InvalidParamsError,
    InvalidRequestError,
    JSONParseError,
    MethodNotFoundError,
    PushNotificationNotSupportedError,
    TaskNotCancelableError,
    TaskNotFoundError,
    UnsupportedOperationError,
)
from a2a.utils.errors import ServerError


logger = logging.getLogger(__name__)

A2AErrorToHttpStatus: dict[type[A2ABaseModel], int] = {
    JSONParseError: 400,
    InvalidRequestError: 400,
    MethodNotFoundError: 404,
    InvalidParamsError: 422,
    InternalError: 500,
    TaskNotFoundError: 404,
    TaskNotCancelableError: 409,
    PushNotificationNotSupportedError: 501,
    UnsupportedOperationError: 501,
    ContentTypeNotSupportedError: 415,
    InvalidAgentResponseError: 502,
    AuthenticatedExtendedCardNotConfiguredError: 404,
}


def rest_error_handler(
    func: Callable[..., Awaitable[Response]],
) -> Callable[..., Awaitable[Response]]:
    """Decorator to catch ServerError and map it to an appropriate JSONResponse."""

    @functools.wraps(func)
    async def wrapper(*args: Any, **kwargs: Any) -> Response:
        try:
            return await func(*args, **kwargs)
        except ServerError as e:
            error = e.error or InternalError(
                message='Internal error due to unknown reason'
            )
            http_code = A2AErrorToHttpStatus.get(type(error), 500)

            log_level = (
                logging.ERROR
                if isinstance(error, InternalError)
                else logging.WARNING
            )
            logger.log(
                log_level,
                'Request error: '
                f"Code={error.code}, Message='{error.message}'"
                f'{", Data=" + str(error.data) if error.data else ""}',
            )
            return JSONResponse(
                content={'message': error.message}, status_code=http_code
            )
        except Exception as e:  # noqa: BLE001
            logger.log(logging.ERROR, f'Unknown error occurred {e}')
            return JSONResponse(
                content={'message': 'unknown exception'}, status_code=500
            )

    return wrapper


def rest_stream_error_handler(
    func: Callable[..., Coroutine[Any, Any, Any]],
) -> Callable[..., Coroutine[Any, Any, Any]]:
    """Decorator to catch ServerError for a streaming method,log it and then rethrow it to be handled by framework."""

    @functools.wraps(func)
    async def wrapper(*args: Any, **kwargs: Any) -> Any:
        try:
            return await func(*args, **kwargs)
        except ServerError as e:
            error = e.error or InternalError(
                message='Internal error due to unknown reason'
            )

            log_level = (
                logging.ERROR
                if isinstance(error, InternalError)
                else logging.WARNING
            )
            logger.log(
                log_level,
                'Request error: '
                f"Code={error.code}, Message='{error.message}'"
                f'{", Data=" + str(error.data) if error.data else ""}',
            )
            # Since the stream has started, we can't return a JSONResponse.
            # Instead, we runt the error handling logic (provides logging)
            # and reraise the error and let server framework manage
            raise e
        except Exception as e:
            # Since the stream has started, we can't return a JSONResponse.
            # Instead, we runt the error handling logic (provides logging)
            # and reraise the error and let server framework manage
            raise e

    return wrapper



---
File: /a2a-python/src/a2a/utils/errors.py
---

"""Custom exceptions for A2A server-side errors."""

from a2a.types import (
    AuthenticatedExtendedCardNotConfiguredError,
    ContentTypeNotSupportedError,
    InternalError,
    InvalidAgentResponseError,
    InvalidParamsError,
    InvalidRequestError,
    JSONParseError,
    JSONRPCError,
    MethodNotFoundError,
    PushNotificationNotSupportedError,
    TaskNotCancelableError,
    TaskNotFoundError,
    UnsupportedOperationError,
)


class A2AServerError(Exception):
    """Base exception for A2A Server errors."""


class MethodNotImplementedError(A2AServerError):
    """Exception raised for methods that are not implemented by the server handler."""

    def __init__(
        self, message: str = 'This method is not implemented by the server'
    ):
        """Initializes the MethodNotImplementedError.

        Args:
            message: A descriptive error message.
        """
        self.message = message
        super().__init__(f'Not Implemented operation Error: {message}')


class ServerError(Exception):
    """Wrapper exception for A2A or JSON-RPC errors originating from the server's logic.

    This exception is used internally by request handlers and other server components
    to signal a specific error that should be formatted as a JSON-RPC error response.
    """

    def __init__(
        self,
        error: (
            JSONRPCError
            | JSONParseError
            | InvalidRequestError
            | MethodNotFoundError
            | InvalidParamsError
            | InternalError
            | TaskNotFoundError
            | TaskNotCancelableError
            | PushNotificationNotSupportedError
            | UnsupportedOperationError
            | ContentTypeNotSupportedError
            | InvalidAgentResponseError
            | AuthenticatedExtendedCardNotConfiguredError
            | None
        ),
    ):
        """Initializes the ServerError.

        Args:
            error: The specific A2A or JSON-RPC error model instance.
                   If None, an `InternalError` will be used when formatting the response.
        """
        self.error = error



---
File: /a2a-python/src/a2a/utils/helpers.py
---

"""General utility functions for the A2A Python SDK."""

import functools
import inspect
import logging

from collections.abc import Callable
from typing import Any
from uuid import uuid4

from a2a.types import (
    Artifact,
    MessageSendParams,
    Part,
    Task,
    TaskArtifactUpdateEvent,
    TaskState,
    TaskStatus,
    TextPart,
)
from a2a.utils.errors import ServerError, UnsupportedOperationError
from a2a.utils.telemetry import trace_function


logger = logging.getLogger(__name__)


@trace_function()
def create_task_obj(message_send_params: MessageSendParams) -> Task:
    """Create a new task object from message send params.

    Generates UUIDs for task and context IDs if they are not already present in the message.

    Args:
        message_send_params: The `MessageSendParams` object containing the initial message.

    Returns:
        A new `Task` object initialized with 'submitted' status and the input message in history.
    """
    if not message_send_params.message.context_id:
        message_send_params.message.context_id = str(uuid4())

    return Task(
        id=str(uuid4()),
        context_id=message_send_params.message.context_id,
        status=TaskStatus(state=TaskState.submitted),
        history=[message_send_params.message],
    )


@trace_function()
def append_artifact_to_task(task: Task, event: TaskArtifactUpdateEvent) -> None:
    """Helper method for updating a Task object with new artifact data from an event.

    Handles creating the artifacts list if it doesn't exist, adding new artifacts,
    and appending parts to existing artifacts based on the `append` flag in the event.

    Args:
        task: The `Task` object to modify.
        event: The `TaskArtifactUpdateEvent` containing the artifact data.
    """
    if not task.artifacts:
        task.artifacts = []

    new_artifact_data: Artifact = event.artifact
    artifact_id: str = new_artifact_data.artifact_id
    append_parts: bool = event.append or False

    existing_artifact: Artifact | None = None
    existing_artifact_list_index: int | None = None

    # Find existing artifact by its id
    for i, art in enumerate(task.artifacts):
        if art.artifact_id == artifact_id:
            existing_artifact = art
            existing_artifact_list_index = i
            break

    if not append_parts:
        # This represents the first chunk for this artifact index.
        if existing_artifact_list_index is not None:
            # Replace the existing artifact entirely with the new data
            logger.debug(
                f'Replacing artifact at id {artifact_id} for task {task.id}'
            )
            task.artifacts[existing_artifact_list_index] = new_artifact_data
        else:
            # Append the new artifact since no artifact with this index exists yet
            logger.debug(
                f'Adding new artifact with id {artifact_id} for task {task.id}'
            )
            task.artifacts.append(new_artifact_data)
    elif existing_artifact:
        # Append new parts to the existing artifact's part list
        logger.debug(
            f'Appending parts to artifact id {artifact_id} for task {task.id}'
        )
        existing_artifact.parts.extend(new_artifact_data.parts)
    else:
        # We received a chunk to append, but we don't have an existing artifact.
        # we will ignore this chunk
        logger.warning(
            f'Received append=True for nonexistent artifact index {artifact_id} in task {task.id}. Ignoring chunk.'
        )


def build_text_artifact(text: str, artifact_id: str) -> Artifact:
    """Helper to create a text artifact.

    Args:
        text: The text content for the artifact.
        artifact_id: The ID for the artifact.

    Returns:
        An `Artifact` object containing a single `TextPart`.
    """
    text_part = TextPart(text=text)
    part = Part(root=text_part)
    return Artifact(parts=[part], artifact_id=artifact_id)


def validate(
    expression: Callable[[Any], bool], error_message: str | None = None
) -> Callable:
    """Decorator that validates if a given expression evaluates to True.

    Typically used on class methods to check capabilities or configuration
    before executing the method's logic. If the expression is False,
    a `ServerError` with an `UnsupportedOperationError` is raised.

    Args:
        expression: A callable that takes the instance (`self`) as its argument
                    and returns a boolean.
        error_message: An optional custom error message for the `UnsupportedOperationError`.
                       If None, the string representation of the expression will be used.
    """

    def decorator(function: Callable) -> Callable:
        if inspect.iscoroutinefunction(function):

            @functools.wraps(function)
            async def async_wrapper(self: Any, *args, **kwargs) -> Any:
                if not expression(self):
                    final_message = error_message or str(expression)
                    logger.error(f'Unsupported Operation: {final_message}')
                    raise ServerError(
                        UnsupportedOperationError(message=final_message)
                    )
                return await function(self, *args, **kwargs)

            return async_wrapper

        @functools.wraps(function)
        def sync_wrapper(self: Any, *args, **kwargs) -> Any:
            if not expression(self):
                final_message = error_message or str(expression)
                logger.error(f'Unsupported Operation: {final_message}')
                raise ServerError(
                    UnsupportedOperationError(message=final_message)
                )
            return function(self, *args, **kwargs)

        return sync_wrapper

    return decorator


def validate_async_generator(
    expression: Callable[[Any], bool], error_message: str | None = None
):
    """Decorator that validates if a given expression evaluates to True.

    Typically used on class methods to check capabilities or configuration
    before executing the method's logic. If the expression is False,
    a `ServerError` with an `UnsupportedOperationError` is raised.

    Args:
        expression: A callable that takes the instance (`self`) as its argument
                    and returns a boolean.
        error_message: An optional custom error message for the `UnsupportedOperationError`.
                       If None, the string representation of the expression will be used.
    """

    def decorator(function):
        @functools.wraps(function)
        async def wrapper(self, *args, **kwargs):
            if not expression(self):
                final_message = error_message or str(expression)
                logger.error(f'Unsupported Operation: {final_message}')
                raise ServerError(
                    UnsupportedOperationError(message=final_message)
                )
            async for i in function(self, *args, **kwargs):
                yield i

        return wrapper

    return decorator


def are_modalities_compatible(
    server_output_modes: list[str] | None, client_output_modes: list[str] | None
) -> bool:
    """Checks if server and client output modalities (MIME types) are compatible.

    Modalities are compatible if:
    1. The client specifies no preferred output modes (client_output_modes is None or empty).
    2. The server specifies no supported output modes (server_output_modes is None or empty).
    3. There is at least one common modality between the server's supported list and the client's preferred list.

    Args:
        server_output_modes: A list of MIME types supported by the server/agent for output.
                             Can be None or empty if the server doesn't specify.
        client_output_modes: A list of MIME types preferred by the client for output.
                             Can be None or empty if the client accepts any.

    Returns:
        True if the modalities are compatible, False otherwise.
    """
    if client_output_modes is None or len(client_output_modes) == 0:
        return True

    if server_output_modes is None or len(server_output_modes) == 0:
        return True

    return any(x in server_output_modes for x in client_output_modes)



---
File: /a2a-python/src/a2a/utils/message.py
---

"""Utility functions for creating and handling A2A Message objects."""

import uuid

from typing import Any

from a2a.types import (
    DataPart,
    FilePart,
    FileWithBytes,
    FileWithUri,
    Message,
    Part,
    Role,
    TextPart,
)


def new_agent_text_message(
    text: str,
    context_id: str | None = None,
    task_id: str | None = None,
) -> Message:
    """Creates a new agent message containing a single TextPart.

    Args:
        text: The text content of the message.
        context_id: The context ID for the message.
        task_id: The task ID for the message.

    Returns:
        A new `Message` object with role 'agent'.
    """
    return Message(
        role=Role.agent,
        parts=[Part(root=TextPart(text=text))],
        message_id=str(uuid.uuid4()),
        task_id=task_id,
        context_id=context_id,
    )


def new_agent_parts_message(
    parts: list[Part],
    context_id: str | None = None,
    task_id: str | None = None,
) -> Message:
    """Creates a new agent message containing a list of Parts.

    Args:
        parts: The list of `Part` objects for the message content.
        context_id: The context ID for the message.
        task_id: The task ID for the message.

    Returns:
        A new `Message` object with role 'agent'.
    """
    return Message(
        role=Role.agent,
        parts=parts,
        message_id=str(uuid.uuid4()),
        task_id=task_id,
        context_id=context_id,
    )


def get_text_parts(parts: list[Part]) -> list[str]:
    """Extracts text content from all TextPart objects in a list of Parts.

    Args:
        parts: A list of `Part` objects.

    Returns:
        A list of strings containing the text content from any `TextPart` objects found.
    """
    return [part.root.text for part in parts if isinstance(part.root, TextPart)]


def get_data_parts(parts: list[Part]) -> list[dict[str, Any]]:
    """Extracts dictionary data from all DataPart objects in a list of Parts.

    Args:
        parts: A list of `Part` objects.

    Returns:
        A list of dictionaries containing the data from any `DataPart` objects found.
    """
    return [part.root.data for part in parts if isinstance(part.root, DataPart)]


def get_file_parts(parts: list[Part]) -> list[FileWithBytes | FileWithUri]:
    """Extracts file data from all FilePart objects in a list of Parts.

    Args:
        parts: A list of `Part` objects.

    Returns:
        A list of `FileWithBytes` or `FileWithUri` objects containing the file data from any `FilePart` objects found.
    """
    return [part.root.file for part in parts if isinstance(part.root, FilePart)]


def get_message_text(message: Message, delimiter: str = '\n') -> str:
    """Extracts and joins all text content from a Message's parts.

    Args:
        message: The `Message` object.
        delimiter: The string to use when joining text from multiple TextParts.

    Returns:
        A single string containing all text content, or an empty string if no text parts are found.
    """
    return delimiter.join(get_text_parts(message.parts))



---
File: /a2a-python/src/a2a/utils/proto_utils.py
---

# mypy: disable-error-code="arg-type"
"""Utils for converting between proto and Python types."""

import json
import logging
import re

from typing import Any

from google.protobuf import json_format, struct_pb2

from a2a import types
from a2a.grpc import a2a_pb2
from a2a.utils.errors import ServerError


logger = logging.getLogger(__name__)


# Regexp patterns for matching
_TASK_NAME_MATCH = r'tasks/([\w-]+)'
_TASK_PUSH_CONFIG_NAME_MATCH = (
    r'tasks/([\w-]+)/pushNotificationConfigs/([\w-]+)'
)


class ToProto:
    """Converts Python types to proto types."""

    @classmethod
    def message(cls, message: types.Message | None) -> a2a_pb2.Message | None:
        if message is None:
            return None
        return a2a_pb2.Message(
            message_id=message.message_id,
            content=[ToProto.part(p) for p in message.parts],
            context_id=message.context_id or '',
            task_id=message.task_id or '',
            role=cls.role(message.role),
            metadata=ToProto.metadata(message.metadata),
        )

    @classmethod
    def metadata(
        cls, metadata: dict[str, Any] | None
    ) -> struct_pb2.Struct | None:
        if metadata is None:
            return None
        return struct_pb2.Struct(
            # TODO: Add support for other types.
            fields={
                key: struct_pb2.Value(string_value=value)
                for key, value in metadata.items()
                if isinstance(value, str)
            }
        )

    @classmethod
    def part(cls, part: types.Part) -> a2a_pb2.Part:
        if isinstance(part.root, types.TextPart):
            return a2a_pb2.Part(text=part.root.text)
        if isinstance(part.root, types.FilePart):
            return a2a_pb2.Part(file=ToProto.file(part.root.file))
        if isinstance(part.root, types.DataPart):
            return a2a_pb2.Part(data=ToProto.data(part.root.data))
        raise ValueError(f'Unsupported part type: {part.root}')

    @classmethod
    def data(cls, data: dict[str, Any]) -> a2a_pb2.DataPart:
        json_data = json.dumps(data)
        return a2a_pb2.DataPart(
            data=json_format.Parse(
                json_data,
                struct_pb2.Struct(),
            )
        )

    @classmethod
    def file(
        cls, file: types.FileWithUri | types.FileWithBytes
    ) -> a2a_pb2.FilePart:
        if isinstance(file, types.FileWithUri):
            return a2a_pb2.FilePart(file_with_uri=file.uri)
        return a2a_pb2.FilePart(file_with_bytes=file.bytes.encode('utf-8'))

    @classmethod
    def task(cls, task: types.Task) -> a2a_pb2.Task:
        return a2a_pb2.Task(
            id=task.id,
            context_id=task.context_id,
            status=ToProto.task_status(task.status),
            artifacts=(
                [ToProto.artifact(a) for a in task.artifacts]
                if task.artifacts
                else None
            ),
            history=(
                [ToProto.message(h) for h in task.history]  # type: ignore[misc]
                if task.history
                else None
            ),
        )

    @classmethod
    def task_status(cls, status: types.TaskStatus) -> a2a_pb2.TaskStatus:
        return a2a_pb2.TaskStatus(
            state=ToProto.task_state(status.state),
            update=ToProto.message(status.message),
        )

    @classmethod
    def task_state(cls, state: types.TaskState) -> a2a_pb2.TaskState:
        match state:
            case types.TaskState.submitted:
                return a2a_pb2.TaskState.TASK_STATE_SUBMITTED
            case types.TaskState.working:
                return a2a_pb2.TaskState.TASK_STATE_WORKING
            case types.TaskState.completed:
                return a2a_pb2.TaskState.TASK_STATE_COMPLETED
            case types.TaskState.canceled:
                return a2a_pb2.TaskState.TASK_STATE_CANCELLED
            case types.TaskState.failed:
                return a2a_pb2.TaskState.TASK_STATE_FAILED
            case types.TaskState.input_required:
                return a2a_pb2.TaskState.TASK_STATE_INPUT_REQUIRED
            case _:
                return a2a_pb2.TaskState.TASK_STATE_UNSPECIFIED

    @classmethod
    def artifact(cls, artifact: types.Artifact) -> a2a_pb2.Artifact:
        return a2a_pb2.Artifact(
            artifact_id=artifact.artifact_id,
            description=artifact.description,
            metadata=ToProto.metadata(artifact.metadata),
            name=artifact.name,
            parts=[ToProto.part(p) for p in artifact.parts],
        )

    @classmethod
    def authentication_info(
        cls, info: types.PushNotificationAuthenticationInfo
    ) -> a2a_pb2.AuthenticationInfo:
        return a2a_pb2.AuthenticationInfo(
            schemes=info.schemes,
            credentials=info.credentials,
        )

    @classmethod
    def push_notification_config(
        cls, config: types.PushNotificationConfig
    ) -> a2a_pb2.PushNotificationConfig:
        auth_info = (
            ToProto.authentication_info(config.authentication)
            if config.authentication
            else None
        )
        return a2a_pb2.PushNotificationConfig(
            id=config.id or '',
            url=config.url,
            token=config.token,
            authentication=auth_info,
        )

    @classmethod
    def task_artifact_update_event(
        cls, event: types.TaskArtifactUpdateEvent
    ) -> a2a_pb2.TaskArtifactUpdateEvent:
        return a2a_pb2.TaskArtifactUpdateEvent(
            task_id=event.task_id,
            context_id=event.context_id,
            artifact=ToProto.artifact(event.artifact),
            metadata=ToProto.metadata(event.metadata),
            append=event.append or False,
            last_chunk=event.last_chunk or False,
        )

    @classmethod
    def task_status_update_event(
        cls, event: types.TaskStatusUpdateEvent
    ) -> a2a_pb2.TaskStatusUpdateEvent:
        return a2a_pb2.TaskStatusUpdateEvent(
            task_id=event.task_id,
            context_id=event.context_id,
            status=ToProto.task_status(event.status),
            metadata=ToProto.metadata(event.metadata),
            final=event.final,
        )

    @classmethod
    def message_send_configuration(
        cls, config: types.MessageSendConfiguration | None
    ) -> a2a_pb2.SendMessageConfiguration:
        if not config:
            return a2a_pb2.SendMessageConfiguration()
        return a2a_pb2.SendMessageConfiguration(
            accepted_output_modes=config.accepted_output_modes,
            push_notification=ToProto.push_notification_config(
                config.push_notification_config
            )
            if config.push_notification_config
            else None,
            history_length=config.history_length,
            blocking=config.blocking or False,
        )

    @classmethod
    def update_event(
        cls,
        event: types.Task
        | types.Message
        | types.TaskStatusUpdateEvent
        | types.TaskArtifactUpdateEvent,
    ) -> a2a_pb2.StreamResponse:
        """Converts a task, message, or task update event to a StreamResponse."""
        if isinstance(event, types.TaskStatusUpdateEvent):
            return a2a_pb2.StreamResponse(
                status_update=ToProto.task_status_update_event(event)
            )
        if isinstance(event, types.TaskArtifactUpdateEvent):
            return a2a_pb2.StreamResponse(
                artifact_update=ToProto.task_artifact_update_event(event)
            )
        if isinstance(event, types.Message):
            return a2a_pb2.StreamResponse(msg=ToProto.message(event))
        if isinstance(event, types.Task):
            return a2a_pb2.StreamResponse(task=ToProto.task(event))
        raise ValueError(f'Unsupported event type: {type(event)}')

    @classmethod
    def task_or_message(
        cls, event: types.Task | types.Message
    ) -> a2a_pb2.SendMessageResponse:
        if isinstance(event, types.Message):
            return a2a_pb2.SendMessageResponse(
                msg=cls.message(event),
            )
        return a2a_pb2.SendMessageResponse(
            task=cls.task(event),
        )

    @classmethod
    def stream_response(
        cls,
        event: (
            types.Message
            | types.Task
            | types.TaskStatusUpdateEvent
            | types.TaskArtifactUpdateEvent
        ),
    ) -> a2a_pb2.StreamResponse:
        if isinstance(event, types.Message):
            return a2a_pb2.StreamResponse(msg=cls.message(event))
        if isinstance(event, types.Task):
            return a2a_pb2.StreamResponse(task=cls.task(event))
        if isinstance(event, types.TaskStatusUpdateEvent):
            return a2a_pb2.StreamResponse(
                status_update=cls.task_status_update_event(event),
            )
        return a2a_pb2.StreamResponse(
            artifact_update=cls.task_artifact_update_event(event),
        )

    @classmethod
    def task_push_notification_config(
        cls, config: types.TaskPushNotificationConfig
    ) -> a2a_pb2.TaskPushNotificationConfig:
        return a2a_pb2.TaskPushNotificationConfig(
            name=f'tasks/{config.task_id}/pushNotificationConfigs/{config.push_notification_config.id}',
            push_notification_config=cls.push_notification_config(
                config.push_notification_config,
            ),
        )

    @classmethod
    def agent_card(
        cls,
        card: types.AgentCard,
    ) -> a2a_pb2.AgentCard:
        return a2a_pb2.AgentCard(
            capabilities=cls.capabilities(card.capabilities),
            default_input_modes=list(card.default_input_modes),
            default_output_modes=list(card.default_output_modes),
            description=card.description,
            documentation_url=card.documentation_url,
            name=card.name,
            provider=cls.provider(card.provider),
            security=cls.security(card.security),
            security_schemes=cls.security_schemes(card.security_schemes),
            skills=[cls.skill(x) for x in card.skills] if card.skills else [],
            url=card.url,
            version=card.version,
            supports_authenticated_extended_card=bool(
                card.supports_authenticated_extended_card
            ),
            preferred_transport=card.preferred_transport,
            protocol_version=card.protocol_version,
            additional_interfaces=[
                cls.agent_interface(x) for x in card.additional_interfaces
            ]
            if card.additional_interfaces
            else None,
        )

    @classmethod
    def agent_interface(
        cls,
        interface: types.AgentInterface,
    ) -> a2a_pb2.AgentInterface:
        return a2a_pb2.AgentInterface(
            transport=interface.transport,
            url=interface.url,
        )

    @classmethod
    def capabilities(
        cls, capabilities: types.AgentCapabilities
    ) -> a2a_pb2.AgentCapabilities:
        return a2a_pb2.AgentCapabilities(
            streaming=bool(capabilities.streaming),
            push_notifications=bool(capabilities.push_notifications),
        )

    @classmethod
    def provider(
        cls, provider: types.AgentProvider | None
    ) -> a2a_pb2.AgentProvider | None:
        if not provider:
            return None
        return a2a_pb2.AgentProvider(
            organization=provider.organization,
            url=provider.url,
        )

    @classmethod
    def security(
        cls,
        security: list[dict[str, list[str]]] | None,
    ) -> list[a2a_pb2.Security] | None:
        if not security:
            return None
        return [
            a2a_pb2.Security(
                schemes={k: a2a_pb2.StringList(list=v) for (k, v) in s.items()}
            )
            for s in security
        ]

    @classmethod
    def security_schemes(
        cls,
        schemes: dict[str, types.SecurityScheme] | None,
    ) -> dict[str, a2a_pb2.SecurityScheme] | None:
        if not schemes:
            return None
        return {k: cls.security_scheme(v) for (k, v) in schemes.items()}

    @classmethod
    def security_scheme(
        cls,
        scheme: types.SecurityScheme,
    ) -> a2a_pb2.SecurityScheme:
        if isinstance(scheme.root, types.APIKeySecurityScheme):
            return a2a_pb2.SecurityScheme(
                api_key_security_scheme=a2a_pb2.APIKeySecurityScheme(
                    description=scheme.root.description,
                    location=scheme.root.in_.value,
                    name=scheme.root.name,
                )
            )
        if isinstance(scheme.root, types.HTTPAuthSecurityScheme):
            return a2a_pb2.SecurityScheme(
                http_auth_security_scheme=a2a_pb2.HTTPAuthSecurityScheme(
                    description=scheme.root.description,
                    scheme=scheme.root.scheme,
                    bearer_format=scheme.root.bearer_format,
                )
            )
        if isinstance(scheme.root, types.OAuth2SecurityScheme):
            return a2a_pb2.SecurityScheme(
                oauth2_security_scheme=a2a_pb2.OAuth2SecurityScheme(
                    description=scheme.root.description,
                    flows=cls.oauth2_flows(scheme.root.flows),
                )
            )
        if isinstance(scheme.root, types.MutualTLSSecurityScheme):
            return a2a_pb2.SecurityScheme(
                mtls_security_scheme=a2a_pb2.MutualTlsSecurityScheme(
                    description=scheme.root.description,
                )
            )
        return a2a_pb2.SecurityScheme(
            open_id_connect_security_scheme=a2a_pb2.OpenIdConnectSecurityScheme(
                description=scheme.root.description,
                open_id_connect_url=scheme.root.open_id_connect_url,
            )
        )

    @classmethod
    def oauth2_flows(cls, flows: types.OAuthFlows) -> a2a_pb2.OAuthFlows:
        if flows.authorization_code:
            return a2a_pb2.OAuthFlows(
                authorization_code=a2a_pb2.AuthorizationCodeOAuthFlow(
                    authorization_url=flows.authorization_code.authorization_url,
                    refresh_url=flows.authorization_code.refresh_url,
                    scopes=dict(flows.authorization_code.scopes.items()),
                    token_url=flows.authorization_code.token_url,
                ),
            )
        if flows.client_credentials:
            return a2a_pb2.OAuthFlows(
                client_credentials=a2a_pb2.ClientCredentialsOAuthFlow(
                    refresh_url=flows.client_credentials.refresh_url,
                    scopes=dict(flows.client_credentials.scopes.items()),
                    token_url=flows.client_credentials.token_url,
                ),
            )
        if flows.implicit:
            return a2a_pb2.OAuthFlows(
                implicit=a2a_pb2.ImplicitOAuthFlow(
                    authorization_url=flows.implicit.authorization_url,
                    refresh_url=flows.implicit.refresh_url,
                    scopes=dict(flows.implicit.scopes.items()),
                ),
            )
        if flows.password:
            return a2a_pb2.OAuthFlows(
                password=a2a_pb2.PasswordOAuthFlow(
                    refresh_url=flows.password.refresh_url,
                    scopes=dict(flows.password.scopes.items()),
                    token_url=flows.password.token_url,
                ),
            )
        raise ValueError('Unknown oauth flow definition')

    @classmethod
    def skill(cls, skill: types.AgentSkill) -> a2a_pb2.AgentSkill:
        return a2a_pb2.AgentSkill(
            id=skill.id,
            name=skill.name,
            description=skill.description,
            tags=skill.tags,
            examples=skill.examples,
            input_modes=skill.input_modes,
            output_modes=skill.output_modes,
        )

    @classmethod
    def role(cls, role: types.Role) -> a2a_pb2.Role:
        match role:
            case types.Role.user:
                return a2a_pb2.Role.ROLE_USER
            case types.Role.agent:
                return a2a_pb2.Role.ROLE_AGENT
            case _:
                return a2a_pb2.Role.ROLE_UNSPECIFIED


class FromProto:
    """Converts proto types to Python types."""

    @classmethod
    def message(cls, message: a2a_pb2.Message) -> types.Message:
        return types.Message(
            message_id=message.message_id,
            parts=[FromProto.part(p) for p in message.content],
            context_id=message.context_id or None,
            task_id=message.task_id or None,
            role=FromProto.role(message.role),
            metadata=FromProto.metadata(message.metadata),
        )

    @classmethod
    def metadata(cls, metadata: struct_pb2.Struct) -> dict[str, Any]:
        return {
            key: value.string_value
            for key, value in metadata.fields.items()
            if value.string_value
        }

    @classmethod
    def part(cls, part: a2a_pb2.Part) -> types.Part:
        if part.HasField('text'):
            return types.Part(root=types.TextPart(text=part.text))
        if part.HasField('file'):
            return types.Part(
                root=types.FilePart(file=FromProto.file(part.file))
            )
        if part.HasField('data'):
            return types.Part(
                root=types.DataPart(data=FromProto.data(part.data))
            )
        raise ValueError(f'Unsupported part type: {part}')

    @classmethod
    def data(cls, data: a2a_pb2.DataPart) -> dict[str, Any]:
        json_data = json_format.MessageToJson(data.data)
        return json.loads(json_data)

    @classmethod
    def file(
        cls, file: a2a_pb2.FilePart
    ) -> types.FileWithUri | types.FileWithBytes:
        if file.HasField('file_with_uri'):
            return types.FileWithUri(uri=file.file_with_uri)
        return types.FileWithBytes(bytes=file.file_with_bytes.decode('utf-8'))

    @classmethod
    def task_or_message(
        cls, event: a2a_pb2.SendMessageResponse
    ) -> types.Task | types.Message:
        if event.HasField('msg'):
            return cls.message(event.msg)
        return cls.task(event.task)

    @classmethod
    def task(cls, task: a2a_pb2.Task) -> types.Task:
        return types.Task(
            id=task.id,
            context_id=task.context_id,
            status=FromProto.task_status(task.status),
            artifacts=[FromProto.artifact(a) for a in task.artifacts],
            history=[FromProto.message(h) for h in task.history],
        )

    @classmethod
    def task_status(cls, status: a2a_pb2.TaskStatus) -> types.TaskStatus:
        return types.TaskStatus(
            state=FromProto.task_state(status.state),
            message=FromProto.message(status.update),
        )

    @classmethod
    def task_state(cls, state: a2a_pb2.TaskState) -> types.TaskState:
        match state:
            case a2a_pb2.TaskState.TASK_STATE_SUBMITTED:
                return types.TaskState.submitted
            case a2a_pb2.TaskState.TASK_STATE_WORKING:
                return types.TaskState.working
            case a2a_pb2.TaskState.TASK_STATE_COMPLETED:
                return types.TaskState.completed
            case a2a_pb2.TaskState.TASK_STATE_CANCELLED:
                return types.TaskState.canceled
            case a2a_pb2.TaskState.TASK_STATE_FAILED:
                return types.TaskState.failed
            case a2a_pb2.TaskState.TASK_STATE_INPUT_REQUIRED:
                return types.TaskState.input_required
            case _:
                return types.TaskState.unknown

    @classmethod
    def artifact(cls, artifact: a2a_pb2.Artifact) -> types.Artifact:
        return types.Artifact(
            artifact_id=artifact.artifact_id,
            description=artifact.description,
            metadata=FromProto.metadata(artifact.metadata),
            name=artifact.name,
            parts=[FromProto.part(p) for p in artifact.parts],
        )

    @classmethod
    def task_artifact_update_event(
        cls, event: a2a_pb2.TaskArtifactUpdateEvent
    ) -> types.TaskArtifactUpdateEvent:
        return types.TaskArtifactUpdateEvent(
            task_id=event.task_id,
            context_id=event.context_id,
            artifact=FromProto.artifact(event.artifact),
            metadata=FromProto.metadata(event.metadata),
            append=event.append,
            last_chunk=event.last_chunk,
        )

    @classmethod
    def task_status_update_event(
        cls, event: a2a_pb2.TaskStatusUpdateEvent
    ) -> types.TaskStatusUpdateEvent:
        return types.TaskStatusUpdateEvent(
            task_id=event.task_id,
            context_id=event.context_id,
            status=FromProto.task_status(event.status),
            metadata=FromProto.metadata(event.metadata),
            final=event.final,
        )

    @classmethod
    def push_notification_config(
        cls, config: a2a_pb2.PushNotificationConfig
    ) -> types.PushNotificationConfig:
        return types.PushNotificationConfig(
            id=config.id,
            url=config.url,
            token=config.token,
            authentication=FromProto.authentication_info(config.authentication)
            if config.HasField('authentication')
            else None,
        )

    @classmethod
    def authentication_info(
        cls, info: a2a_pb2.AuthenticationInfo
    ) -> types.PushNotificationAuthenticationInfo:
        return types.PushNotificationAuthenticationInfo(
            schemes=list(info.schemes),
            credentials=info.credentials,
        )

    @classmethod
    def message_send_configuration(
        cls, config: a2a_pb2.SendMessageConfiguration
    ) -> types.MessageSendConfiguration:
        return types.MessageSendConfiguration(
            accepted_output_modes=list(config.accepted_output_modes),
            push_notification_config=FromProto.push_notification_config(
                config.push_notification
            )
            if config.HasField('push_notification')
            else None,
            history_length=config.history_length,
            blocking=config.blocking,
        )

    @classmethod
    def message_send_params(
        cls, request: a2a_pb2.SendMessageRequest
    ) -> types.MessageSendParams:
        return types.MessageSendParams(
            configuration=cls.message_send_configuration(request.configuration),
            message=cls.message(request.request),
            metadata=cls.metadata(request.metadata),
        )

    @classmethod
    def task_id_params(
        cls,
        request: (
            a2a_pb2.CancelTaskRequest
            | a2a_pb2.TaskSubscriptionRequest
            | a2a_pb2.GetTaskPushNotificationConfigRequest
        ),
    ) -> types.TaskIdParams:
        # This is currently incomplete until the core sdk supports multiple
        # configs for a single task.
        if isinstance(request, a2a_pb2.GetTaskPushNotificationConfigRequest):
            m = re.match(_TASK_PUSH_CONFIG_NAME_MATCH, request.name)
            if not m:
                raise ServerError(
                    error=types.InvalidParamsError(
                        message=f'No task for {request.name}'
                    )
                )
            return types.TaskIdParams(id=m.group(1))
        m = re.match(_TASK_NAME_MATCH, request.name)
        if not m:
            raise ServerError(
                error=types.InvalidParamsError(
                    message=f'No task for {request.name}'
                )
            )
        return types.TaskIdParams(id=m.group(1))

    @classmethod
    def task_push_notification_config_request(
        cls,
        request: a2a_pb2.CreateTaskPushNotificationConfigRequest,
    ) -> types.TaskPushNotificationConfig:
        m = re.match(_TASK_NAME_MATCH, request.parent)
        if not m:
            raise ServerError(
                error=types.InvalidParamsError(
                    message=f'No task for {request.parent}'
                )
            )
        return types.TaskPushNotificationConfig(
            push_notification_config=cls.push_notification_config(
                request.config.push_notification_config,
            ),
            task_id=m.group(1),
        )

    @classmethod
    def task_push_notification_config(
        cls,
        config: a2a_pb2.TaskPushNotificationConfig,
    ) -> types.TaskPushNotificationConfig:
        m = re.match(_TASK_PUSH_CONFIG_NAME_MATCH, config.name)
        if not m:
            raise ServerError(
                error=types.InvalidParamsError(
                    message=f'Bad TaskPushNotificationConfig resource name {config.name}'
                )
            )
        return types.TaskPushNotificationConfig(
            push_notification_config=cls.push_notification_config(
                config.push_notification_config,
            ),
            task_id=m.group(1),
        )

    @classmethod
    def agent_card(
        cls,
        card: a2a_pb2.AgentCard,
    ) -> types.AgentCard:
        return types.AgentCard(
            capabilities=cls.capabilities(card.capabilities),
            default_input_modes=list(card.default_input_modes),
            default_output_modes=list(card.default_output_modes),
            description=card.description,
            documentation_url=card.documentation_url,
            name=card.name,
            provider=cls.provider(card.provider),
            security=cls.security(list(card.security)),
            security_schemes=cls.security_schemes(dict(card.security_schemes)),
            skills=[cls.skill(x) for x in card.skills] if card.skills else [],
            url=card.url,
            version=card.version,
            supports_authenticated_extended_card=card.supports_authenticated_extended_card,
            preferred_transport=card.preferred_transport,
            protocol_version=card.protocol_version,
            additional_interfaces=[
                cls.agent_interface(x) for x in card.additional_interfaces
            ]
            if card.additional_interfaces
            else None,
        )

    @classmethod
    def agent_interface(
        cls,
        interface: a2a_pb2.AgentInterface,
    ) -> types.AgentInterface:
        return types.AgentInterface(
            transport=interface.transport,
            url=interface.url,
        )

    @classmethod
    def task_query_params(
        cls,
        request: a2a_pb2.GetTaskRequest,
    ) -> types.TaskQueryParams:
        m = re.match(_TASK_NAME_MATCH, request.name)
        if not m:
            raise ServerError(
                error=types.InvalidParamsError(
                    message=f'No task for {request.name}'
                )
            )
        return types.TaskQueryParams(
            history_length=request.history_length
            if request.history_length
            else None,
            id=m.group(1),
            metadata=None,
        )

    @classmethod
    def capabilities(
        cls, capabilities: a2a_pb2.AgentCapabilities
    ) -> types.AgentCapabilities:
        return types.AgentCapabilities(
            streaming=capabilities.streaming,
            push_notifications=capabilities.push_notifications,
        )

    @classmethod
    def security(
        cls,
        security: list[a2a_pb2.Security] | None,
    ) -> list[dict[str, list[str]]] | None:
        if not security:
            return None
        return [
            {k: list(v.list) for (k, v) in s.schemes.items()} for s in security
        ]

    @classmethod
    def provider(
        cls, provider: a2a_pb2.AgentProvider | None
    ) -> types.AgentProvider | None:
        if not provider:
            return None
        return types.AgentProvider(
            organization=provider.organization,
            url=provider.url,
        )

    @classmethod
    def security_schemes(
        cls, schemes: dict[str, a2a_pb2.SecurityScheme]
    ) -> dict[str, types.SecurityScheme]:
        return {k: cls.security_scheme(v) for (k, v) in schemes.items()}

    @classmethod
    def security_scheme(
        cls,
        scheme: a2a_pb2.SecurityScheme,
    ) -> types.SecurityScheme:
        if scheme.HasField('api_key_security_scheme'):
            return types.SecurityScheme(
                root=types.APIKeySecurityScheme(
                    description=scheme.api_key_security_scheme.description,
                    name=scheme.api_key_security_scheme.name,
                    in_=types.In(scheme.api_key_security_scheme.location),  # type: ignore[call-arg]
                )
            )
        if scheme.HasField('http_auth_security_scheme'):
            return types.SecurityScheme(
                root=types.HTTPAuthSecurityScheme(
                    description=scheme.http_auth_security_scheme.description,
                    scheme=scheme.http_auth_security_scheme.scheme,
                    bearer_format=scheme.http_auth_security_scheme.bearer_format,
                )
            )
        if scheme.HasField('oauth2_security_scheme'):
            return types.SecurityScheme(
                root=types.OAuth2SecurityScheme(
                    description=scheme.oauth2_security_scheme.description,
                    flows=cls.oauth2_flows(scheme.oauth2_security_scheme.flows),
                )
            )
        return types.SecurityScheme(
            root=types.OpenIdConnectSecurityScheme(
                description=scheme.open_id_connect_security_scheme.description,
                open_id_connect_url=scheme.open_id_connect_security_scheme.open_id_connect_url,
            )
        )

    @classmethod
    def oauth2_flows(cls, flows: a2a_pb2.OAuthFlows) -> types.OAuthFlows:
        if flows.HasField('authorization_code'):
            return types.OAuthFlows(
                authorization_code=types.AuthorizationCodeOAuthFlow(
                    authorization_url=flows.authorization_code.authorization_url,
                    refresh_url=flows.authorization_code.refresh_url,
                    scopes=dict(flows.authorization_code.scopes.items()),
                    token_url=flows.authorization_code.token_url,
                ),
            )
        if flows.HasField('client_credentials'):
            return types.OAuthFlows(
                client_credentials=types.ClientCredentialsOAuthFlow(
                    refresh_url=flows.client_credentials.refresh_url,
                    scopes=dict(flows.client_credentials.scopes.items()),
                    token_url=flows.client_credentials.token_url,
                ),
            )
        if flows.HasField('implicit'):
            return types.OAuthFlows(
                implicit=types.ImplicitOAuthFlow(
                    authorization_url=flows.implicit.authorization_url,
                    refresh_url=flows.implicit.refresh_url,
                    scopes=dict(flows.implicit.scopes.items()),
                ),
            )
        return types.OAuthFlows(
            password=types.PasswordOAuthFlow(
                refresh_url=flows.password.refresh_url,
                scopes=dict(flows.password.scopes.items()),
                token_url=flows.password.token_url,
            ),
        )

    @classmethod
    def stream_response(
        cls,
        response: a2a_pb2.StreamResponse,
    ) -> (
        types.Message
        | types.Task
        | types.TaskStatusUpdateEvent
        | types.TaskArtifactUpdateEvent
    ):
        if response.HasField('msg'):
            return cls.message(response.msg)
        if response.HasField('task'):
            return cls.task(response.task)
        if response.HasField('status_update'):
            return cls.task_status_update_event(response.status_update)
        return cls.task_artifact_update_event(response.artifact_update)

    @classmethod
    def skill(cls, skill: a2a_pb2.AgentSkill) -> types.AgentSkill:
        return types.AgentSkill(
            id=skill.id,
            name=skill.name,
            description=skill.description,
            tags=list(skill.tags),
            examples=list(skill.examples),
            input_modes=list(skill.input_modes),
            output_modes=list(skill.output_modes),
        )

    @classmethod
    def role(cls, role: a2a_pb2.Role) -> types.Role:
        match role:
            case a2a_pb2.Role.ROLE_USER:
                return types.Role.user
            case a2a_pb2.Role.ROLE_AGENT:
                return types.Role.agent
            case _:
                return types.Role.agent



---
File: /a2a-python/src/a2a/utils/task.py
---

"""Utility functions for creating A2A Task objects."""

import uuid

from a2a.types import Artifact, Message, Task, TaskState, TaskStatus, TextPart


def new_task(request: Message) -> Task:
    """Creates a new Task object from an initial user message.

    Generates task and context IDs if not provided in the message.

    Args:
        request: The initial `Message` object from the user.

    Returns:
        A new `Task` object initialized with 'submitted' status and the input message in history.

    Raises:
        TypeError: If the message role is None.
        ValueError: If the message parts are empty, if any part has empty content, or if the provided context_id is invalid.
    """
    if not request.role:
        raise TypeError('Message role cannot be None')
    if not request.parts:
        raise ValueError('Message parts cannot be empty')
    for part in request.parts:
        if isinstance(part.root, TextPart) and not part.root.text:
            raise ValueError('TextPart content cannot be empty')

    context_id_str = request.context_id
    if context_id_str is not None:
        try:
            uuid.UUID(context_id_str)
            context_id = context_id_str
        except (ValueError, AttributeError, TypeError) as e:
            raise ValueError(
                f"Invalid context_id: '{context_id_str}' is not a valid UUID."
            ) from e
    else:
        context_id = str(uuid.uuid4())

    return Task(
        status=TaskStatus(state=TaskState.submitted),
        id=(request.task_id if request.task_id else str(uuid.uuid4())),
        context_id=context_id,
        history=[request],
    )


def completed_task(
    task_id: str,
    context_id: str,
    artifacts: list[Artifact],
    history: list[Message] | None = None,
) -> Task:
    """Creates a Task object in the 'completed' state.

    Useful for constructing a final Task representation when the agent
    finishes and produces artifacts.

    Args:
        task_id: The ID of the task.
        context_id: The context ID of the task.
        artifacts: A list of `Artifact` objects produced by the task.
        history: An optional list of `Message` objects representing the task history.

    Returns:
        A `Task` object with status set to 'completed'.
    """
    if not artifacts or not all(isinstance(a, Artifact) for a in artifacts):
        raise ValueError(
            'artifacts must be a non-empty list of Artifact objects'
        )

    if history is None:
        history = []
    return Task(
        status=TaskStatus(state=TaskState.completed),
        id=task_id,
        context_id=context_id,
        artifacts=artifacts,
        history=history,
    )



---
File: /a2a-python/src/a2a/utils/telemetry.py
---

"""OpenTelemetry Tracing Utilities for A2A Python SDK.

This module provides decorators to simplify the integration of OpenTelemetry
tracing into Python applications. It offers `trace_function` for instrumenting
individual functions (both synchronous and asynchronous) and `trace_class`
for instrumenting multiple methods within a class.

The tracer is initialized with the module name and version defined by
`INSTRUMENTING_MODULE_NAME` ('a2a-python-sdk') and
`INSTRUMENTING_MODULE_VERSION` ('1.0.0').

Features:
- Automatic span creation for decorated functions/methods.
- Support for both synchronous and asynchronous functions.
- Default span naming based on module and function/class/method name.
- Customizable span names, kinds, and static attributes.
- Dynamic attribute setting via an `attribute_extractor` callback.
- Automatic recording of exceptions and setting of span status.
- Selective method tracing in classes using include/exclude lists.

Usage:
    For a single function:
    ```python
    from your_module import trace_function


    @trace_function
    def my_function():
        # ...
        pass


    @trace_function(span_name='custom.op', kind=SpanKind.CLIENT)
    async def my_async_function():
        # ...
        pass
    ```

    For a class:
    ```python
    from your_module import trace_class


    @trace_class(exclude_list=['internal_method'])
    class MyService:
        def public_api(self, user_id):
            # This method will be traced
            pass

        def internal_method(self):
            # This method will not be traced
            pass
    ```
"""

import asyncio
import functools
import inspect
import logging

from collections.abc import Callable
from typing import TYPE_CHECKING, Any


if TYPE_CHECKING:
    from opentelemetry.trace import SpanKind as SpanKindType
else:
    SpanKindType = object

logger = logging.getLogger(__name__)

try:
    from opentelemetry import trace
    from opentelemetry.trace import SpanKind as _SpanKind
    from opentelemetry.trace import StatusCode

except ImportError:
    logger.debug(
        'OpenTelemetry not found. Tracing will be disabled. '
        'Install with: \'pip install "a2a-sdk[telemetry]"\''
    )

    class _NoOp:
        """A no-op object that absorbs all tracing calls when OpenTelemetry is not installed."""

        def __call__(self, *args: Any, **kwargs: Any) -> Any:
            return self

        def __enter__(self) -> '_NoOp':
            return self

        def __exit__(self, *args: object, **kwargs: Any) -> None:
            pass

        def __getattr__(self, name: str) -> Any:
            return self

    trace = _NoOp()  # type: ignore
    _SpanKind = _NoOp()  # type: ignore
    StatusCode = _NoOp()  # type: ignore

SpanKind = _SpanKind
__all__ = ['SpanKind']

INSTRUMENTING_MODULE_NAME = 'a2a-python-sdk'
INSTRUMENTING_MODULE_VERSION = '1.0.0'


def trace_function(  # noqa: PLR0915
    func: Callable | None = None,
    *,
    span_name: str | None = None,
    kind: SpanKindType = SpanKind.INTERNAL,
    attributes: dict[str, Any] | None = None,
    attribute_extractor: Callable | None = None,
) -> Callable:
    """A decorator to automatically trace a function call with OpenTelemetry.

    This decorator can be used to wrap both sync and async functions.
    When applied, it creates a new span for each call to the decorated function.
    The span will record the execution time, status (OK or ERROR), and any
    exceptions that occur.

    It can be used in two ways:

    1. As a direct decorator: `@trace_function`
    2. As a decorator factory to provide arguments: `@trace_function(span_name="custom.name")`

    Args:
        func (callable, optional): The function to be decorated. If None,
            the decorator returns a partial function, allowing it to be called
            with arguments. Defaults to None.
        span_name (str, optional): Custom name for the span. If None,
            it defaults to ``f'{func.__module__}.{func.__name__}'``.
            Defaults to None.
        kind (SpanKind, optional): The ``opentelemetry.trace.SpanKind`` for the
            created span. Defaults to ``SpanKind.INTERNAL``.
        attributes (dict, optional): A dictionary of static attributes to be
            set on the span. Keys are attribute names (str) and values are
            the corresponding attribute values. Defaults to None.
        attribute_extractor (callable, optional): A function that can be used
            to dynamically extract and set attributes on the span.
            It is called within a ``finally`` block, ensuring it runs even if
            the decorated function raises an exception.
            The function signature should be:
            ``attribute_extractor(span, args, kwargs, result, exception)``
            where:
                - ``span`` : the OpenTelemetry ``Span`` object.
                - ``args`` : a tuple of positional arguments passed
                - ``kwargs`` : a dictionary of keyword arguments passed
                - ``result`` : return value (None if an exception occurred)
                - ``exception`` : exception object if raised (None otherwise).
            Any exception raised by the ``attribute_extractor`` itself will be
            caught and logged. Defaults to None.

    Returns:
        callable: The wrapped function that includes tracing, or a partial
            decorator if ``func`` is None.
    """
    if func is None:
        return functools.partial(
            trace_function,
            span_name=span_name,
            kind=kind,
            attributes=attributes,
            attribute_extractor=attribute_extractor,
        )

    actual_span_name = span_name or f'{func.__module__}.{func.__name__}'

    is_async_func = inspect.iscoroutinefunction(func)

    logger.debug(
        f'Start tracing for {actual_span_name}, is_async_func {is_async_func}'
    )

    @functools.wraps(func)
    async def async_wrapper(*args, **kwargs) -> Any:
        """Async Wrapper for the decorator."""
        logger.debug('Start async tracer')
        tracer = trace.get_tracer(
            INSTRUMENTING_MODULE_NAME, INSTRUMENTING_MODULE_VERSION
        )
        with tracer.start_as_current_span(actual_span_name, kind=kind) as span:
            if attributes:
                for k, v in attributes.items():
                    span.set_attribute(k, v)

            result = None
            exception = None

            try:
                # Async wrapper, await for the function call to complete.
                result = await func(*args, **kwargs)
                span.set_status(StatusCode.OK)
            # asyncio.CancelledError extends from BaseException
            except asyncio.CancelledError as ce:
                exception = None
                logger.debug(f'CancelledError in span {actual_span_name}')
                span.record_exception(ce)
                raise
            except Exception as e:
                exception = e
                span.record_exception(e)
                span.set_status(StatusCode.ERROR, description=str(e))
                raise
            finally:
                if attribute_extractor:
                    try:
                        attribute_extractor(
                            span, args, kwargs, result, exception
                        )
                    except Exception:
                        logger.exception(
                            f'attribute_extractor error in span {actual_span_name}'
                        )
            return result

    @functools.wraps(func)
    def sync_wrapper(*args, **kwargs) -> Any:
        """Sync Wrapper for the decorator."""
        tracer = trace.get_tracer(INSTRUMENTING_MODULE_NAME)
        with tracer.start_as_current_span(actual_span_name, kind=kind) as span:
            if attributes:
                for k, v in attributes.items():
                    span.set_attribute(k, v)

            result = None
            exception = None

            try:
                # Sync wrapper, execute the function call.
                result = func(*args, **kwargs)
                span.set_status(StatusCode.OK)

            except Exception as e:
                exception = e
                span.record_exception(e)
                span.set_status(StatusCode.ERROR, description=str(e))
                raise
            finally:
                if attribute_extractor:
                    try:
                        attribute_extractor(
                            span, args, kwargs, result, exception
                        )
                    except Exception:
                        logger.exception(
                            f'attribute_extractor error in span {actual_span_name}'
                        )
            return result

    return async_wrapper if is_async_func else sync_wrapper


def trace_class(
    include_list: list[str] | None = None,
    exclude_list: list[str] | None = None,
    kind: SpanKindType = SpanKind.INTERNAL,
) -> Callable:
    """A class decorator to automatically trace specified methods of a class.

    This decorator iterates over the methods of a class and applies the
    `trace_function` decorator to them, based on the `include_list` and
    `exclude_list` criteria. Methods starting or ending with double underscores
    (dunder methods, e.g., `__init__`, `__call__`) are always excluded by default.

    Args:
        include_list (list[str], optional): A list of method names to
            explicitly include for tracing. If provided, only methods in this
            list (that are not dunder methods) will be traced.
            Defaults to None (trace all non-dunder methods).
        exclude_list (list[str], optional): A list of method names to exclude
            from tracing. This is only considered if `include_list` is not
            provided. Dunder methods are implicitly excluded.
            Defaults to an empty list.
        kind (SpanKind, optional): The `opentelemetry.trace.SpanKind` for the
            created spans on the methods. Defaults to `SpanKind.INTERNAL`.

    Returns:
        callable: A decorator function that, when applied to a class,
                  modifies the class to wrap its specified methods with tracing.

    Example:
        To trace all methods except 'internal_method':
        ```python
        @trace_class(exclude_list=['internal_method'])
        class MyService:
            def public_api(self):
                pass

            def internal_method(self):
                pass
        ```

        To trace only 'method_one' and 'method_two':
        ```python
        @trace_class(include_list=['method_one', 'method_two'])
        class AnotherService:
            def method_one(self):
                pass

            def method_two(self):
                pass

            def not_traced_method(self):
                pass
        ```
    """
    logger.debug(f'Trace all class {include_list}, {exclude_list}')
    exclude_list = exclude_list or []

    def decorator(cls: Any) -> Any:
        for name, method in inspect.getmembers(cls, inspect.isfunction):
            if name.startswith('__') and name.endswith('__'):
                continue
            if include_list and name not in include_list:
                continue
            if not include_list and name in exclude_list:
                continue

            span_name = f'{cls.__module__}.{cls.__name__}.{name}'
            setattr(
                cls,
                name,
                trace_function(span_name=span_name, kind=kind)(method),
            )
        return cls

    return decorator



---
File: /a2a-python/src/a2a/__init__.py
---

"""The A2A Python SDK."""



---
File: /a2a-python/src/a2a/_base.py
---

from pydantic import BaseModel, ConfigDict
from pydantic.alias_generators import to_camel


def to_camel_custom(snake: str) -> str:
    """Convert a snake_case string to camelCase.

    Args:
        snake: The string to convert.

    Returns:
        The converted camelCase string.
    """
    # First, remove any trailing underscores. This is common for names that
    # conflict with Python keywords, like 'in_' or 'from_'.
    if snake.endswith('_'):
        snake = snake.rstrip('_')
    return to_camel(snake)


class A2ABaseModel(BaseModel):
    """Base class for shared behavior across A2A data models.

    Provides a common configuration (e.g., alias-based population) and
    serves as the foundation for future extensions or shared utilities.

    This implementation provides backward compatibility for camelCase aliases
    by lazy-loading an alias map upon first use. Accessing or setting
    attributes via their camelCase alias will raise a DeprecationWarning.
    """

    model_config = ConfigDict(
        # SEE: https://docs.pydantic.dev/latest/api/config/#pydantic.config.ConfigDict.populate_by_name
        validate_by_name=True,
        validate_by_alias=True,
        serialize_by_alias=True,
        alias_generator=to_camel_custom,
    )



---
File: /a2a-python/src/a2a/types.py
---

# generated by datamodel-codegen:
#   filename:  https://raw.githubusercontent.com/a2aproject/A2A/refs/heads/main/specification/json/a2a.json

from __future__ import annotations

from enum import Enum
from typing import Any, Literal

from pydantic import Field, RootModel

from a2a._base import A2ABaseModel


class A2A(RootModel[Any]):
    root: Any


class In(str, Enum):
    """
    The location of the API key.
    """

    cookie = 'cookie'
    header = 'header'
    query = 'query'


class APIKeySecurityScheme(A2ABaseModel):
    """
    Defines a security scheme using an API key.
    """

    description: str | None = None
    """
    An optional description for the security scheme.
    """
    in_: In
    """
    The location of the API key.
    """
    name: str
    """
    The name of the header, query, or cookie parameter to be used.
    """
    type: Literal['apiKey'] = 'apiKey'
    """
    The type of the security scheme. Must be 'apiKey'.
    """


class AgentCardSignature(A2ABaseModel):
    """
    AgentCardSignature represents a JWS signature of an AgentCard.
    This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).
    """

    header: dict[str, Any] | None = None
    """
    The unprotected JWS header values.
    """
    protected: str
    """
    The protected JWS header for the signature. This is a Base64url-encoded
    JSON object, as per RFC 7515.
    """
    signature: str
    """
    The computed signature, Base64url-encoded.
    """


class AgentExtension(A2ABaseModel):
    """
    A declaration of a protocol extension supported by an Agent.
    """

    description: str | None = None
    """
    A human-readable description of how this agent uses the extension.
    """
    params: dict[str, Any] | None = None
    """
    Optional, extension-specific configuration parameters.
    """
    required: bool | None = None
    """
    If true, the client must understand and comply with the extension's requirements
    to interact with the agent.
    """
    uri: str
    """
    The unique URI identifying the extension.
    """


class AgentInterface(A2ABaseModel):
    """
    Declares a combination of a target URL and a transport protocol for interacting with the agent.
    This allows agents to expose the same functionality over multiple transport mechanisms.
    """

    transport: str = Field(..., examples=['JSONRPC', 'GRPC', 'HTTP+JSON'])
    """
    The transport protocol supported at this URL.
    """
    url: str = Field(
        ...,
        examples=[
            'https://api.example.com/a2a/v1',
            'https://grpc.example.com/a2a',
            'https://rest.example.com/v1',
        ],
    )
    """
    The URL where this interface is available. Must be a valid absolute HTTPS URL in production.
    """


class AgentProvider(A2ABaseModel):
    """
    Represents the service provider of an agent.
    """

    organization: str
    """
    The name of the agent provider's organization.
    """
    url: str
    """
    A URL for the agent provider's website or relevant documentation.
    """


class AgentSkill(A2ABaseModel):
    """
    Represents a distinct capability or function that an agent can perform.
    """

    description: str
    """
    A detailed description of the skill, intended to help clients or users
    understand its purpose and functionality.
    """
    examples: list[str] | None = Field(
        default=None, examples=[['I need a recipe for bread']]
    )
    """
    Example prompts or scenarios that this skill can handle. Provides a hint to
    the client on how to use the skill.
    """
    id: str
    """
    A unique identifier for the agent's skill.
    """
    input_modes: list[str] | None = None
    """
    The set of supported input MIME types for this skill, overriding the agent's defaults.
    """
    name: str
    """
    A human-readable name for the skill.
    """
    output_modes: list[str] | None = None
    """
    The set of supported output MIME types for this skill, overriding the agent's defaults.
    """
    security: list[dict[str, list[str]]] | None = Field(
        default=None, examples=[[{'google': ['oidc']}]]
    )
    """
    Security schemes necessary for the agent to leverage this skill.
    As in the overall AgentCard.security, this list represents a logical OR of security
    requirement objects. Each object is a set of security schemes that must be used together
    (a logical AND).
    """
    tags: list[str] = Field(
        ..., examples=[['cooking', 'customer support', 'billing']]
    )
    """
    A set of keywords describing the skill's capabilities.
    """


class AuthenticatedExtendedCardNotConfiguredError(A2ABaseModel):
    """
    An A2A-specific error indicating that the agent does not have an Authenticated Extended Card configured
    """

    code: Literal[-32007] = -32007
    """
    The error code for when an authenticated extended card is not configured.
    """
    data: Any | None = None
    """
    A primitive or structured value containing additional information about the error.
    This may be omitted.
    """
    message: str | None = 'Authenticated Extended Card is not configured'
    """
    The error message.
    """


class AuthorizationCodeOAuthFlow(A2ABaseModel):
    """
    Defines configuration details for the OAuth 2.0 Authorization Code flow.
    """

    authorization_url: str
    """
    The authorization URL to be used for this flow.
    This MUST be a URL and use TLS.
    """
    refresh_url: str | None = None
    """
    The URL to be used for obtaining refresh tokens.
    This MUST be a URL and use TLS.
    """
    scopes: dict[str, str]
    """
    The available scopes for the OAuth2 security scheme. A map between the scope
    name and a short description for it.
    """
    token_url: str
    """
    The token URL to be used for this flow.
    This MUST be a URL and use TLS.
    """


class ClientCredentialsOAuthFlow(A2ABaseModel):
    """
    Defines configuration details for the OAuth 2.0 Client Credentials flow.
    """

    refresh_url: str | None = None
    """
    The URL to be used for obtaining refresh tokens. This MUST be a URL.
    """
    scopes: dict[str, str]
    """
    The available scopes for the OAuth2 security scheme. A map between the scope
    name and a short description for it.
    """
    token_url: str
    """
    The token URL to be used for this flow. This MUST be a URL.
    """


class ContentTypeNotSupportedError(A2ABaseModel):
    """
    An A2A-specific error indicating an incompatibility between the requested
    content types and the agent's capabilities.
    """

    code: Literal[-32005] = -32005
    """
    The error code for an unsupported content type.
    """
    data: Any | None = None
    """
    A primitive or structured value containing additional information about the error.
    This may be omitted.
    """
    message: str | None = 'Incompatible content types'
    """
    The error message.
    """


class DataPart(A2ABaseModel):
    """
    Represents a structured data segment (e.g., JSON) within a message or artifact.
    """

    data: dict[str, Any]
    """
    The structured data content.
    """
    kind: Literal['data'] = 'data'
    """
    The type of this part, used as a discriminator. Always 'data'.
    """
    metadata: dict[str, Any] | None = None
    """
    Optional metadata associated with this part.
    """


class DeleteTaskPushNotificationConfigParams(A2ABaseModel):
    """
    Defines parameters for deleting a specific push notification configuration for a task.
    """

    id: str
    """
    The unique identifier of the task.
    """
    metadata: dict[str, Any] | None = None
    """
    Optional metadata associated with the request.
    """
    push_notification_config_id: str
    """
    The ID of the push notification configuration to delete.
    """


class DeleteTaskPushNotificationConfigRequest(A2ABaseModel):
    """
    Represents a JSON-RPC request for the `tasks/pushNotificationConfig/delete` method.
    """

    id: str | int
    """
    The identifier for this request.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    method: Literal['tasks/pushNotificationConfig/delete'] = (
        'tasks/pushNotificationConfig/delete'
    )
    """
    The method name. Must be 'tasks/pushNotificationConfig/delete'.
    """
    params: DeleteTaskPushNotificationConfigParams
    """
    The parameters identifying the push notification configuration to delete.
    """


class DeleteTaskPushNotificationConfigSuccessResponse(A2ABaseModel):
    """
    Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/delete` method.
    """

    id: str | int | None = None
    """
    The identifier established by the client.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    result: None
    """
    The result is null on successful deletion.
    """


class FileBase(A2ABaseModel):
    """
    Defines base properties for a file.
    """

    mime_type: str | None = None
    """
    The MIME type of the file (e.g., "application/pdf").
    """
    name: str | None = None
    """
    An optional name for the file (e.g., "document.pdf").
    """


class FileWithBytes(A2ABaseModel):
    """
    Represents a file with its content provided directly as a base64-encoded string.
    """

    bytes: str
    """
    The base64-encoded content of the file.
    """
    mime_type: str | None = None
    """
    The MIME type of the file (e.g., "application/pdf").
    """
    name: str | None = None
    """
    An optional name for the file (e.g., "document.pdf").
    """


class FileWithUri(A2ABaseModel):
    """
    Represents a file with its content located at a specific URI.
    """

    mime_type: str | None = None
    """
    The MIME type of the file (e.g., "application/pdf").
    """
    name: str | None = None
    """
    An optional name for the file (e.g., "document.pdf").
    """
    uri: str
    """
    A URL pointing to the file's content.
    """


class GetAuthenticatedExtendedCardRequest(A2ABaseModel):
    """
    Represents a JSON-RPC request for the `agent/getAuthenticatedExtendedCard` method.
    """

    id: str | int
    """
    The identifier for this request.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    method: Literal['agent/getAuthenticatedExtendedCard'] = (
        'agent/getAuthenticatedExtendedCard'
    )
    """
    The method name. Must be 'agent/getAuthenticatedExtendedCard'.
    """


class GetTaskPushNotificationConfigParams(A2ABaseModel):
    """
    Defines parameters for fetching a specific push notification configuration for a task.
    """

    id: str
    """
    The unique identifier of the task.
    """
    metadata: dict[str, Any] | None = None
    """
    Optional metadata associated with the request.
    """
    push_notification_config_id: str | None = None
    """
    The ID of the push notification configuration to retrieve.
    """


class HTTPAuthSecurityScheme(A2ABaseModel):
    """
    Defines a security scheme using HTTP authentication.
    """

    bearer_format: str | None = None
    """
    A hint to the client to identify how the bearer token is formatted (e.g., "JWT").
    This is primarily for documentation purposes.
    """
    description: str | None = None
    """
    An optional description for the security scheme.
    """
    scheme: str
    """
    The name of the HTTP Authentication scheme to be used in the Authorization header,
    as defined in RFC7235 (e.g., "Bearer").
    This value should be registered in the IANA Authentication Scheme registry.
    """
    type: Literal['http'] = 'http'
    """
    The type of the security scheme. Must be 'http'.
    """


class ImplicitOAuthFlow(A2ABaseModel):
    """
    Defines configuration details for the OAuth 2.0 Implicit flow.
    """

    authorization_url: str
    """
    The authorization URL to be used for this flow. This MUST be a URL.
    """
    refresh_url: str | None = None
    """
    The URL to be used for obtaining refresh tokens. This MUST be a URL.
    """
    scopes: dict[str, str]
    """
    The available scopes for the OAuth2 security scheme. A map between the scope
    name and a short description for it.
    """


class InternalError(A2ABaseModel):
    """
    An error indicating an internal error on the server.
    """

    code: Literal[-32603] = -32603
    """
    The error code for an internal server error.
    """
    data: Any | None = None
    """
    A primitive or structured value containing additional information about the error.
    This may be omitted.
    """
    message: str | None = 'Internal error'
    """
    The error message.
    """


class InvalidAgentResponseError(A2ABaseModel):
    """
    An A2A-specific error indicating that the agent returned a response that
    does not conform to the specification for the current method.
    """

    code: Literal[-32006] = -32006
    """
    The error code for an invalid agent response.
    """
    data: Any | None = None
    """
    A primitive or structured value containing additional information about the error.
    This may be omitted.
    """
    message: str | None = 'Invalid agent response'
    """
    The error message.
    """


class InvalidParamsError(A2ABaseModel):
    """
    An error indicating that the method parameters are invalid.
    """

    code: Literal[-32602] = -32602
    """
    The error code for an invalid parameters error.
    """
    data: Any | None = None
    """
    A primitive or structured value containing additional information about the error.
    This may be omitted.
    """
    message: str | None = 'Invalid parameters'
    """
    The error message.
    """


class InvalidRequestError(A2ABaseModel):
    """
    An error indicating that the JSON sent is not a valid Request object.
    """

    code: Literal[-32600] = -32600
    """
    The error code for an invalid request.
    """
    data: Any | None = None
    """
    A primitive or structured value containing additional information about the error.
    This may be omitted.
    """
    message: str | None = 'Request payload validation error'
    """
    The error message.
    """


class JSONParseError(A2ABaseModel):
    """
    An error indicating that the server received invalid JSON.
    """

    code: Literal[-32700] = -32700
    """
    The error code for a JSON parse error.
    """
    data: Any | None = None
    """
    A primitive or structured value containing additional information about the error.
    This may be omitted.
    """
    message: str | None = 'Invalid JSON payload'
    """
    The error message.
    """


class JSONRPCError(A2ABaseModel):
    """
    Represents a JSON-RPC 2.0 Error object, included in an error response.
    """

    code: int
    """
    A number that indicates the error type that occurred.
    """
    data: Any | None = None
    """
    A primitive or structured value containing additional information about the error.
    This may be omitted.
    """
    message: str
    """
    A string providing a short description of the error.
    """


class JSONRPCMessage(A2ABaseModel):
    """
    Defines the base structure for any JSON-RPC 2.0 request, response, or notification.
    """

    id: str | int | None = None
    """
    A unique identifier established by the client. It must be a String, a Number, or null.
    The server must reply with the same value in the response. This property is omitted for notifications.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """


class JSONRPCRequest(A2ABaseModel):
    """
    Represents a JSON-RPC 2.0 Request object.
    """

    id: str | int | None = None
    """
    A unique identifier established by the client. It must be a String, a Number, or null.
    The server must reply with the same value in the response. This property is omitted for notifications.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    method: str
    """
    A string containing the name of the method to be invoked.
    """
    params: dict[str, Any] | None = None
    """
    A structured value holding the parameter values to be used during the method invocation.
    """


class JSONRPCSuccessResponse(A2ABaseModel):
    """
    Represents a successful JSON-RPC 2.0 Response object.
    """

    id: str | int | None = None
    """
    The identifier established by the client.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    result: Any
    """
    The value of this member is determined by the method invoked on the Server.
    """


class ListTaskPushNotificationConfigParams(A2ABaseModel):
    """
    Defines parameters for listing all push notification configurations associated with a task.
    """

    id: str
    """
    The unique identifier of the task.
    """
    metadata: dict[str, Any] | None = None
    """
    Optional metadata associated with the request.
    """


class ListTaskPushNotificationConfigRequest(A2ABaseModel):
    """
    Represents a JSON-RPC request for the `tasks/pushNotificationConfig/list` method.
    """

    id: str | int
    """
    The identifier for this request.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    method: Literal['tasks/pushNotificationConfig/list'] = (
        'tasks/pushNotificationConfig/list'
    )
    """
    The method name. Must be 'tasks/pushNotificationConfig/list'.
    """
    params: ListTaskPushNotificationConfigParams
    """
    The parameters identifying the task whose configurations are to be listed.
    """


class Role(str, Enum):
    """
    Identifies the sender of the message. `user` for the client, `agent` for the service.
    """

    agent = 'agent'
    user = 'user'


class MethodNotFoundError(A2ABaseModel):
    """
    An error indicating that the requested method does not exist or is not available.
    """

    code: Literal[-32601] = -32601
    """
    The error code for a method not found error.
    """
    data: Any | None = None
    """
    A primitive or structured value containing additional information about the error.
    This may be omitted.
    """
    message: str | None = 'Method not found'
    """
    The error message.
    """


class MutualTLSSecurityScheme(A2ABaseModel):
    """
    Defines a security scheme using mTLS authentication.
    """

    description: str | None = None
    """
    An optional description for the security scheme.
    """
    type: Literal['mutualTLS'] = 'mutualTLS'
    """
    The type of the security scheme. Must be 'mutualTLS'.
    """


class OpenIdConnectSecurityScheme(A2ABaseModel):
    """
    Defines a security scheme using OpenID Connect.
    """

    description: str | None = None
    """
    An optional description for the security scheme.
    """
    open_id_connect_url: str
    """
    The OpenID Connect Discovery URL for the OIDC provider's metadata.
    """
    type: Literal['openIdConnect'] = 'openIdConnect'
    """
    The type of the security scheme. Must be 'openIdConnect'.
    """


class PartBase(A2ABaseModel):
    """
    Defines base properties common to all message or artifact parts.
    """

    metadata: dict[str, Any] | None = None
    """
    Optional metadata associated with this part.
    """


class PasswordOAuthFlow(A2ABaseModel):
    """
    Defines configuration details for the OAuth 2.0 Resource Owner Password flow.
    """

    refresh_url: str | None = None
    """
    The URL to be used for obtaining refresh tokens. This MUST be a URL.
    """
    scopes: dict[str, str]
    """
    The available scopes for the OAuth2 security scheme. A map between the scope
    name and a short description for it.
    """
    token_url: str
    """
    The token URL to be used for this flow. This MUST be a URL.
    """


class PushNotificationAuthenticationInfo(A2ABaseModel):
    """
    Defines authentication details for a push notification endpoint.
    """

    credentials: str | None = None
    """
    Optional credentials required by the push notification endpoint.
    """
    schemes: list[str]
    """
    A list of supported authentication schemes (e.g., 'Basic', 'Bearer').
    """


class PushNotificationConfig(A2ABaseModel):
    """
    Defines the configuration for setting up push notifications for task updates.
    """

    authentication: PushNotificationAuthenticationInfo | None = None
    """
    Optional authentication details for the agent to use when calling the notification URL.
    """
    id: str | None = None
    """
    A unique ID for the push notification configuration, set by the client
    to support multiple notification callbacks.
    """
    token: str | None = None
    """
    A unique token for this task or session to validate incoming push notifications.
    """
    url: str
    """
    The callback URL where the agent should send push notifications.
    """


class PushNotificationNotSupportedError(A2ABaseModel):
    """
    An A2A-specific error indicating that the agent does not support push notifications.
    """

    code: Literal[-32003] = -32003
    """
    The error code for when push notifications are not supported.
    """
    data: Any | None = None
    """
    A primitive or structured value containing additional information about the error.
    This may be omitted.
    """
    message: str | None = 'Push Notification is not supported'
    """
    The error message.
    """


class SecuritySchemeBase(A2ABaseModel):
    """
    Defines base properties shared by all security scheme objects.
    """

    description: str | None = None
    """
    An optional description for the security scheme.
    """


class TaskIdParams(A2ABaseModel):
    """
    Defines parameters containing a task ID, used for simple task operations.
    """

    id: str
    """
    The unique identifier of the task.
    """
    metadata: dict[str, Any] | None = None
    """
    Optional metadata associated with the request.
    """


class TaskNotCancelableError(A2ABaseModel):
    """
    An A2A-specific error indicating that the task is in a state where it cannot be canceled.
    """

    code: Literal[-32002] = -32002
    """
    The error code for a task that cannot be canceled.
    """
    data: Any | None = None
    """
    A primitive or structured value containing additional information about the error.
    This may be omitted.
    """
    message: str | None = 'Task cannot be canceled'
    """
    The error message.
    """


class TaskNotFoundError(A2ABaseModel):
    """
    An A2A-specific error indicating that the requested task ID was not found.
    """

    code: Literal[-32001] = -32001
    """
    The error code for a task not found error.
    """
    data: Any | None = None
    """
    A primitive or structured value containing additional information about the error.
    This may be omitted.
    """
    message: str | None = 'Task not found'
    """
    The error message.
    """


class TaskPushNotificationConfig(A2ABaseModel):
    """
    A container associating a push notification configuration with a specific task.
    """

    push_notification_config: PushNotificationConfig
    """
    The push notification configuration for this task.
    """
    task_id: str
    """
    The ID of the task.
    """


class TaskQueryParams(A2ABaseModel):
    """
    Defines parameters for querying a task, with an option to limit history length.
    """

    history_length: int | None = None
    """
    The number of most recent messages from the task's history to retrieve.
    """
    id: str
    """
    The unique identifier of the task.
    """
    metadata: dict[str, Any] | None = None
    """
    Optional metadata associated with the request.
    """


class TaskResubscriptionRequest(A2ABaseModel):
    """
    Represents a JSON-RPC request for the `tasks/resubscribe` method, used to resume a streaming connection.
    """

    id: str | int
    """
    The identifier for this request.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    method: Literal['tasks/resubscribe'] = 'tasks/resubscribe'
    """
    The method name. Must be 'tasks/resubscribe'.
    """
    params: TaskIdParams
    """
    The parameters identifying the task to resubscribe to.
    """


class TaskState(str, Enum):
    """
    Defines the lifecycle states of a Task.
    """

    submitted = 'submitted'
    working = 'working'
    input_required = 'input-required'
    completed = 'completed'
    canceled = 'canceled'
    failed = 'failed'
    rejected = 'rejected'
    auth_required = 'auth-required'
    unknown = 'unknown'


class TextPart(A2ABaseModel):
    """
    Represents a text segment within a message or artifact.
    """

    kind: Literal['text'] = 'text'
    """
    The type of this part, used as a discriminator. Always 'text'.
    """
    metadata: dict[str, Any] | None = None
    """
    Optional metadata associated with this part.
    """
    text: str
    """
    The string content of the text part.
    """


class TransportProtocol(str, Enum):
    """
    Supported A2A transport protocols.
    """

    jsonrpc = 'JSONRPC'
    grpc = 'GRPC'
    http_json = 'HTTP+JSON'


class UnsupportedOperationError(A2ABaseModel):
    """
    An A2A-specific error indicating that the requested operation is not supported by the agent.
    """

    code: Literal[-32004] = -32004
    """
    The error code for an unsupported operation.
    """
    data: Any | None = None
    """
    A primitive or structured value containing additional information about the error.
    This may be omitted.
    """
    message: str | None = 'This operation is not supported'
    """
    The error message.
    """


class A2AError(
    RootModel[
        JSONParseError
        | InvalidRequestError
        | MethodNotFoundError
        | InvalidParamsError
        | InternalError
        | TaskNotFoundError
        | TaskNotCancelableError
        | PushNotificationNotSupportedError
        | UnsupportedOperationError
        | ContentTypeNotSupportedError
        | InvalidAgentResponseError
        | AuthenticatedExtendedCardNotConfiguredError
    ]
):
    root: (
        JSONParseError
        | InvalidRequestError
        | MethodNotFoundError
        | InvalidParamsError
        | InternalError
        | TaskNotFoundError
        | TaskNotCancelableError
        | PushNotificationNotSupportedError
        | UnsupportedOperationError
        | ContentTypeNotSupportedError
        | InvalidAgentResponseError
        | AuthenticatedExtendedCardNotConfiguredError
    )
    """
    A discriminated union of all standard JSON-RPC and A2A-specific error types.
    """


class AgentCapabilities(A2ABaseModel):
    """
    Defines optional capabilities supported by an agent.
    """

    extensions: list[AgentExtension] | None = None
    """
    A list of protocol extensions supported by the agent.
    """
    push_notifications: bool | None = None
    """
    Indicates if the agent supports sending push notifications for asynchronous task updates.
    """
    state_transition_history: bool | None = None
    """
    Indicates if the agent provides a history of state transitions for a task.
    """
    streaming: bool | None = None
    """
    Indicates if the agent supports Server-Sent Events (SSE) for streaming responses.
    """


class CancelTaskRequest(A2ABaseModel):
    """
    Represents a JSON-RPC request for the `tasks/cancel` method.
    """

    id: str | int
    """
    The identifier for this request.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    method: Literal['tasks/cancel'] = 'tasks/cancel'
    """
    The method name. Must be 'tasks/cancel'.
    """
    params: TaskIdParams
    """
    The parameters identifying the task to cancel.
    """


class FilePart(A2ABaseModel):
    """
    Represents a file segment within a message or artifact. The file content can be
    provided either directly as bytes or as a URI.
    """

    file: FileWithBytes | FileWithUri
    """
    The file content, represented as either a URI or as base64-encoded bytes.
    """
    kind: Literal['file'] = 'file'
    """
    The type of this part, used as a discriminator. Always 'file'.
    """
    metadata: dict[str, Any] | None = None
    """
    Optional metadata associated with this part.
    """


class GetTaskPushNotificationConfigRequest(A2ABaseModel):
    """
    Represents a JSON-RPC request for the `tasks/pushNotificationConfig/get` method.
    """

    id: str | int
    """
    The identifier for this request.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    method: Literal['tasks/pushNotificationConfig/get'] = (
        'tasks/pushNotificationConfig/get'
    )
    """
    The method name. Must be 'tasks/pushNotificationConfig/get'.
    """
    params: TaskIdParams | GetTaskPushNotificationConfigParams
    """
    The parameters for getting a push notification configuration.
    """


class GetTaskPushNotificationConfigSuccessResponse(A2ABaseModel):
    """
    Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/get` method.
    """

    id: str | int | None = None
    """
    The identifier established by the client.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    result: TaskPushNotificationConfig
    """
    The result, containing the requested push notification configuration.
    """


class GetTaskRequest(A2ABaseModel):
    """
    Represents a JSON-RPC request for the `tasks/get` method.
    """

    id: str | int
    """
    The identifier for this request.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    method: Literal['tasks/get'] = 'tasks/get'
    """
    The method name. Must be 'tasks/get'.
    """
    params: TaskQueryParams
    """
    The parameters for querying a task.
    """


class JSONRPCErrorResponse(A2ABaseModel):
    """
    Represents a JSON-RPC 2.0 Error Response object.
    """

    error: (
        JSONRPCError
        | JSONParseError
        | InvalidRequestError
        | MethodNotFoundError
        | InvalidParamsError
        | InternalError
        | TaskNotFoundError
        | TaskNotCancelableError
        | PushNotificationNotSupportedError
        | UnsupportedOperationError
        | ContentTypeNotSupportedError
        | InvalidAgentResponseError
        | AuthenticatedExtendedCardNotConfiguredError
    )
    """
    An object describing the error that occurred.
    """
    id: str | int | None = None
    """
    The identifier established by the client.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """


class ListTaskPushNotificationConfigSuccessResponse(A2ABaseModel):
    """
    Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/list` method.
    """

    id: str | int | None = None
    """
    The identifier established by the client.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    result: list[TaskPushNotificationConfig]
    """
    The result, containing an array of all push notification configurations for the task.
    """


class MessageSendConfiguration(A2ABaseModel):
    """
    Defines configuration options for a `message/send` or `message/stream` request.
    """

    accepted_output_modes: list[str] | None = None
    """
    A list of output MIME types the client is prepared to accept in the response.
    """
    blocking: bool | None = None
    """
    If true, the client will wait for the task to complete. The server may reject this if the task is long-running.
    """
    history_length: int | None = None
    """
    The number of most recent messages from the task's history to retrieve in the response.
    """
    push_notification_config: PushNotificationConfig | None = None
    """
    Configuration for the agent to send push notifications for updates after the initial response.
    """


class OAuthFlows(A2ABaseModel):
    """
    Defines the configuration for the supported OAuth 2.0 flows.
    """

    authorization_code: AuthorizationCodeOAuthFlow | None = None
    """
    Configuration for the OAuth Authorization Code flow. Previously called accessCode in OpenAPI 2.0.
    """
    client_credentials: ClientCredentialsOAuthFlow | None = None
    """
    Configuration for the OAuth Client Credentials flow. Previously called application in OpenAPI 2.0.
    """
    implicit: ImplicitOAuthFlow | None = None
    """
    Configuration for the OAuth Implicit flow.
    """
    password: PasswordOAuthFlow | None = None
    """
    Configuration for the OAuth Resource Owner Password flow.
    """


class Part(RootModel[TextPart | FilePart | DataPart]):
    root: TextPart | FilePart | DataPart
    """
    A discriminated union representing a part of a message or artifact, which can
    be text, a file, or structured data.
    """


class SetTaskPushNotificationConfigRequest(A2ABaseModel):
    """
    Represents a JSON-RPC request for the `tasks/pushNotificationConfig/set` method.
    """

    id: str | int
    """
    The identifier for this request.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    method: Literal['tasks/pushNotificationConfig/set'] = (
        'tasks/pushNotificationConfig/set'
    )
    """
    The method name. Must be 'tasks/pushNotificationConfig/set'.
    """
    params: TaskPushNotificationConfig
    """
    The parameters for setting the push notification configuration.
    """


class SetTaskPushNotificationConfigSuccessResponse(A2ABaseModel):
    """
    Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/set` method.
    """

    id: str | int | None = None
    """
    The identifier established by the client.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    result: TaskPushNotificationConfig
    """
    The result, containing the configured push notification settings.
    """


class Artifact(A2ABaseModel):
    """
    Represents a file, data structure, or other resource generated by an agent during a task.
    """

    artifact_id: str
    """
    A unique identifier for the artifact within the scope of the task.
    """
    description: str | None = None
    """
    An optional, human-readable description of the artifact.
    """
    extensions: list[str] | None = None
    """
    The URIs of extensions that are relevant to this artifact.
    """
    metadata: dict[str, Any] | None = None
    """
    Optional metadata for extensions. The key is an extension-specific identifier.
    """
    name: str | None = None
    """
    An optional, human-readable name for the artifact.
    """
    parts: list[Part]
    """
    An array of content parts that make up the artifact.
    """


class DeleteTaskPushNotificationConfigResponse(
    RootModel[
        JSONRPCErrorResponse | DeleteTaskPushNotificationConfigSuccessResponse
    ]
):
    root: JSONRPCErrorResponse | DeleteTaskPushNotificationConfigSuccessResponse
    """
    Represents a JSON-RPC response for the `tasks/pushNotificationConfig/delete` method.
    """


class GetTaskPushNotificationConfigResponse(
    RootModel[
        JSONRPCErrorResponse | GetTaskPushNotificationConfigSuccessResponse
    ]
):
    root: JSONRPCErrorResponse | GetTaskPushNotificationConfigSuccessResponse
    """
    Represents a JSON-RPC response for the `tasks/pushNotificationConfig/get` method.
    """


class ListTaskPushNotificationConfigResponse(
    RootModel[
        JSONRPCErrorResponse | ListTaskPushNotificationConfigSuccessResponse
    ]
):
    root: JSONRPCErrorResponse | ListTaskPushNotificationConfigSuccessResponse
    """
    Represents a JSON-RPC response for the `tasks/pushNotificationConfig/list` method.
    """


class Message(A2ABaseModel):
    """
    Represents a single message in the conversation between a user and an agent.
    """

    context_id: str | None = None
    """
    The context identifier for this message, used to group related interactions.
    """
    extensions: list[str] | None = None
    """
    The URIs of extensions that are relevant to this message.
    """
    kind: Literal['message'] = 'message'
    """
    The type of this object, used as a discriminator. Always 'message' for a Message.
    """
    message_id: str
    """
    A unique identifier for the message, typically a UUID, generated by the sender.
    """
    metadata: dict[str, Any] | None = None
    """
    Optional metadata for extensions. The key is an extension-specific identifier.
    """
    parts: list[Part]
    """
    An array of content parts that form the message body. A message can be
    composed of multiple parts of different types (e.g., text and files).
    """
    reference_task_ids: list[str] | None = None
    """
    A list of other task IDs that this message references for additional context.
    """
    role: Role
    """
    Identifies the sender of the message. `user` for the client, `agent` for the service.
    """
    task_id: str | None = None
    """
    The identifier of the task this message is part of. Can be omitted for the first message of a new task.
    """


class MessageSendParams(A2ABaseModel):
    """
    Defines the parameters for a request to send a message to an agent. This can be used
    to create a new task, continue an existing one, or restart a task.
    """

    configuration: MessageSendConfiguration | None = None
    """
    Optional configuration for the send request.
    """
    message: Message
    """
    The message object being sent to the agent.
    """
    metadata: dict[str, Any] | None = None
    """
    Optional metadata for extensions.
    """


class OAuth2SecurityScheme(A2ABaseModel):
    """
    Defines a security scheme using OAuth 2.0.
    """

    description: str | None = None
    """
    An optional description for the security scheme.
    """
    flows: OAuthFlows
    """
    An object containing configuration information for the supported OAuth 2.0 flows.
    """
    oauth2_metadata_url: str | None = None
    """
    URL to the oauth2 authorization server metadata
    [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414). TLS is required.
    """
    type: Literal['oauth2'] = 'oauth2'
    """
    The type of the security scheme. Must be 'oauth2'.
    """


class SecurityScheme(
    RootModel[
        APIKeySecurityScheme
        | HTTPAuthSecurityScheme
        | OAuth2SecurityScheme
        | OpenIdConnectSecurityScheme
        | MutualTLSSecurityScheme
    ]
):
    root: (
        APIKeySecurityScheme
        | HTTPAuthSecurityScheme
        | OAuth2SecurityScheme
        | OpenIdConnectSecurityScheme
        | MutualTLSSecurityScheme
    )
    """
    Defines a security scheme that can be used to secure an agent's endpoints.
    This is a discriminated union type based on the OpenAPI 3.0 Security Scheme Object.
    """


class SendMessageRequest(A2ABaseModel):
    """
    Represents a JSON-RPC request for the `message/send` method.
    """

    id: str | int
    """
    The identifier for this request.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    method: Literal['message/send'] = 'message/send'
    """
    The method name. Must be 'message/send'.
    """
    params: MessageSendParams
    """
    The parameters for sending a message.
    """


class SendStreamingMessageRequest(A2ABaseModel):
    """
    Represents a JSON-RPC request for the `message/stream` method.
    """

    id: str | int
    """
    The identifier for this request.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    method: Literal['message/stream'] = 'message/stream'
    """
    The method name. Must be 'message/stream'.
    """
    params: MessageSendParams
    """
    The parameters for sending a message.
    """


class SetTaskPushNotificationConfigResponse(
    RootModel[
        JSONRPCErrorResponse | SetTaskPushNotificationConfigSuccessResponse
    ]
):
    root: JSONRPCErrorResponse | SetTaskPushNotificationConfigSuccessResponse
    """
    Represents a JSON-RPC response for the `tasks/pushNotificationConfig/set` method.
    """


class TaskArtifactUpdateEvent(A2ABaseModel):
    """
    An event sent by the agent to notify the client that an artifact has been
    generated or updated. This is typically used in streaming models.
    """

    append: bool | None = None
    """
    If true, the content of this artifact should be appended to a previously sent artifact with the same ID.
    """
    artifact: Artifact
    """
    The artifact that was generated or updated.
    """
    context_id: str
    """
    The context ID associated with the task.
    """
    kind: Literal['artifact-update'] = 'artifact-update'
    """
    The type of this event, used as a discriminator. Always 'artifact-update'.
    """
    last_chunk: bool | None = None
    """
    If true, this is the final chunk of the artifact.
    """
    metadata: dict[str, Any] | None = None
    """
    Optional metadata for extensions.
    """
    task_id: str
    """
    The ID of the task this artifact belongs to.
    """


class TaskStatus(A2ABaseModel):
    """
    Represents the status of a task at a specific point in time.
    """

    message: Message | None = None
    """
    An optional, human-readable message providing more details about the current status.
    """
    state: TaskState
    """
    The current state of the task's lifecycle.
    """
    timestamp: str | None = Field(
        default=None, examples=['2023-10-27T10:00:00Z']
    )
    """
    An ISO 8601 datetime string indicating when this status was recorded.
    """


class TaskStatusUpdateEvent(A2ABaseModel):
    """
    An event sent by the agent to notify the client of a change in a task's status.
    This is typically used in streaming or subscription models.
    """

    context_id: str
    """
    The context ID associated with the task.
    """
    final: bool
    """
    If true, this is the final event in the stream for this interaction.
    """
    kind: Literal['status-update'] = 'status-update'
    """
    The type of this event, used as a discriminator. Always 'status-update'.
    """
    metadata: dict[str, Any] | None = None
    """
    Optional metadata for extensions.
    """
    status: TaskStatus
    """
    The new status of the task.
    """
    task_id: str
    """
    The ID of the task that was updated.
    """


class A2ARequest(
    RootModel[
        SendMessageRequest
        | SendStreamingMessageRequest
        | GetTaskRequest
        | CancelTaskRequest
        | SetTaskPushNotificationConfigRequest
        | GetTaskPushNotificationConfigRequest
        | TaskResubscriptionRequest
        | ListTaskPushNotificationConfigRequest
        | DeleteTaskPushNotificationConfigRequest
        | GetAuthenticatedExtendedCardRequest
    ]
):
    root: (
        SendMessageRequest
        | SendStreamingMessageRequest
        | GetTaskRequest
        | CancelTaskRequest
        | SetTaskPushNotificationConfigRequest
        | GetTaskPushNotificationConfigRequest
        | TaskResubscriptionRequest
        | ListTaskPushNotificationConfigRequest
        | DeleteTaskPushNotificationConfigRequest
        | GetAuthenticatedExtendedCardRequest
    )
    """
    A discriminated union representing all possible JSON-RPC 2.0 requests supported by the A2A specification.
    """


class AgentCard(A2ABaseModel):
    """
    The AgentCard is a self-describing manifest for an agent. It provides essential
    metadata including the agent's identity, capabilities, skills, supported
    communication methods, and security requirements.
    """

    additional_interfaces: list[AgentInterface] | None = None
    """
    A list of additional supported interfaces (transport and URL combinations).
    This allows agents to expose multiple transports, potentially at different URLs.

    Best practices:
    - SHOULD include all supported transports for completeness
    - SHOULD include an entry matching the main 'url' and 'preferredTransport'
    - MAY reuse URLs if multiple transports are available at the same endpoint
    - MUST accurately declare the transport available at each URL

    Clients can select any interface from this list based on their transport capabilities
    and preferences. This enables transport negotiation and fallback scenarios.
    """
    capabilities: AgentCapabilities
    """
    A declaration of optional capabilities supported by the agent.
    """
    default_input_modes: list[str]
    """
    Default set of supported input MIME types for all skills, which can be
    overridden on a per-skill basis.
    """
    default_output_modes: list[str]
    """
    Default set of supported output MIME types for all skills, which can be
    overridden on a per-skill basis.
    """
    description: str = Field(
        ..., examples=['Agent that helps users with recipes and cooking.']
    )
    """
    A human-readable description of the agent, assisting users and other agents
    in understanding its purpose.
    """
    documentation_url: str | None = None
    """
    An optional URL to the agent's documentation.
    """
    icon_url: str | None = None
    """
    An optional URL to an icon for the agent.
    """
    name: str = Field(..., examples=['Recipe Agent'])
    """
    A human-readable name for the agent.
    """
    preferred_transport: str | None = Field(
        default='JSONRPC', examples=['JSONRPC', 'GRPC', 'HTTP+JSON']
    )
    """
    The transport protocol for the preferred endpoint (the main 'url' field).
    If not specified, defaults to 'JSONRPC'.

    IMPORTANT: The transport specified here MUST be available at the main 'url'.
    This creates a binding between the main URL and its supported transport protocol.
    Clients should prefer this transport and URL combination when both are supported.
    """
    protocol_version: str | None = '0.3.0'
    """
    The version of the A2A protocol this agent supports.
    """
    provider: AgentProvider | None = None
    """
    Information about the agent's service provider.
    """
    security: list[dict[str, list[str]]] | None = Field(
        default=None,
        examples=[[{'oauth': ['read']}, {'api-key': [], 'mtls': []}]],
    )
    """
    A list of security requirement objects that apply to all agent interactions. Each object
    lists security schemes that can be used. Follows the OpenAPI 3.0 Security Requirement Object.
    This list can be seen as an OR of ANDs. Each object in the list describes one possible
    set of security requirements that must be present on a request. This allows specifying,
    for example, "callers must either use OAuth OR an API Key AND mTLS."
    """
    security_schemes: dict[str, SecurityScheme] | None = None
    """
    A declaration of the security schemes available to authorize requests. The key is the
    scheme name. Follows the OpenAPI 3.0 Security Scheme Object.
    """
    signatures: list[AgentCardSignature] | None = None
    """
    JSON Web Signatures computed for this AgentCard.
    """
    skills: list[AgentSkill]
    """
    The set of skills, or distinct capabilities, that the agent can perform.
    """
    supports_authenticated_extended_card: bool | None = None
    """
    If true, the agent can provide an extended agent card with additional details
    to authenticated users. Defaults to false.
    """
    url: str = Field(..., examples=['https://api.example.com/a2a/v1'])
    """
    The preferred endpoint URL for interacting with the agent.
    This URL MUST support the transport specified by 'preferredTransport'.
    """
    version: str = Field(..., examples=['1.0.0'])
    """
    The agent's own version number. The format is defined by the provider.
    """


class GetAuthenticatedExtendedCardSuccessResponse(A2ABaseModel):
    """
    Represents a successful JSON-RPC response for the `agent/getAuthenticatedExtendedCard` method.
    """

    id: str | int | None = None
    """
    The identifier established by the client.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    result: AgentCard
    """
    The result is an Agent Card object.
    """


class Task(A2ABaseModel):
    """
    Represents a single, stateful operation or conversation between a client and an agent.
    """

    artifacts: list[Artifact] | None = None
    """
    A collection of artifacts generated by the agent during the execution of the task.
    """
    context_id: str
    """
    A server-generated identifier for maintaining context across multiple related tasks or interactions.
    """
    history: list[Message] | None = None
    """
    An array of messages exchanged during the task, representing the conversation history.
    """
    id: str
    """
    A unique identifier for the task, generated by the server for a new task.
    """
    kind: Literal['task'] = 'task'
    """
    The type of this object, used as a discriminator. Always 'task' for a Task.
    """
    metadata: dict[str, Any] | None = None
    """
    Optional metadata for extensions. The key is an extension-specific identifier.
    """
    status: TaskStatus
    """
    The current status of the task, including its state and a descriptive message.
    """


class CancelTaskSuccessResponse(A2ABaseModel):
    """
    Represents a successful JSON-RPC response for the `tasks/cancel` method.
    """

    id: str | int | None = None
    """
    The identifier established by the client.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    result: Task
    """
    The result, containing the final state of the canceled Task object.
    """


class GetAuthenticatedExtendedCardResponse(
    RootModel[
        JSONRPCErrorResponse | GetAuthenticatedExtendedCardSuccessResponse
    ]
):
    root: JSONRPCErrorResponse | GetAuthenticatedExtendedCardSuccessResponse
    """
    Represents a JSON-RPC response for the `agent/getAuthenticatedExtendedCard` method.
    """


class GetTaskSuccessResponse(A2ABaseModel):
    """
    Represents a successful JSON-RPC response for the `tasks/get` method.
    """

    id: str | int | None = None
    """
    The identifier established by the client.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    result: Task
    """
    The result, containing the requested Task object.
    """


class SendMessageSuccessResponse(A2ABaseModel):
    """
    Represents a successful JSON-RPC response for the `message/send` method.
    """

    id: str | int | None = None
    """
    The identifier established by the client.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    result: Task | Message
    """
    The result, which can be a direct reply Message or the initial Task object.
    """


class SendStreamingMessageSuccessResponse(A2ABaseModel):
    """
    Represents a successful JSON-RPC response for the `message/stream` method.
    The server may send multiple response objects for a single request.
    """

    id: str | int | None = None
    """
    The identifier established by the client.
    """
    jsonrpc: Literal['2.0'] = '2.0'
    """
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
    result: Task | Message | TaskStatusUpdateEvent | TaskArtifactUpdateEvent
    """
    The result, which can be a Message, Task, or a streaming update event.
    """


class CancelTaskResponse(
    RootModel[JSONRPCErrorResponse | CancelTaskSuccessResponse]
):
    root: JSONRPCErrorResponse | CancelTaskSuccessResponse
    """
    Represents a JSON-RPC response for the `tasks/cancel` method.
    """


class GetTaskResponse(RootModel[JSONRPCErrorResponse | GetTaskSuccessResponse]):
    root: JSONRPCErrorResponse | GetTaskSuccessResponse
    """
    Represents a JSON-RPC response for the `tasks/get` method.
    """


class JSONRPCResponse(
    RootModel[
        JSONRPCErrorResponse
        | SendMessageSuccessResponse
        | SendStreamingMessageSuccessResponse
        | GetTaskSuccessResponse
        | CancelTaskSuccessResponse
        | SetTaskPushNotificationConfigSuccessResponse
        | GetTaskPushNotificationConfigSuccessResponse
        | ListTaskPushNotificationConfigSuccessResponse
        | DeleteTaskPushNotificationConfigSuccessResponse
        | GetAuthenticatedExtendedCardSuccessResponse
    ]
):
    root: (
        JSONRPCErrorResponse
        | SendMessageSuccessResponse
        | SendStreamingMessageSuccessResponse
        | GetTaskSuccessResponse
        | CancelTaskSuccessResponse
        | SetTaskPushNotificationConfigSuccessResponse
        | GetTaskPushNotificationConfigSuccessResponse
        | ListTaskPushNotificationConfigSuccessResponse
        | DeleteTaskPushNotificationConfigSuccessResponse
        | GetAuthenticatedExtendedCardSuccessResponse
    )
    """
    A discriminated union representing all possible JSON-RPC 2.0 responses
    for the A2A specification methods.
    """


class SendMessageResponse(
    RootModel[JSONRPCErrorResponse | SendMessageSuccessResponse]
):
    root: JSONRPCErrorResponse | SendMessageSuccessResponse
    """
    Represents a JSON-RPC response for the `message/send` method.
    """


class SendStreamingMessageResponse(
    RootModel[JSONRPCErrorResponse | SendStreamingMessageSuccessResponse]
):
    root: JSONRPCErrorResponse | SendStreamingMessageSuccessResponse
    """
    Represents a JSON-RPC response for the `message/stream` method.
    """



---
File: /a2a-python/tests/auth/test_user.py
---

import unittest

from a2a.auth.user import UnauthenticatedUser


class TestUnauthenticatedUser(unittest.TestCase):
    def test_is_authenticated_returns_false(self):
        user = UnauthenticatedUser()
        self.assertFalse(user.is_authenticated)

    def test_user_name_returns_empty_string(self):
        user = UnauthenticatedUser()
        self.assertEqual(user.user_name, '')


if __name__ == '__main__':
    unittest.main()



---
File: /a2a-python/tests/client/test_auth_middleware.py
---

import json

from collections.abc import Callable
from dataclasses import dataclass
from typing import Any

import httpx
import pytest
import respx

from a2a.client import (
    AuthInterceptor,
    Client,
    ClientCallContext,
    ClientCallInterceptor,
    ClientConfig,
    ClientFactory,
    InMemoryContextCredentialStore,
)
from a2a.types import (
    APIKeySecurityScheme,
    AgentCapabilities,
    AgentCard,
    AuthorizationCodeOAuthFlow,
    HTTPAuthSecurityScheme,
    In,
    Message,
    OAuth2SecurityScheme,
    OAuthFlows,
    OpenIdConnectSecurityScheme,
    Role,
    SecurityScheme,
    SendMessageSuccessResponse,
    TransportProtocol,
)


class HeaderInterceptor(ClientCallInterceptor):
    """A simple mock interceptor for testing basic middleware functionality."""

    def __init__(self, header_name: str, header_value: str):
        self.header_name = header_name
        self.header_value = header_value

    async def intercept(
        self,
        method_name: str,
        request_payload: dict[str, Any],
        http_kwargs: dict[str, Any],
        agent_card: AgentCard | None,
        context: ClientCallContext | None,
    ) -> tuple[dict[str, Any], dict[str, Any]]:
        headers = http_kwargs.get('headers', {})
        headers[self.header_name] = self.header_value
        http_kwargs['headers'] = headers
        return request_payload, http_kwargs


def build_success_response(request: httpx.Request) -> httpx.Response:
    """Creates a valid JSON-RPC success response based on the request."""
    request_payload = json.loads(request.content)
    response_payload = SendMessageSuccessResponse(
        id=request_payload['id'],
        jsonrpc='2.0',
        result=Message(
            kind='message',
            message_id='message-id',
            role=Role.agent,
            parts=[],
        ),
    ).model_dump(mode='json')
    return httpx.Response(200, json=response_payload)


def build_message() -> Message:
    """Builds a minimal Message."""
    return Message(
        message_id='msg1',
        role=Role.user,
        parts=[],
    )


async def send_message(
    client: Client,
    url: str,
    session_id: str | None = None,
) -> httpx.Request:
    """Mocks the response and sends a message using the client."""
    respx.post(url).mock(side_effect=build_success_response)
    context = ClientCallContext(
        state={'sessionId': session_id} if session_id else {}
    )
    async for _ in client.send_message(
        request=build_message(),
        context=context,
    ):
        pass
    return respx.calls.last.request


@pytest.fixture
def store():
    store = InMemoryContextCredentialStore()
    yield store


@pytest.mark.asyncio
async def test_auth_interceptor_skips_when_no_agent_card(store):
    """
    Tests that the AuthInterceptor does not modify the request when no AgentCard is provided.
    """
    request_payload = {'foo': 'bar'}
    http_kwargs = {'fizz': 'buzz'}
    auth_interceptor = AuthInterceptor(credential_service=store)

    new_payload, new_kwargs = await auth_interceptor.intercept(
        method_name='message/send',
        request_payload=request_payload,
        http_kwargs=http_kwargs,
        agent_card=None,
        context=ClientCallContext(state={}),
    )
    assert new_payload == request_payload
    assert new_kwargs == http_kwargs


@pytest.mark.asyncio
async def test_in_memory_context_credential_store(store):
    """
    Verifies that InMemoryContextCredentialStore correctly stores and retrieves
    credentials based on the session ID in the client context.
    """
    session_id = 'session-id'
    scheme_name = 'test-scheme'
    credential = 'test-token'
    await store.set_credentials(session_id, scheme_name, credential)

    # Assert: Successful retrieval
    context = ClientCallContext(state={'sessionId': session_id})
    retrieved_credential = await store.get_credentials(scheme_name, context)
    assert retrieved_credential == credential
    # Assert: Retrieval with wrong session ID returns None
    wrong_context = ClientCallContext(state={'sessionId': 'wrong-session'})
    retrieved_credential_wrong = await store.get_credentials(
        scheme_name, wrong_context
    )
    assert retrieved_credential_wrong is None
    # Assert: Retrieval with no context returns None
    retrieved_credential_none = await store.get_credentials(scheme_name, None)
    assert retrieved_credential_none is None
    # Assert: Retrieval with context but no sessionId returns None
    empty_context = ClientCallContext(state={})
    retrieved_credential_empty = await store.get_credentials(
        scheme_name, empty_context
    )
    assert retrieved_credential_empty is None
    # Assert: Overwrite the credential when session_id already exists
    new_credential = 'new-token'
    await store.set_credentials(session_id, scheme_name, new_credential)
    assert await store.get_credentials(scheme_name, context) == new_credential


@pytest.mark.asyncio
@respx.mock
async def test_client_with_simple_interceptor():
    """
    Ensures that a custom HeaderInterceptor correctly injects a static header
    into outbound HTTP requests from the A2AClient.
    """
    url = 'http://agent.com/rpc'
    interceptor = HeaderInterceptor('X-Test-Header', 'Test-Value-123')
    card = AgentCard(
        url=url,
        name='testbot',
        description='test bot',
        version='1.0',
        default_input_modes=[],
        default_output_modes=[],
        skills=[],
        capabilities=AgentCapabilities(),
        preferred_transport=TransportProtocol.jsonrpc,
    )

    async with httpx.AsyncClient() as http_client:
        config = ClientConfig(
            httpx_client=http_client,
            supported_transports=[TransportProtocol.jsonrpc],
        )
        factory = ClientFactory(config)
        client = factory.create(card, interceptors=[interceptor])

        request = await send_message(client, url)
        assert request.headers['x-test-header'] == 'Test-Value-123'


@dataclass
class AuthTestCase:
    """
    Represents a test scenario for verifying authentication behavior in AuthInterceptor.
    """

    url: str
    """The endpoint URL of the agent to which the request is sent."""
    session_id: str
    """The client session ID used to fetch credentials from the credential store."""
    scheme_name: str
    """The name of the security scheme defined in the agent card."""
    credential: str
    """The actual credential value (e.g., API key, access token) to be injected."""
    security_scheme: Any
    """The security scheme object (e.g., APIKeySecurityScheme, OAuth2SecurityScheme, etc.) to define behavior."""
    expected_header_key: str
    """The expected HTTP header name to be set by the interceptor."""
    expected_header_value_func: Callable[[str], str]
    """A function that maps the credential to its expected header value (e.g., lambda c: f"Bearer {c}")."""


api_key_test_case = AuthTestCase(
    url='http://agent.com/rpc',
    session_id='session-id',
    scheme_name='apikey',
    credential='secret-api-key',
    security_scheme=APIKeySecurityScheme(
        type='apiKey',
        name='X-API-Key',
        in_=In.header,
    ),
    expected_header_key='x-api-key',
    expected_header_value_func=lambda c: c,
)


oauth2_test_case = AuthTestCase(
    url='http://agent.com/rpc',
    session_id='session-id',
    scheme_name='oauth2',
    credential='secret-oauth-access-token',
    security_scheme=OAuth2SecurityScheme(
        type='oauth2',
        flows=OAuthFlows(
            authorization_code=AuthorizationCodeOAuthFlow(
                authorization_url='http://provider.com/auth',
                token_url='http://provider.com/token',
                scopes={'read': 'Read scope'},
            )
        ),
    ),
    expected_header_key='Authorization',
    expected_header_value_func=lambda c: f'Bearer {c}',
)


oidc_test_case = AuthTestCase(
    url='http://agent.com/rpc',
    session_id='session-id',
    scheme_name='oidc',
    credential='secret-oidc-id-token',
    security_scheme=OpenIdConnectSecurityScheme(
        type='openIdConnect',
        open_id_connect_url='http://provider.com/.well-known/openid-configuration',
    ),
    expected_header_key='Authorization',
    expected_header_value_func=lambda c: f'Bearer {c}',
)


bearer_test_case = AuthTestCase(
    url='http://agent.com/rpc',
    session_id='session-id',
    scheme_name='bearer',
    credential='bearer-token-123',
    security_scheme=HTTPAuthSecurityScheme(
        scheme='bearer',
    ),
    expected_header_key='Authorization',
    expected_header_value_func=lambda c: f'Bearer {c}',
)


@pytest.mark.asyncio
@pytest.mark.parametrize(
    'test_case',
    [api_key_test_case, oauth2_test_case, oidc_test_case, bearer_test_case],
)
@respx.mock
async def test_auth_interceptor_variants(test_case, store):
    """
    Parametrized test verifying that AuthInterceptor correctly attaches credentials
    based on the defined security scheme in the AgentCard.
    """
    await store.set_credentials(
        test_case.session_id, test_case.scheme_name, test_case.credential
    )
    auth_interceptor = AuthInterceptor(credential_service=store)
    agent_card = AgentCard(
        url=test_case.url,
        name=f'{test_case.scheme_name}bot',
        description=f'A bot that uses {test_case.scheme_name}',
        version='1.0',
        default_input_modes=[],
        default_output_modes=[],
        skills=[],
        capabilities=AgentCapabilities(),
        security=[{test_case.scheme_name: []}],
        security_schemes={
            test_case.scheme_name: SecurityScheme(
                root=test_case.security_scheme
            )
        },
        preferred_transport=TransportProtocol.jsonrpc,
    )

    async with httpx.AsyncClient() as http_client:
        config = ClientConfig(
            httpx_client=http_client,
            supported_transports=[TransportProtocol.jsonrpc],
        )
        factory = ClientFactory(config)
        client = factory.create(agent_card, interceptors=[auth_interceptor])

        request = await send_message(
            client, test_case.url, test_case.session_id
        )
        assert request.headers[
            test_case.expected_header_key
        ] == test_case.expected_header_value_func(test_case.credential)


@pytest.mark.asyncio
async def test_auth_interceptor_skips_when_scheme_not_in_security_schemes(
    store,
):
    """
    Tests that AuthInterceptor skips a scheme if it's listed in security requirements
    but not defined in security_schemes.
    """
    scheme_name = 'missing'
    session_id = 'session-id'
    credential = 'dummy-token'
    request_payload = {'foo': 'bar'}
    http_kwargs = {'fizz': 'buzz'}
    await store.set_credentials(session_id, scheme_name, credential)
    auth_interceptor = AuthInterceptor(credential_service=store)
    agent_card = AgentCard(
        url='http://agent.com/rpc',
        name='missingbot',
        description='A bot that uses missing scheme definition',
        version='1.0',
        default_input_modes=[],
        default_output_modes=[],
        skills=[],
        capabilities=AgentCapabilities(),
        security=[{scheme_name: []}],
        security_schemes={},
    )

    new_payload, new_kwargs = await auth_interceptor.intercept(
        method_name='message/send',
        request_payload=request_payload,
        http_kwargs=http_kwargs,
        agent_card=agent_card,
        context=ClientCallContext(state={'sessionId': session_id}),
    )
    assert new_payload == request_payload
    assert new_kwargs == http_kwargs



---
File: /a2a-python/tests/client/test_base_client.py
---

from unittest.mock import AsyncMock, MagicMock

import pytest

from a2a.client.base_client import BaseClient
from a2a.client.client import ClientConfig
from a2a.client.transports.base import ClientTransport
from a2a.types import (
    AgentCapabilities,
    AgentCard,
    Message,
    Part,
    Role,
    Task,
    TaskState,
    TaskStatus,
    TextPart,
)


@pytest.fixture
def mock_transport():
    return AsyncMock(spec=ClientTransport)


@pytest.fixture
def sample_agent_card():
    return AgentCard(
        name='Test Agent',
        description='An agent for testing',
        url='http://test.com',
        version='1.0',
        capabilities=AgentCapabilities(streaming=True),
        default_input_modes=['text/plain'],
        default_output_modes=['text/plain'],
        skills=[],
    )


@pytest.fixture
def sample_message():
    return Message(
        role=Role.user,
        message_id='msg-1',
        parts=[Part(root=TextPart(text='Hello'))],
    )


@pytest.fixture
def base_client(sample_agent_card, mock_transport):
    config = ClientConfig(streaming=True)
    return BaseClient(
        card=sample_agent_card,
        config=config,
        transport=mock_transport,
        consumers=[],
        middleware=[],
    )


@pytest.mark.asyncio
async def test_send_message_streaming(
    base_client: BaseClient, mock_transport: MagicMock, sample_message: Message
):
    async def create_stream(*args, **kwargs):
        yield Task(
            id='task-123',
            context_id='ctx-456',
            status=TaskStatus(state=TaskState.completed),
        )

    mock_transport.send_message_streaming.return_value = create_stream()

    events = [event async for event in base_client.send_message(sample_message)]

    mock_transport.send_message_streaming.assert_called_once()
    assert not mock_transport.send_message.called
    assert len(events) == 1
    assert events[0][0].id == 'task-123'


@pytest.mark.asyncio
async def test_send_message_non_streaming(
    base_client: BaseClient, mock_transport: MagicMock, sample_message: Message
):
    base_client._config.streaming = False
    mock_transport.send_message.return_value = Task(
        id='task-456',
        context_id='ctx-789',
        status=TaskStatus(state=TaskState.completed),
    )

    events = [event async for event in base_client.send_message(sample_message)]

    mock_transport.send_message.assert_called_once()
    assert not mock_transport.send_message_streaming.called
    assert len(events) == 1
    assert events[0][0].id == 'task-456'


@pytest.mark.asyncio
async def test_send_message_non_streaming_agent_capability_false(
    base_client: BaseClient, mock_transport: MagicMock, sample_message: Message
):
    base_client._card.capabilities.streaming = False
    mock_transport.send_message.return_value = Task(
        id='task-789',
        context_id='ctx-101',
        status=TaskStatus(state=TaskState.completed),
    )

    events = [event async for event in base_client.send_message(sample_message)]

    mock_transport.send_message.assert_called_once()
    assert not mock_transport.send_message_streaming.called
    assert len(events) == 1
    assert events[0][0].id == 'task-789'



---
File: /a2a-python/tests/client/test_client_factory.py
---

"""Tests for the ClientFactory."""

import httpx
import pytest

from a2a.client import ClientConfig, ClientFactory
from a2a.client.transports import JsonRpcTransport, RestTransport
from a2a.types import (
    AgentCapabilities,
    AgentCard,
    AgentInterface,
    TransportProtocol,
)


@pytest.fixture
def base_agent_card() -> AgentCard:
    """Provides a base AgentCard for tests."""
    return AgentCard(
        name='Test Agent',
        description='An agent for testing.',
        url='http://primary-url.com',
        version='1.0.0',
        capabilities=AgentCapabilities(),
        skills=[],
        default_input_modes=[],
        default_output_modes=[],
        preferred_transport=TransportProtocol.jsonrpc,
    )


def test_client_factory_selects_preferred_transport(base_agent_card: AgentCard):
    """Verify that the factory selects the preferred transport by default."""
    config = ClientConfig(
        httpx_client=httpx.AsyncClient(),
        supported_transports=[
            TransportProtocol.jsonrpc,
            TransportProtocol.http_json,
        ],
    )
    factory = ClientFactory(config)
    client = factory.create(base_agent_card)

    assert isinstance(client._transport, JsonRpcTransport)
    assert client._transport.url == 'http://primary-url.com'


def test_client_factory_selects_secondary_transport_url(
    base_agent_card: AgentCard,
):
    """Verify that the factory selects the correct URL for a secondary transport."""
    base_agent_card.additional_interfaces = [
        AgentInterface(
            transport=TransportProtocol.http_json,
            url='http://secondary-url.com',
        )
    ]
    # Client prefers REST, which is available as a secondary transport
    config = ClientConfig(
        httpx_client=httpx.AsyncClient(),
        supported_transports=[
            TransportProtocol.http_json,
            TransportProtocol.jsonrpc,
        ],
        use_client_preference=True,
    )
    factory = ClientFactory(config)
    client = factory.create(base_agent_card)

    assert isinstance(client._transport, RestTransport)
    assert client._transport.url == 'http://secondary-url.com'


def test_client_factory_server_preference(base_agent_card: AgentCard):
    """Verify that the factory respects server transport preference."""
    base_agent_card.preferred_transport = TransportProtocol.http_json
    base_agent_card.additional_interfaces = [
        AgentInterface(
            transport=TransportProtocol.jsonrpc, url='http://secondary-url.com'
        )
    ]
    # Client supports both, but server prefers REST
    config = ClientConfig(
        httpx_client=httpx.AsyncClient(),
        supported_transports=[
            TransportProtocol.jsonrpc,
            TransportProtocol.http_json,
        ],
    )
    factory = ClientFactory(config)
    client = factory.create(base_agent_card)

    assert isinstance(client._transport, RestTransport)
    assert client._transport.url == 'http://primary-url.com'


def test_client_factory_no_compatible_transport(base_agent_card: AgentCard):
    """Verify that the factory raises an error if no compatible transport is found."""
    config = ClientConfig(
        httpx_client=httpx.AsyncClient(),
        supported_transports=[TransportProtocol.grpc],
    )
    factory = ClientFactory(config)
    with pytest.raises(ValueError, match='no compatible transports found'):
        factory.create(base_agent_card)



---
File: /a2a-python/tests/client/test_client_task_manager.py
---

from unittest.mock import AsyncMock, Mock, patch

import pytest

from a2a.client.client_task_manager import ClientTaskManager
from a2a.client.errors import (
    A2AClientInvalidArgsError,
    A2AClientInvalidStateError,
)
from a2a.types import (
    Artifact,
    Message,
    Part,
    Role,
    Task,
    TaskArtifactUpdateEvent,
    TaskState,
    TaskStatus,
    TaskStatusUpdateEvent,
    TextPart,
)


@pytest.fixture
def task_manager():
    return ClientTaskManager()


@pytest.fixture
def sample_task():
    return Task(
        id='task123',
        context_id='context456',
        status=TaskStatus(state=TaskState.working),
        history=[],
        artifacts=[],
    )


@pytest.fixture
def sample_message():
    return Message(
        message_id='msg1',
        role=Role.user,
        parts=[Part(root=TextPart(text='Hello'))],
    )


def test_get_task_no_task_id_returns_none(task_manager: ClientTaskManager):
    assert task_manager.get_task() is None


def test_get_task_or_raise_no_task_raises_error(
    task_manager: ClientTaskManager,
):
    with pytest.raises(A2AClientInvalidStateError, match='no current Task'):
        task_manager.get_task_or_raise()


@pytest.mark.asyncio
async def test_save_task_event_with_task(
    task_manager: ClientTaskManager, sample_task: Task
):
    await task_manager.save_task_event(sample_task)
    assert task_manager.get_task() == sample_task
    assert task_manager._task_id == sample_task.id
    assert task_manager._context_id == sample_task.context_id


@pytest.mark.asyncio
async def test_save_task_event_with_task_already_set_raises_error(
    task_manager: ClientTaskManager, sample_task: Task
):
    await task_manager.save_task_event(sample_task)
    with pytest.raises(
        A2AClientInvalidArgsError,
        match='Task is already set, create new manager for new tasks.',
    ):
        await task_manager.save_task_event(sample_task)


@pytest.mark.asyncio
async def test_save_task_event_with_status_update(
    task_manager: ClientTaskManager, sample_task: Task, sample_message: Message
):
    await task_manager.save_task_event(sample_task)
    status_update = TaskStatusUpdateEvent(
        task_id=sample_task.id,
        context_id=sample_task.context_id,
        status=TaskStatus(state=TaskState.completed, message=sample_message),
        final=True,
    )
    updated_task = await task_manager.save_task_event(status_update)
    assert updated_task.status.state == TaskState.completed
    assert updated_task.history == [sample_message]


@pytest.mark.asyncio
async def test_save_task_event_with_artifact_update(
    task_manager: ClientTaskManager, sample_task: Task
):
    await task_manager.save_task_event(sample_task)
    artifact = Artifact(
        artifact_id='art1', parts=[Part(root=TextPart(text='artifact content'))]
    )
    artifact_update = TaskArtifactUpdateEvent(
        task_id=sample_task.id,
        context_id=sample_task.context_id,
        artifact=artifact,
    )

    with patch(
        'a2a.client.client_task_manager.append_artifact_to_task'
    ) as mock_append:
        updated_task = await task_manager.save_task_event(artifact_update)
        mock_append.assert_called_once_with(updated_task, artifact_update)


@pytest.mark.asyncio
async def test_save_task_event_creates_task_if_not_exists(
    task_manager: ClientTaskManager,
):
    status_update = TaskStatusUpdateEvent(
        task_id='new_task',
        context_id='new_context',
        status=TaskStatus(state=TaskState.working),
        final=False,
    )
    updated_task = await task_manager.save_task_event(status_update)
    assert updated_task is not None
    assert updated_task.id == 'new_task'
    assert updated_task.status.state == TaskState.working


@pytest.mark.asyncio
async def test_process_with_task_event(
    task_manager: ClientTaskManager, sample_task: Task
):
    with patch.object(
        task_manager, 'save_task_event', new_callable=AsyncMock
    ) as mock_save:
        await task_manager.process(sample_task)
        mock_save.assert_called_once_with(sample_task)


@pytest.mark.asyncio
async def test_process_with_non_task_event(task_manager: ClientTaskManager):
    with patch.object(
        task_manager, 'save_task_event', new_callable=Mock
    ) as mock_save:
        non_task_event = 'not a task event'
        await task_manager.process(non_task_event)
        mock_save.assert_not_called()


def test_update_with_message(
    task_manager: ClientTaskManager, sample_task: Task, sample_message: Message
):
    updated_task = task_manager.update_with_message(sample_message, sample_task)
    assert updated_task.history == [sample_message]


def test_update_with_message_moves_status_message(
    task_manager: ClientTaskManager, sample_task: Task, sample_message: Message
):
    status_message = Message(
        message_id='status_msg',
        role=Role.agent,
        parts=[Part(root=TextPart(text='Status'))],
    )
    sample_task.status.message = status_message
    updated_task = task_manager.update_with_message(sample_message, sample_task)
    assert updated_task.history == [status_message, sample_message]
    assert updated_task.status.message is None



---
File: /a2a-python/tests/client/test_errors.py
---

import pytest

from a2a.client import A2AClientError, A2AClientHTTPError, A2AClientJSONError


class TestA2AClientError:
    """Test cases for the base A2AClientError class."""

    def test_instantiation(self):
        """Test that A2AClientError can be instantiated."""
        error = A2AClientError('Test error message')
        assert isinstance(error, Exception)
        assert str(error) == 'Test error message'

    def test_inheritance(self):
        """Test that A2AClientError inherits from Exception."""
        error = A2AClientError()
        assert isinstance(error, Exception)


class TestA2AClientHTTPError:
    """Test cases for A2AClientHTTPError class."""

    def test_instantiation(self):
        """Test that A2AClientHTTPError can be instantiated with status_code and message."""
        error = A2AClientHTTPError(404, 'Not Found')
        assert isinstance(error, A2AClientError)
        assert error.status_code == 404
        assert error.message == 'Not Found'

    def test_message_formatting(self):
        """Test that the error message is formatted correctly."""
        error = A2AClientHTTPError(500, 'Internal Server Error')
        assert str(error) == 'HTTP Error 500: Internal Server Error'

    def test_inheritance(self):
        """Test that A2AClientHTTPError inherits from A2AClientError."""
        error = A2AClientHTTPError(400, 'Bad Request')
        assert isinstance(error, A2AClientError)

    def test_with_empty_message(self):
        """Test behavior with an empty message."""
        error = A2AClientHTTPError(403, '')
        assert error.status_code == 403
        assert error.message == ''
        assert str(error) == 'HTTP Error 403: '

    def test_with_various_status_codes(self):
        """Test with different HTTP status codes."""
        test_cases = [
            (200, 'OK'),
            (201, 'Created'),
            (400, 'Bad Request'),
            (401, 'Unauthorized'),
            (403, 'Forbidden'),
            (404, 'Not Found'),
            (500, 'Internal Server Error'),
            (503, 'Service Unavailable'),
        ]

        for status_code, message in test_cases:
            error = A2AClientHTTPError(status_code, message)
            assert error.status_code == status_code
            assert error.message == message
            assert str(error) == f'HTTP Error {status_code}: {message}'


class TestA2AClientJSONError:
    """Test cases for A2AClientJSONError class."""

    def test_instantiation(self):
        """Test that A2AClientJSONError can be instantiated with a message."""
        error = A2AClientJSONError('Invalid JSON format')
        assert isinstance(error, A2AClientError)
        assert error.message == 'Invalid JSON format'

    def test_message_formatting(self):
        """Test that the error message is formatted correctly."""
        error = A2AClientJSONError('Missing required field')
        assert str(error) == 'JSON Error: Missing required field'

    def test_inheritance(self):
        """Test that A2AClientJSONError inherits from A2AClientError."""
        error = A2AClientJSONError('Parsing error')
        assert isinstance(error, A2AClientError)

    def test_with_empty_message(self):
        """Test behavior with an empty message."""
        error = A2AClientJSONError('')
        assert error.message == ''
        assert str(error) == 'JSON Error: '

    def test_with_various_messages(self):
        """Test with different error messages."""
        test_messages = [
            'Malformed JSON',
            'Missing required fields',
            'Invalid data type',
            'Unexpected JSON structure',
            'Empty JSON object',
        ]

        for message in test_messages:
            error = A2AClientJSONError(message)
            assert error.message == message
            assert str(error) == f'JSON Error: {message}'


class TestExceptionHierarchy:
    """Test the exception hierarchy and relationships."""

    def test_exception_hierarchy(self):
        """Test that the exception hierarchy is correct."""
        assert issubclass(A2AClientError, Exception)
        assert issubclass(A2AClientHTTPError, A2AClientError)
        assert issubclass(A2AClientJSONError, A2AClientError)

    def test_catch_specific_exception(self):
        """Test that specific exceptions can be caught."""
        try:
            raise A2AClientHTTPError(404, 'Not Found')
        except A2AClientHTTPError as e:
            assert e.status_code == 404
            assert e.message == 'Not Found'

    def test_catch_base_exception(self):
        """Test that derived exceptions can be caught as base exception."""
        exceptions = [
            A2AClientHTTPError(404, 'Not Found'),
            A2AClientJSONError('Invalid JSON'),
        ]

        for raised_error in exceptions:
            try:
                raise raised_error
            except A2AClientError as e:
                assert isinstance(e, A2AClientError)


class TestExceptionRaising:
    """Test cases for raising and handling the exceptions."""

    def test_raising_http_error(self):
        """Test raising an HTTP error and checking its properties."""
        with pytest.raises(A2AClientHTTPError) as excinfo:
            raise A2AClientHTTPError(429, 'Too Many Requests')

        error = excinfo.value
        assert error.status_code == 429
        assert error.message == 'Too Many Requests'
        assert str(error) == 'HTTP Error 429: Too Many Requests'

    def test_raising_json_error(self):
        """Test raising a JSON error and checking its properties."""
        with pytest.raises(A2AClientJSONError) as excinfo:
            raise A2AClientJSONError('Invalid format')

        error = excinfo.value
        assert error.message == 'Invalid format'
        assert str(error) == 'JSON Error: Invalid format'

    def test_raising_base_error(self):
        """Test raising the base error."""
        with pytest.raises(A2AClientError) as excinfo:
            raise A2AClientError('Generic client error')

        assert str(excinfo.value) == 'Generic client error'


# Additional parametrized tests for more comprehensive coverage


@pytest.mark.parametrize(
    'status_code,message,expected',
    [
        (400, 'Bad Request', 'HTTP Error 400: Bad Request'),
        (404, 'Not Found', 'HTTP Error 404: Not Found'),
        (500, 'Server Error', 'HTTP Error 500: Server Error'),
    ],
)
def test_http_error_parametrized(status_code, message, expected):
    """Parametrized test for HTTP errors with different status codes."""
    error = A2AClientHTTPError(status_code, message)
    assert error.status_code == status_code
    assert error.message == message
    assert str(error) == expected


@pytest.mark.parametrize(
    'message,expected',
    [
        ('Missing field', 'JSON Error: Missing field'),
        ('Invalid type', 'JSON Error: Invalid type'),
        ('Parsing failed', 'JSON Error: Parsing failed'),
    ],
)
def test_json_error_parametrized(message, expected):
    """Parametrized test for JSON errors with different messages."""
    error = A2AClientJSONError(message)
    assert error.message == message
    assert str(error) == expected



---
File: /a2a-python/tests/client/test_grpc_client.py
---

from unittest.mock import AsyncMock

import pytest

from a2a.client.transports.grpc import GrpcTransport
from a2a.grpc import a2a_pb2, a2a_pb2_grpc
from a2a.types import (
    AgentCapabilities,
    AgentCard,
    Message,
    MessageSendParams,
    Part,
    Role,
    Task,
    TaskIdParams,
    TaskQueryParams,
    TaskState,
    TaskStatus,
    TextPart,
)
from a2a.utils import get_text_parts, proto_utils


# Fixtures
@pytest.fixture
def mock_grpc_stub() -> AsyncMock:
    """Provides a mock gRPC stub with methods mocked."""
    stub = AsyncMock(spec=a2a_pb2_grpc.A2AServiceStub)
    stub.SendMessage = AsyncMock()
    stub.SendStreamingMessage = AsyncMock()
    stub.GetTask = AsyncMock()
    stub.CancelTask = AsyncMock()
    stub.CreateTaskPushNotification = AsyncMock()
    stub.GetTaskPushNotification = AsyncMock()
    return stub


@pytest.fixture
def sample_agent_card() -> AgentCard:
    """Provides a minimal agent card for initialization."""
    return AgentCard(
        name='gRPC Test Agent',
        description='Agent for testing gRPC client',
        url='grpc://localhost:50051',
        version='1.0',
        capabilities=AgentCapabilities(streaming=True, push_notifications=True),
        default_input_modes=['text/plain'],
        default_output_modes=['text/plain'],
        skills=[],
    )


@pytest.fixture
def grpc_transport(
    mock_grpc_stub: AsyncMock, sample_agent_card: AgentCard
) -> GrpcTransport:
    """Provides a GrpcTransport instance."""
    channel = AsyncMock()
    transport = GrpcTransport(channel=channel, agent_card=sample_agent_card)
    transport.stub = mock_grpc_stub
    return transport


@pytest.fixture
def sample_message_send_params() -> MessageSendParams:
    """Provides a sample MessageSendParams object."""
    return MessageSendParams(
        message=Message(
            role=Role.user,
            message_id='msg-1',
            parts=[Part(root=TextPart(text='Hello'))],
        )
    )


@pytest.fixture
def sample_task() -> Task:
    """Provides a sample Task object."""
    return Task(
        id='task-1',
        context_id='ctx-1',
        status=TaskStatus(state=TaskState.completed),
    )


@pytest.fixture
def sample_message() -> Message:
    """Provides a sample Message object."""
    return Message(
        role=Role.agent,
        message_id='msg-response',
        parts=[Part(root=TextPart(text='Hi there'))],
    )


@pytest.mark.asyncio
async def test_send_message_task_response(
    grpc_transport: GrpcTransport,
    mock_grpc_stub: AsyncMock,
    sample_message_send_params: MessageSendParams,
    sample_task: Task,
):
    """Test send_message that returns a Task."""
    mock_grpc_stub.SendMessage.return_value = a2a_pb2.SendMessageResponse(
        task=proto_utils.ToProto.task(sample_task)
    )

    response = await grpc_transport.send_message(sample_message_send_params)

    mock_grpc_stub.SendMessage.assert_awaited_once()
    assert isinstance(response, Task)
    assert response.id == sample_task.id


@pytest.mark.asyncio
async def test_send_message_message_response(
    grpc_transport: GrpcTransport,
    mock_grpc_stub: AsyncMock,
    sample_message_send_params: MessageSendParams,
    sample_message: Message,
):
    """Test send_message that returns a Message."""
    mock_grpc_stub.SendMessage.return_value = a2a_pb2.SendMessageResponse(
        msg=proto_utils.ToProto.message(sample_message)
    )

    response = await grpc_transport.send_message(sample_message_send_params)

    mock_grpc_stub.SendMessage.assert_awaited_once()
    assert isinstance(response, Message)
    assert response.message_id == sample_message.message_id
    assert get_text_parts(response.parts) == get_text_parts(
        sample_message.parts
    )


@pytest.mark.asyncio
async def test_get_task(
    grpc_transport: GrpcTransport, mock_grpc_stub: AsyncMock, sample_task: Task
):
    """Test retrieving a task."""
    mock_grpc_stub.GetTask.return_value = proto_utils.ToProto.task(sample_task)
    params = TaskQueryParams(id=sample_task.id)

    response = await grpc_transport.get_task(params)

    mock_grpc_stub.GetTask.assert_awaited_once_with(
        a2a_pb2.GetTaskRequest(
            name=f'tasks/{sample_task.id}', history_length=None
        )
    )
    assert response.id == sample_task.id


@pytest.mark.asyncio
async def test_get_task_with_history(
    grpc_transport: GrpcTransport, mock_grpc_stub: AsyncMock, sample_task: Task
):
    """Test retrieving a task with history."""
    mock_grpc_stub.GetTask.return_value = proto_utils.ToProto.task(sample_task)
    history_len = 10
    params = TaskQueryParams(id=sample_task.id, history_length=history_len)

    await grpc_transport.get_task(params)

    mock_grpc_stub.GetTask.assert_awaited_once_with(
        a2a_pb2.GetTaskRequest(
            name=f'tasks/{sample_task.id}', history_length=history_len
        )
    )


@pytest.mark.asyncio
async def test_cancel_task(
    grpc_transport: GrpcTransport, mock_grpc_stub: AsyncMock, sample_task: Task
):
    """Test cancelling a task."""
    cancelled_task = sample_task.model_copy()
    cancelled_task.status.state = TaskState.canceled
    mock_grpc_stub.CancelTask.return_value = proto_utils.ToProto.task(
        cancelled_task
    )
    params = TaskIdParams(id=sample_task.id)

    response = await grpc_transport.cancel_task(params)

    mock_grpc_stub.CancelTask.assert_awaited_once_with(
        a2a_pb2.CancelTaskRequest(name=f'tasks/{sample_task.id}')
    )
    assert response.status.state == TaskState.canceled



---
File: /a2a-python/tests/client/test_jsonrpc_client.py
---

import json

from collections.abc import AsyncGenerator
from typing import Any
from unittest.mock import AsyncMock, MagicMock, patch

import httpx
import pytest

from httpx_sse import EventSource, SSEError, ServerSentEvent

from a2a.client import (
    A2ACardResolver,
    A2AClientHTTPError,
    A2AClientJSONError,
    A2AClientTimeoutError,
    create_text_message_object,
)
from a2a.client.transports.jsonrpc import JsonRpcTransport
from a2a.types import (
    AgentCapabilities,
    AgentCard,
    AgentSkill,
    InvalidParamsError,
    Message,
    MessageSendParams,
    PushNotificationConfig,
    Role,
    SendMessageSuccessResponse,
    Task,
    TaskIdParams,
    TaskPushNotificationConfig,
    TaskQueryParams,
)
from a2a.utils import AGENT_CARD_WELL_KNOWN_PATH


AGENT_CARD = AgentCard(
    name='Hello World Agent',
    description='Just a hello world agent',
    url='http://localhost:9999/',
    version='1.0.0',
    default_input_modes=['text'],
    default_output_modes=['text'],
    capabilities=AgentCapabilities(),
    skills=[
        AgentSkill(
            id='hello_world',
            name='Returns hello world',
            description='just returns hello world',
            tags=['hello world'],
            examples=['hi', 'hello world'],
        )
    ],
)

AGENT_CARD_EXTENDED = AGENT_CARD.model_copy(
    update={
        'name': 'Hello World Agent - Extended Edition',
        'skills': [
            *AGENT_CARD.skills,
            AgentSkill(
                id='extended_skill',
                name='Super Greet',
                description='A more enthusiastic greeting.',
                tags=['extended'],
                examples=['super hi'],
            ),
        ],
        'version': '1.0.1',
    }
)

AGENT_CARD_SUPPORTS_EXTENDED = AGENT_CARD.model_copy(
    update={'supports_authenticated_extended_card': True}
)
AGENT_CARD_NO_URL_SUPPORTS_EXTENDED = AGENT_CARD_SUPPORTS_EXTENDED.model_copy(
    update={'url': ''}
)

MINIMAL_TASK: dict[str, Any] = {
    'id': 'task-abc',
    'contextId': 'session-xyz',
    'status': {'state': 'working'},
    'kind': 'task',
}

MINIMAL_CANCELLED_TASK: dict[str, Any] = {
    'id': 'task-abc',
    'contextId': 'session-xyz',
    'status': {'state': 'canceled'},
    'kind': 'task',
}


@pytest.fixture
def mock_httpx_client() -> AsyncMock:
    return AsyncMock(spec=httpx.AsyncClient)


@pytest.fixture
def mock_agent_card() -> MagicMock:
    mock = MagicMock(spec=AgentCard, url='http://agent.example.com/api')
    mock.supports_authenticated_extended_card = False
    return mock


async def async_iterable_from_list(
    items: list[ServerSentEvent],
) -> AsyncGenerator[ServerSentEvent, None]:
    """Helper to create an async iterable from a list."""
    for item in items:
        yield item


class TestA2ACardResolver:
    BASE_URL = 'http://example.com'
    AGENT_CARD_PATH = AGENT_CARD_WELL_KNOWN_PATH
    FULL_AGENT_CARD_URL = f'{BASE_URL}{AGENT_CARD_PATH}'
    EXTENDED_AGENT_CARD_PATH = '/agent/authenticatedExtendedCard'

    @pytest.mark.asyncio
    async def test_init_parameters_stored_correctly(
        self, mock_httpx_client: AsyncMock
    ):
        base_url = 'http://example.com'
        custom_path = '/custom/agent-card.json'
        resolver = A2ACardResolver(
            httpx_client=mock_httpx_client,
            base_url=base_url,
            agent_card_path=custom_path,
        )
        assert resolver.base_url == base_url
        assert resolver.agent_card_path == custom_path.lstrip('/')
        assert resolver.httpx_client == mock_httpx_client

        resolver_default_path = A2ACardResolver(
            httpx_client=mock_httpx_client,
            base_url=base_url,
        )
        assert (
            '/' + resolver_default_path.agent_card_path
            == AGENT_CARD_WELL_KNOWN_PATH
        )

    @pytest.mark.asyncio
    async def test_init_strips_slashes(self, mock_httpx_client: AsyncMock):
        resolver = A2ACardResolver(
            httpx_client=mock_httpx_client,
            base_url='http://example.com/',
            agent_card_path='/.well-known/agent-card.json/',
        )
        assert resolver.base_url == 'http://example.com'
        assert resolver.agent_card_path == '.well-known/agent-card.json/'

    @pytest.mark.asyncio
    async def test_get_agent_card_success_public_only(
        self, mock_httpx_client: AsyncMock
    ):
        mock_response = AsyncMock(spec=httpx.Response)
        mock_response.status_code = 200
        mock_response.json.return_value = AGENT_CARD.model_dump(mode='json')
        mock_httpx_client.get.return_value = mock_response

        resolver = A2ACardResolver(
            httpx_client=mock_httpx_client,
            base_url=self.BASE_URL,
            agent_card_path=self.AGENT_CARD_PATH,
        )
        agent_card = await resolver.get_agent_card(http_kwargs={'timeout': 10})

        mock_httpx_client.get.assert_called_once_with(
            self.FULL_AGENT_CARD_URL, timeout=10
        )
        mock_response.raise_for_status.assert_called_once()
        assert isinstance(agent_card, AgentCard)
        assert agent_card == AGENT_CARD
        assert mock_httpx_client.get.call_count == 1

    @pytest.mark.asyncio
    async def test_get_agent_card_success_with_specified_path_for_extended_card(
        self, mock_httpx_client: AsyncMock
    ):
        extended_card_response = AsyncMock(spec=httpx.Response)
        extended_card_response.status_code = 200
        extended_card_response.json.return_value = (
            AGENT_CARD_EXTENDED.model_dump(mode='json')
        )
        mock_httpx_client.get.return_value = extended_card_response

        resolver = A2ACardResolver(
            httpx_client=mock_httpx_client,
            base_url=self.BASE_URL,
            agent_card_path=self.AGENT_CARD_PATH,
        )

        auth_kwargs = {'headers': {'Authorization': 'Bearer test token'}}
        agent_card_result = await resolver.get_agent_card(
            relative_card_path=self.EXTENDED_AGENT_CARD_PATH,
            http_kwargs=auth_kwargs,
        )

        expected_extended_url = (
            f'{self.BASE_URL}/{self.EXTENDED_AGENT_CARD_PATH.lstrip("/")}'
        )
        mock_httpx_client.get.assert_called_once_with(
            expected_extended_url, **auth_kwargs
        )
        extended_card_response.raise_for_status.assert_called_once()
        assert isinstance(agent_card_result, AgentCard)
        assert agent_card_result == AGENT_CARD_EXTENDED

    @pytest.mark.asyncio
    async def test_get_agent_card_validation_error(
        self, mock_httpx_client: AsyncMock
    ):
        mock_response = AsyncMock(spec=httpx.Response)
        mock_response.status_code = 200
        mock_response.json.return_value = {
            'invalid_field': 'value',
            'name': 'Test Agent',
        }
        mock_httpx_client.get.return_value = mock_response

        resolver = A2ACardResolver(
            httpx_client=mock_httpx_client, base_url=self.BASE_URL
        )
        with pytest.raises(A2AClientJSONError) as exc_info:
            await resolver.get_agent_card()

        assert (
            f'Failed to validate agent card structure from {self.FULL_AGENT_CARD_URL}'
            in str(exc_info.value)
        )
        assert 'invalid_field' in str(exc_info.value)
        assert mock_httpx_client.get.call_count == 1

    @pytest.mark.asyncio
    async def test_get_agent_card_http_status_error(
        self, mock_httpx_client: AsyncMock
    ):
        mock_response = MagicMock(spec=httpx.Response)
        mock_response.status_code = 404
        mock_response.text = 'Not Found'
        http_status_error = httpx.HTTPStatusError(
            'Not Found', request=MagicMock(), response=mock_response
        )
        mock_httpx_client.get.side_effect = http_status_error

        resolver = A2ACardResolver(
            httpx_client=mock_httpx_client,
            base_url=self.BASE_URL,
            agent_card_path=self.AGENT_CARD_PATH,
        )

        with pytest.raises(A2AClientHTTPError) as exc_info:
            await resolver.get_agent_card()

        assert exc_info.value.status_code == 404
        assert (
            f'Failed to fetch agent card from {self.FULL_AGENT_CARD_URL}'
            in str(exc_info.value)
        )
        assert 'Not Found' in str(exc_info.value)
        mock_httpx_client.get.assert_called_once_with(self.FULL_AGENT_CARD_URL)

    @pytest.mark.asyncio
    async def test_get_agent_card_json_decode_error(
        self, mock_httpx_client: AsyncMock
    ):
        mock_response = AsyncMock(spec=httpx.Response)
        mock_response.status_code = 200
        json_error = json.JSONDecodeError('Expecting value', 'doc', 0)
        mock_response.json.side_effect = json_error
        mock_httpx_client.get.return_value = mock_response

        resolver = A2ACardResolver(
            httpx_client=mock_httpx_client,
            base_url=self.BASE_URL,
            agent_card_path=self.AGENT_CARD_PATH,
        )

        with pytest.raises(A2AClientJSONError) as exc_info:
            await resolver.get_agent_card()

        assert (
            f'Failed to parse JSON for agent card from {self.FULL_AGENT_CARD_URL}'
            in str(exc_info.value)
        )
        assert 'Expecting value' in str(exc_info.value)
        mock_httpx_client.get.assert_called_once_with(self.FULL_AGENT_CARD_URL)

    @pytest.mark.asyncio
    async def test_get_agent_card_request_error(
        self, mock_httpx_client: AsyncMock
    ):
        request_error = httpx.RequestError('Network issue', request=MagicMock())
        mock_httpx_client.get.side_effect = request_error

        resolver = A2ACardResolver(
            httpx_client=mock_httpx_client,
            base_url=self.BASE_URL,
            agent_card_path=self.AGENT_CARD_PATH,
        )

        with pytest.raises(A2AClientHTTPError) as exc_info:
            await resolver.get_agent_card()

        assert exc_info.value.status_code == 503
        assert (
            f'Network communication error fetching agent card from {self.FULL_AGENT_CARD_URL}'
            in str(exc_info.value)
        )
        assert 'Network issue' in str(exc_info.value)
        mock_httpx_client.get.assert_called_once_with(self.FULL_AGENT_CARD_URL)


class TestJsonRpcTransport:
    AGENT_URL = 'http://agent.example.com/api'

    def test_init_with_agent_card(
        self, mock_httpx_client: AsyncMock, mock_agent_card: MagicMock
    ):
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client, agent_card=mock_agent_card
        )
        assert client.url == mock_agent_card.url
        assert client.httpx_client == mock_httpx_client

    def test_init_with_url(self, mock_httpx_client: AsyncMock):
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client, url=self.AGENT_URL
        )
        assert client.url == self.AGENT_URL
        assert client.httpx_client == mock_httpx_client

    def test_init_with_agent_card_and_url_prioritizes_url(
        self, mock_httpx_client: AsyncMock, mock_agent_card: MagicMock
    ):
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client,
            agent_card=mock_agent_card,
            url='http://otherurl.com',
        )
        assert client.url == 'http://otherurl.com'

    def test_init_raises_value_error_if_no_card_or_url(
        self, mock_httpx_client: AsyncMock
    ):
        with pytest.raises(ValueError) as exc_info:
            JsonRpcTransport(httpx_client=mock_httpx_client)
        assert 'Must provide either agent_card or url' in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_send_message_success(
        self, mock_httpx_client: AsyncMock, mock_agent_card: MagicMock
    ):
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client, agent_card=mock_agent_card
        )
        params = MessageSendParams(
            message=create_text_message_object(content='Hello')
        )
        success_response = create_text_message_object(
            role=Role.agent, content='Hi there!'
        )
        rpc_response = SendMessageSuccessResponse(
            id='123', jsonrpc='2.0', result=success_response
        )
        response = httpx.Response(
            200, json=rpc_response.model_dump(mode='json')
        )
        response.request = httpx.Request('POST', 'http://agent.example.com/api')
        mock_httpx_client.post.return_value = response

        response = await client.send_message(request=params)

        assert isinstance(response, Message)
        assert response.model_dump() == success_response.model_dump()

    @pytest.mark.asyncio
    async def test_send_message_error_response(
        self, mock_httpx_client: AsyncMock, mock_agent_card: MagicMock
    ):
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client, agent_card=mock_agent_card
        )
        params = MessageSendParams(
            message=create_text_message_object(content='Hello')
        )
        error_response = InvalidParamsError()
        rpc_response = {
            'id': '123',
            'jsonrpc': '2.0',
            'error': error_response.model_dump(exclude_none=True),
        }
        mock_httpx_client.post.return_value.json.return_value = rpc_response

        with pytest.raises(Exception):
            await client.send_message(request=params)

    @pytest.mark.asyncio
    @patch('a2a.client.transports.jsonrpc.aconnect_sse')
    async def test_send_message_streaming_success(
        self,
        mock_aconnect_sse: AsyncMock,
        mock_httpx_client: AsyncMock,
        mock_agent_card: MagicMock,
    ):
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client, agent_card=mock_agent_card
        )
        params = MessageSendParams(
            message=create_text_message_object(content='Hello stream')
        )
        mock_stream_response_1 = SendMessageSuccessResponse(
            id='stream_id_123',
            jsonrpc='2.0',
            result=create_text_message_object(
                content='First part ', role=Role.agent
            ),
        )
        mock_stream_response_2 = SendMessageSuccessResponse(
            id='stream_id_123',
            jsonrpc='2.0',
            result=create_text_message_object(
                content='second part ', role=Role.agent
            ),
        )
        sse_event_1 = ServerSentEvent(
            data=mock_stream_response_1.model_dump_json()
        )
        sse_event_2 = ServerSentEvent(
            data=mock_stream_response_2.model_dump_json()
        )
        mock_event_source = AsyncMock(spec=EventSource)
        mock_event_source.aiter_sse.return_value = async_iterable_from_list(
            [sse_event_1, sse_event_2]
        )
        mock_aconnect_sse.return_value.__aenter__.return_value = (
            mock_event_source
        )

        results = [
            item async for item in client.send_message_streaming(request=params)
        ]

        assert len(results) == 2
        assert isinstance(results[0], Message)
        assert (
            results[0].model_dump()
            == mock_stream_response_1.result.model_dump()
        )
        assert isinstance(results[1], Message)
        assert (
            results[1].model_dump()
            == mock_stream_response_2.result.model_dump()
        )

    @pytest.mark.asyncio
    async def test_send_request_http_status_error(
        self, mock_httpx_client: AsyncMock, mock_agent_card: MagicMock
    ):
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client, agent_card=mock_agent_card
        )
        mock_response = MagicMock(spec=httpx.Response)
        mock_response.status_code = 404
        mock_response.text = 'Not Found'
        http_error = httpx.HTTPStatusError(
            'Not Found', request=MagicMock(), response=mock_response
        )
        mock_httpx_client.post.side_effect = http_error

        with pytest.raises(A2AClientHTTPError) as exc_info:
            await client._send_request({}, {})

        assert exc_info.value.status_code == 404
        assert 'Not Found' in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_send_request_json_decode_error(
        self, mock_httpx_client: AsyncMock, mock_agent_card: MagicMock
    ):
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client, agent_card=mock_agent_card
        )
        mock_response = AsyncMock(spec=httpx.Response)
        mock_response.status_code = 200
        json_error = json.JSONDecodeError('Expecting value', 'doc', 0)
        mock_response.json.side_effect = json_error
        mock_httpx_client.post.return_value = mock_response

        with pytest.raises(A2AClientJSONError) as exc_info:
            await client._send_request({}, {})

        assert 'Expecting value' in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_send_request_httpx_request_error(
        self, mock_httpx_client: AsyncMock, mock_agent_card: MagicMock
    ):
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client, agent_card=mock_agent_card
        )
        request_error = httpx.RequestError('Network issue', request=MagicMock())
        mock_httpx_client.post.side_effect = request_error

        with pytest.raises(A2AClientHTTPError) as exc_info:
            await client._send_request({}, {})

        assert exc_info.value.status_code == 503
        assert 'Network communication error' in str(exc_info.value)
        assert 'Network issue' in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_send_message_client_timeout(
        self, mock_httpx_client: AsyncMock, mock_agent_card: MagicMock
    ):
        mock_httpx_client.post.side_effect = httpx.ReadTimeout(
            'Request timed out'
        )
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client, agent_card=mock_agent_card
        )
        params = MessageSendParams(
            message=create_text_message_object(content='Hello')
        )

        with pytest.raises(A2AClientTimeoutError) as exc_info:
            await client.send_message(request=params)

        assert 'Client Request timed out' in str(exc_info.value)

    @pytest.mark.asyncio
    async def test_get_task_success(
        self, mock_httpx_client: AsyncMock, mock_agent_card: MagicMock
    ):
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client, agent_card=mock_agent_card
        )
        params = TaskQueryParams(id='task-abc')
        rpc_response = {
            'id': '123',
            'jsonrpc': '2.0',
            'result': MINIMAL_TASK,
        }
        with patch.object(
            client, '_send_request', new_callable=AsyncMock
        ) as mock_send_request:
            mock_send_request.return_value = rpc_response
            response = await client.get_task(request=params)

        assert isinstance(response, Task)
        assert (
            response.model_dump()
            == Task.model_validate(MINIMAL_TASK).model_dump()
        )
        mock_send_request.assert_called_once()
        sent_payload = mock_send_request.call_args.args[0]
        assert sent_payload['method'] == 'tasks/get'

    @pytest.mark.asyncio
    async def test_cancel_task_success(
        self, mock_httpx_client: AsyncMock, mock_agent_card: MagicMock
    ):
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client, agent_card=mock_agent_card
        )
        params = TaskIdParams(id='task-abc')
        rpc_response = {
            'id': '123',
            'jsonrpc': '2.0',
            'result': MINIMAL_CANCELLED_TASK,
        }
        with patch.object(
            client, '_send_request', new_callable=AsyncMock
        ) as mock_send_request:
            mock_send_request.return_value = rpc_response
            response = await client.cancel_task(request=params)

        assert isinstance(response, Task)
        assert (
            response.model_dump()
            == Task.model_validate(MINIMAL_CANCELLED_TASK).model_dump()
        )
        mock_send_request.assert_called_once()
        sent_payload = mock_send_request.call_args.args[0]
        assert sent_payload['method'] == 'tasks/cancel'

    @pytest.mark.asyncio
    async def test_set_task_callback_success(
        self, mock_httpx_client: AsyncMock, mock_agent_card: MagicMock
    ):
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client, agent_card=mock_agent_card
        )
        params = TaskPushNotificationConfig(
            task_id='task-abc',
            push_notification_config=PushNotificationConfig(
                url='http://callback.com'
            ),
        )
        rpc_response = {
            'id': '123',
            'jsonrpc': '2.0',
            'result': params.model_dump(mode='json'),
        }
        with patch.object(
            client, '_send_request', new_callable=AsyncMock
        ) as mock_send_request:
            mock_send_request.return_value = rpc_response
            response = await client.set_task_callback(request=params)

        assert isinstance(response, TaskPushNotificationConfig)
        assert response.model_dump() == params.model_dump()
        mock_send_request.assert_called_once()
        sent_payload = mock_send_request.call_args.args[0]
        assert sent_payload['method'] == 'tasks/pushNotificationConfig/set'

    @pytest.mark.asyncio
    async def test_get_task_callback_success(
        self, mock_httpx_client: AsyncMock, mock_agent_card: MagicMock
    ):
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client, agent_card=mock_agent_card
        )
        params = TaskIdParams(id='task-abc')
        expected_response = TaskPushNotificationConfig(
            task_id='task-abc',
            push_notification_config=PushNotificationConfig(
                url='http://callback.com'
            ),
        )
        rpc_response = {
            'id': '123',
            'jsonrpc': '2.0',
            'result': expected_response.model_dump(mode='json'),
        }
        with patch.object(
            client, '_send_request', new_callable=AsyncMock
        ) as mock_send_request:
            mock_send_request.return_value = rpc_response
            response = await client.get_task_callback(request=params)

        assert isinstance(response, TaskPushNotificationConfig)
        assert response.model_dump() == expected_response.model_dump()
        mock_send_request.assert_called_once()
        sent_payload = mock_send_request.call_args.args[0]
        assert sent_payload['method'] == 'tasks/pushNotificationConfig/get'

    @pytest.mark.asyncio
    @patch('a2a.client.transports.jsonrpc.aconnect_sse')
    async def test_send_message_streaming_sse_error(
        self,
        mock_aconnect_sse: AsyncMock,
        mock_httpx_client: AsyncMock,
        mock_agent_card: MagicMock,
    ):
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client, agent_card=mock_agent_card
        )
        params = MessageSendParams(
            message=create_text_message_object(content='Hello stream')
        )
        mock_event_source = AsyncMock(spec=EventSource)
        mock_event_source.aiter_sse.side_effect = SSEError(
            'Simulated SSE error'
        )
        mock_aconnect_sse.return_value.__aenter__.return_value = (
            mock_event_source
        )

        with pytest.raises(A2AClientHTTPError):
            _ = [
                item
                async for item in client.send_message_streaming(request=params)
            ]

    @pytest.mark.asyncio
    @patch('a2a.client.transports.jsonrpc.aconnect_sse')
    async def test_send_message_streaming_json_error(
        self,
        mock_aconnect_sse: AsyncMock,
        mock_httpx_client: AsyncMock,
        mock_agent_card: MagicMock,
    ):
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client, agent_card=mock_agent_card
        )
        params = MessageSendParams(
            message=create_text_message_object(content='Hello stream')
        )
        sse_event = ServerSentEvent(data='{invalid json')
        mock_event_source = AsyncMock(spec=EventSource)
        mock_event_source.aiter_sse.return_value = async_iterable_from_list(
            [sse_event]
        )
        mock_aconnect_sse.return_value.__aenter__.return_value = (
            mock_event_source
        )

        with pytest.raises(A2AClientJSONError):
            _ = [
                item
                async for item in client.send_message_streaming(request=params)
            ]

    @pytest.mark.asyncio
    @patch('a2a.client.transports.jsonrpc.aconnect_sse')
    async def test_send_message_streaming_request_error(
        self,
        mock_aconnect_sse: AsyncMock,
        mock_httpx_client: AsyncMock,
        mock_agent_card: MagicMock,
    ):
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client, agent_card=mock_agent_card
        )
        params = MessageSendParams(
            message=create_text_message_object(content='Hello stream')
        )
        mock_event_source = AsyncMock(spec=EventSource)
        mock_event_source.aiter_sse.side_effect = httpx.RequestError(
            'Simulated request error', request=MagicMock()
        )
        mock_aconnect_sse.return_value.__aenter__.return_value = (
            mock_event_source
        )

        with pytest.raises(A2AClientHTTPError):
            _ = [
                item
                async for item in client.send_message_streaming(request=params)
            ]

    @pytest.mark.asyncio
    async def test_get_card_no_card_provided(
        self, mock_httpx_client: AsyncMock
    ):
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client, url=self.AGENT_URL
        )
        mock_response = AsyncMock(spec=httpx.Response)
        mock_response.status_code = 200
        mock_response.json.return_value = AGENT_CARD.model_dump(mode='json')
        mock_httpx_client.get.return_value = mock_response

        card = await client.get_card()

        assert card == AGENT_CARD
        mock_httpx_client.get.assert_called_once()

    @pytest.mark.asyncio
    async def test_get_card_with_extended_card_support(
        self, mock_httpx_client: AsyncMock
    ):
        agent_card = AGENT_CARD.model_copy(
            update={'supports_authenticated_extended_card': True}
        )
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client, agent_card=agent_card
        )

        rpc_response = {
            'id': '123',
            'jsonrpc': '2.0',
            'result': AGENT_CARD_EXTENDED.model_dump(mode='json'),
        }
        with patch.object(
            client, '_send_request', new_callable=AsyncMock
        ) as mock_send_request:
            mock_send_request.return_value = rpc_response
            card = await client.get_card()

        assert card == agent_card
        mock_send_request.assert_called_once()
        sent_payload = mock_send_request.call_args.args[0]
        assert sent_payload['method'] == 'agent/getAuthenticatedExtendedCard'

    @pytest.mark.asyncio
    async def test_close(self, mock_httpx_client: AsyncMock):
        client = JsonRpcTransport(
            httpx_client=mock_httpx_client, url=self.AGENT_URL
        )
        await client.close()
        mock_httpx_client.aclose.assert_called_once()



---
File: /a2a-python/tests/client/test_legacy_client.py
---

"""Tests for the legacy client compatibility layer."""

from unittest.mock import AsyncMock, MagicMock

import httpx
import pytest

from a2a.client import A2AClient, A2AGrpcClient
from a2a.types import (
    AgentCapabilities,
    AgentCard,
    Message,
    MessageSendParams,
    Part,
    Role,
    SendMessageRequest,
    Task,
    TaskQueryParams,
    TaskState,
    TaskStatus,
    TextPart,
)


@pytest.fixture
def mock_httpx_client() -> AsyncMock:
    return AsyncMock(spec=httpx.AsyncClient)


@pytest.fixture
def mock_grpc_stub() -> AsyncMock:
    stub = AsyncMock()
    stub._channel = MagicMock()
    return stub


@pytest.fixture
def jsonrpc_agent_card() -> AgentCard:
    return AgentCard(
        name='Test Agent',
        description='A test agent',
        url='http://test.agent.com/rpc',
        version='1.0.0',
        capabilities=AgentCapabilities(streaming=True),
        skills=[],
        default_input_modes=[],
        default_output_modes=[],
        preferred_transport='jsonrpc',
    )


@pytest.fixture
def grpc_agent_card() -> AgentCard:
    return AgentCard(
        name='Test Agent',
        description='A test agent',
        url='http://test.agent.com/rpc',
        version='1.0.0',
        capabilities=AgentCapabilities(streaming=True),
        skills=[],
        default_input_modes=[],
        default_output_modes=[],
        preferred_transport='grpc',
    )


@pytest.mark.asyncio
async def test_a2a_client_send_message(
    mock_httpx_client: AsyncMock, jsonrpc_agent_card: AgentCard
):
    client = A2AClient(
        httpx_client=mock_httpx_client, agent_card=jsonrpc_agent_card
    )

    # Mock the underlying transport's send_message method
    mock_response_task = Task(
        id='task-123',
        context_id='ctx-456',
        status=TaskStatus(state=TaskState.completed),
    )

    client._transport.send_message = AsyncMock(return_value=mock_response_task)

    message = Message(
        message_id='msg-123',
        role=Role.user,
        parts=[Part(root=TextPart(text='Hello'))],
    )
    request = SendMessageRequest(
        id='req-123', params=MessageSendParams(message=message)
    )
    response = await client.send_message(request)

    assert response.root.result.id == 'task-123'


@pytest.mark.asyncio
async def test_a2a_grpc_client_get_task(
    mock_grpc_stub: AsyncMock, grpc_agent_card: AgentCard
):
    client = A2AGrpcClient(grpc_stub=mock_grpc_stub, agent_card=grpc_agent_card)

    mock_response_task = Task(
        id='task-456',
        context_id='ctx-789',
        status=TaskStatus(state=TaskState.working),
    )

    client.get_task = AsyncMock(return_value=mock_response_task)

    params = TaskQueryParams(id='task-456')
    response = await client.get_task(params)

    assert response.id == 'task-456'
    client.get_task.assert_awaited_once_with(params)



---
File: /a2a-python/tests/client/test_optionals.py
---

"""Tests for a2a.client.optionals module."""

import importlib
import sys

from unittest.mock import patch


def test_channel_import_failure():
    """Test Channel behavior when grpc is not available."""
    with patch.dict('sys.modules', {'grpc': None, 'grpc.aio': None}):
        if 'a2a.client.optionals' in sys.modules:
            del sys.modules['a2a.client.optionals']

        optionals = importlib.import_module('a2a.client.optionals')
        assert optionals.Channel is None



---
File: /a2a-python/tests/extensions/test_common.py
---

from a2a.extensions.common import (
    find_extension_by_uri,
    get_requested_extensions,
)
from a2a.types import AgentCapabilities, AgentCard, AgentExtension


def test_get_requested_extensions():
    assert get_requested_extensions([]) == set()
    assert get_requested_extensions(['foo']) == {'foo'}
    assert get_requested_extensions(['foo', 'bar']) == {'foo', 'bar'}
    assert get_requested_extensions(['foo, bar']) == {'foo', 'bar'}
    assert get_requested_extensions(['foo,bar']) == {'foo', 'bar'}
    assert get_requested_extensions(['foo', 'bar,baz']) == {'foo', 'bar', 'baz'}
    assert get_requested_extensions(['foo,, bar', 'baz']) == {
        'foo',
        'bar',
        'baz',
    }
    assert get_requested_extensions([' foo , bar ', 'baz']) == {
        'foo',
        'bar',
        'baz',
    }


def test_find_extension_by_uri():
    ext1 = AgentExtension(uri='foo', description='The Foo extension')
    ext2 = AgentExtension(uri='bar', description='The Bar extension')
    card = AgentCard(
        name='Test Agent',
        description='Test Agent Description',
        version='1.0',
        url='http://test.com',
        skills=[],
        default_input_modes=['text/plain'],
        default_output_modes=['text/plain'],
        capabilities=AgentCapabilities(extensions=[ext1, ext2]),
    )

    assert find_extension_by_uri(card, 'foo') == ext1
    assert find_extension_by_uri(card, 'bar') == ext2
    assert find_extension_by_uri(card, 'baz') is None


def test_find_extension_by_uri_no_extensions():
    card = AgentCard(
        name='Test Agent',
        description='Test Agent Description',
        version='1.0',
        url='http://test.com',
        skills=[],
        default_input_modes=['text/plain'],
        default_output_modes=['text/plain'],
        capabilities=AgentCapabilities(extensions=None),
    )

    assert find_extension_by_uri(card, 'foo') is None



---
File: /a2a-python/tests/integration/test_client_server_integration.py
---

import asyncio
from collections.abc import AsyncGenerator
from typing import NamedTuple
from unittest.mock import ANY, AsyncMock

import grpc
import httpx
import pytest
import pytest_asyncio
from grpc.aio import Channel

from a2a.client.transports import JsonRpcTransport, RestTransport
from a2a.client.transports.base import ClientTransport
from a2a.client.transports.grpc import GrpcTransport
from a2a.grpc import a2a_pb2_grpc
from a2a.server.apps import A2AFastAPIApplication, A2ARESTFastAPIApplication
from a2a.server.request_handlers import GrpcHandler, RequestHandler
from a2a.types import (
    AgentCapabilities,
    AgentCard,
    AgentInterface,
    GetTaskPushNotificationConfigParams,
    Message,
    MessageSendParams,
    Part,
    PushNotificationConfig,
    Role,
    Task,
    TaskIdParams,
    TaskPushNotificationConfig,
    TaskQueryParams,
    TaskState,
    TaskStatus,
    TaskStatusUpdateEvent,
    TextPart,
    TransportProtocol,
)

# --- Test Constants ---

TASK_FROM_STREAM = Task(
    id='task-123-stream',
    context_id='ctx-456-stream',
    status=TaskStatus(state=TaskState.completed),
    kind='task',
)

TASK_FROM_BLOCKING = Task(
    id='task-789-blocking',
    context_id='ctx-101-blocking',
    status=TaskStatus(state=TaskState.completed),
    kind='task',
)

GET_TASK_RESPONSE = Task(
    id='task-get-456',
    context_id='ctx-get-789',
    status=TaskStatus(state=TaskState.working),
    kind='task',
)

CANCEL_TASK_RESPONSE = Task(
    id='task-cancel-789',
    context_id='ctx-cancel-101',
    status=TaskStatus(state=TaskState.canceled),
    kind='task',
)

CALLBACK_CONFIG = TaskPushNotificationConfig(
    task_id='task-callback-123',
    push_notification_config=PushNotificationConfig(
        id='pnc-abc', url='http://callback.example.com', token=''
    ),
)

RESUBSCRIBE_EVENT = TaskStatusUpdateEvent(
    task_id='task-resub-456',
    context_id='ctx-resub-789',
    status=TaskStatus(state=TaskState.working),
    final=False,
)


# --- Test Fixtures ---


@pytest.fixture
def mock_request_handler() -> AsyncMock:
    """Provides a mock RequestHandler for the server-side handlers."""
    handler = AsyncMock(spec=RequestHandler)

    # Configure on_message_send for non-streaming calls
    handler.on_message_send.return_value = TASK_FROM_BLOCKING

    # Configure on_message_send_stream for streaming calls
    async def stream_side_effect(*args, **kwargs):
        yield TASK_FROM_STREAM

    handler.on_message_send_stream.side_effect = stream_side_effect

    # Configure other methods
    handler.on_get_task.return_value = GET_TASK_RESPONSE
    handler.on_cancel_task.return_value = CANCEL_TASK_RESPONSE
    handler.on_set_task_push_notification_config.side_effect = (
        lambda params, context: params
    )
    handler.on_get_task_push_notification_config.return_value = CALLBACK_CONFIG

    async def resubscribe_side_effect(*args, **kwargs):
        yield RESUBSCRIBE_EVENT

    handler.on_resubscribe_to_task.side_effect = resubscribe_side_effect

    return handler


@pytest.fixture
def agent_card() -> AgentCard:
    """Provides a sample AgentCard for tests."""
    return AgentCard(
        name='Test Agent',
        description='An agent for integration testing.',
        url='http://testserver',
        version='1.0.0',
        capabilities=AgentCapabilities(streaming=True, push_notifications=True),
        skills=[],
        default_input_modes=['text/plain'],
        default_output_modes=['text/plain'],
        preferred_transport=TransportProtocol.jsonrpc,
        supports_authenticated_extended_card=False,
        additional_interfaces=[
            AgentInterface(
                transport=TransportProtocol.http_json, url='http://testserver'
            ),
            AgentInterface(
                transport=TransportProtocol.grpc, url='localhost:50051'
            ),
        ],
    )


class TransportSetup(NamedTuple):
    """Holds the transport and handler for a given test."""

    transport: ClientTransport
    handler: AsyncMock


# --- HTTP/JSON-RPC/REST Setup ---


@pytest.fixture
def http_base_setup(mock_request_handler: AsyncMock, agent_card: AgentCard):
    """A base fixture to patch the sse-starlette event loop issue."""
    from sse_starlette import sse

    sse.AppStatus.should_exit_event = asyncio.Event()
    yield mock_request_handler, agent_card


@pytest.fixture
def jsonrpc_setup(http_base_setup) -> TransportSetup:
    """Sets up the JsonRpcTransport and in-memory server."""
    mock_request_handler, agent_card = http_base_setup
    app_builder = A2AFastAPIApplication(
        agent_card, mock_request_handler, extended_agent_card=agent_card
    )
    app = app_builder.build()
    httpx_client = httpx.AsyncClient(transport=httpx.ASGITransport(app=app))
    transport = JsonRpcTransport(
        httpx_client=httpx_client, agent_card=agent_card
    )
    return TransportSetup(transport=transport, handler=mock_request_handler)


@pytest.fixture
def rest_setup(http_base_setup) -> TransportSetup:
    """Sets up the RestTransport and in-memory server."""
    mock_request_handler, agent_card = http_base_setup
    app_builder = A2ARESTFastAPIApplication(agent_card, mock_request_handler)
    app = app_builder.build()
    httpx_client = httpx.AsyncClient(transport=httpx.ASGITransport(app=app))
    transport = RestTransport(httpx_client=httpx_client, agent_card=agent_card)
    return TransportSetup(transport=transport, handler=mock_request_handler)


# --- gRPC Setup ---


@pytest_asyncio.fixture
async def grpc_server_and_handler(
    mock_request_handler: AsyncMock, agent_card: AgentCard
) -> AsyncGenerator[tuple[str, AsyncMock], None]:
    """Creates and manages an in-process gRPC test server."""
    server = grpc.aio.server()
    port = server.add_insecure_port('[::]:0')
    server_address = f'localhost:{port}'
    servicer = GrpcHandler(agent_card, mock_request_handler)
    a2a_pb2_grpc.add_A2AServiceServicer_to_server(servicer, server)
    await server.start()
    yield server_address, mock_request_handler
    await server.stop(0)


# --- The Integration Tests ---


@pytest.mark.asyncio
@pytest.mark.parametrize(
    'transport_setup_fixture',
    [
        pytest.param('jsonrpc_setup', id='JSON-RPC'),
        pytest.param('rest_setup', id='REST'),
    ],
)
async def test_http_transport_sends_message_streaming(
    transport_setup_fixture: str, request
) -> None:
    """
    Integration test for HTTP-based transports (JSON-RPC, REST) streaming.
    """
    transport_setup: TransportSetup = request.getfixturevalue(
        transport_setup_fixture
    )
    transport = transport_setup.transport
    handler = transport_setup.handler

    message_to_send = Message(
        role=Role.user,
        message_id='msg-integration-test',
        parts=[Part(root=TextPart(text='Hello, integration test!'))],
    )
    params = MessageSendParams(message=message_to_send)

    stream = transport.send_message_streaming(request=params)
    first_event = await anext(stream)

    assert first_event.id == TASK_FROM_STREAM.id
    assert first_event.context_id == TASK_FROM_STREAM.context_id

    handler.on_message_send_stream.assert_called_once()
    call_args, _ = handler.on_message_send_stream.call_args
    received_params: MessageSendParams = call_args[0]

    assert received_params.message.message_id == message_to_send.message_id
    assert (
        received_params.message.parts[0].root.text
        == message_to_send.parts[0].root.text
    )

    if hasattr(transport, 'close'):
        await transport.close()


@pytest.mark.asyncio
async def test_grpc_transport_sends_message_streaming(
    grpc_server_and_handler: tuple[str, AsyncMock],
    agent_card: AgentCard,
) -> None:
    """
    Integration test specifically for the gRPC transport streaming.
    """
    server_address, handler = grpc_server_and_handler
    agent_card.url = server_address

    def channel_factory(address: str) -> Channel:
        return grpc.aio.insecure_channel(address)

    channel = channel_factory(server_address)
    transport = GrpcTransport(channel=channel, agent_card=agent_card)

    message_to_send = Message(
        role=Role.user,
        message_id='msg-grpc-integration-test',
        parts=[Part(root=TextPart(text='Hello, gRPC integration test!'))],
    )
    params = MessageSendParams(message=message_to_send)

    stream = transport.send_message_streaming(request=params)
    first_event = await anext(stream)

    assert first_event.id == TASK_FROM_STREAM.id
    assert first_event.context_id == TASK_FROM_STREAM.context_id

    handler.on_message_send_stream.assert_called_once()
    call_args, _ = handler.on_message_send_stream.call_args
    received_params: MessageSendParams = call_args[0]

    assert received_params.message.message_id == message_to_send.message_id
    assert (
        received_params.message.parts[0].root.text
        == message_to_send.parts[0].root.text
    )

    await transport.close()


@pytest.mark.asyncio
@pytest.mark.parametrize(
    'transport_setup_fixture',
    [
        pytest.param('jsonrpc_setup', id='JSON-RPC'),
        pytest.param('rest_setup', id='REST'),
    ],
)
async def test_http_transport_sends_message_blocking(
    transport_setup_fixture: str, request
) -> None:
    """
    Integration test for HTTP-based transports (JSON-RPC, REST) blocking.
    """
    transport_setup: TransportSetup = request.getfixturevalue(
        transport_setup_fixture
    )
    transport = transport_setup.transport
    handler = transport_setup.handler

    message_to_send = Message(
        role=Role.user,
        message_id='msg-integration-test-blocking',
        parts=[Part(root=TextPart(text='Hello, blocking test!'))],
    )
    params = MessageSendParams(message=message_to_send)

    result = await transport.send_message(request=params)

    assert result.id == TASK_FROM_BLOCKING.id
    assert result.context_id == TASK_FROM_BLOCKING.context_id

    handler.on_message_send.assert_awaited_once()
    call_args, _ = handler.on_message_send.call_args
    received_params: MessageSendParams = call_args[0]

    assert received_params.message.message_id == message_to_send.message_id
    assert (
        received_params.message.parts[0].root.text
        == message_to_send.parts[0].root.text
    )

    if hasattr(transport, 'close'):
        await transport.close()


@pytest.mark.asyncio
async def test_grpc_transport_sends_message_blocking(
    grpc_server_and_handler: tuple[str, AsyncMock],
    agent_card: AgentCard,
) -> None:
    """
    Integration test specifically for the gRPC transport blocking.
    """
    server_address, handler = grpc_server_and_handler
    agent_card.url = server_address

    def channel_factory(address: str) -> Channel:
        return grpc.aio.insecure_channel(address)

    channel = channel_factory(server_address)
    transport = GrpcTransport(channel=channel, agent_card=agent_card)

    message_to_send = Message(
        role=Role.user,
        message_id='msg-grpc-integration-test-blocking',
        parts=[Part(root=TextPart(text='Hello, gRPC blocking test!'))],
    )
    params = MessageSendParams(message=message_to_send)

    result = await transport.send_message(request=params)

    assert result.id == TASK_FROM_BLOCKING.id
    assert result.context_id == TASK_FROM_BLOCKING.context_id

    handler.on_message_send.assert_awaited_once()
    call_args, _ = handler.on_message_send.call_args
    received_params: MessageSendParams = call_args[0]

    assert received_params.message.message_id == message_to_send.message_id
    assert (
        received_params.message.parts[0].root.text
        == message_to_send.parts[0].root.text
    )

    await transport.close()


@pytest.mark.asyncio
@pytest.mark.parametrize(
    'transport_setup_fixture',
    [
        pytest.param('jsonrpc_setup', id='JSON-RPC'),
        pytest.param('rest_setup', id='REST'),
    ],
)
async def test_http_transport_get_task(
    transport_setup_fixture: str, request
) -> None:
    transport_setup: TransportSetup = request.getfixturevalue(
        transport_setup_fixture
    )
    transport = transport_setup.transport
    handler = transport_setup.handler

    params = TaskQueryParams(id=GET_TASK_RESPONSE.id)
    result = await transport.get_task(request=params)

    assert result.id == GET_TASK_RESPONSE.id
    handler.on_get_task.assert_awaited_once_with(params, ANY)

    if hasattr(transport, 'close'):
        await transport.close()


@pytest.mark.asyncio
async def test_grpc_transport_get_task(
    grpc_server_and_handler: tuple[str, AsyncMock],
    agent_card: AgentCard,
) -> None:
    server_address, handler = grpc_server_and_handler
    agent_card.url = server_address

    def channel_factory(address: str) -> Channel:
        return grpc.aio.insecure_channel(address)

    channel = channel_factory(server_address)
    transport = GrpcTransport(channel=channel, agent_card=agent_card)

    params = TaskQueryParams(id=GET_TASK_RESPONSE.id)
    result = await transport.get_task(request=params)

    assert result.id == GET_TASK_RESPONSE.id
    handler.on_get_task.assert_awaited_once()
    assert handler.on_get_task.call_args[0][0].id == GET_TASK_RESPONSE.id

    await transport.close()


@pytest.mark.asyncio
@pytest.mark.parametrize(
    'transport_setup_fixture',
    [
        pytest.param('jsonrpc_setup', id='JSON-RPC'),
        pytest.param('rest_setup', id='REST'),
    ],
)
async def test_http_transport_cancel_task(
    transport_setup_fixture: str, request
) -> None:
    transport_setup: TransportSetup = request.getfixturevalue(
        transport_setup_fixture
    )
    transport = transport_setup.transport
    handler = transport_setup.handler

    params = TaskIdParams(id=CANCEL_TASK_RESPONSE.id)
    result = await transport.cancel_task(request=params)

    assert result.id == CANCEL_TASK_RESPONSE.id
    handler.on_cancel_task.assert_awaited_once_with(params, ANY)

    if hasattr(transport, 'close'):
        await transport.close()


@pytest.mark.asyncio
async def test_grpc_transport_cancel_task(
    grpc_server_and_handler: tuple[str, AsyncMock],
    agent_card: AgentCard,
) -> None:
    server_address, handler = grpc_server_and_handler
    agent_card.url = server_address

    def channel_factory(address: str) -> Channel:
        return grpc.aio.insecure_channel(address)

    channel = channel_factory(server_address)
    transport = GrpcTransport(channel=channel, agent_card=agent_card)

    params = TaskIdParams(id=CANCEL_TASK_RESPONSE.id)
    result = await transport.cancel_task(request=params)

    assert result.id == CANCEL_TASK_RESPONSE.id
    handler.on_cancel_task.assert_awaited_once()
    assert handler.on_cancel_task.call_args[0][0].id == CANCEL_TASK_RESPONSE.id

    await transport.close()


@pytest.mark.asyncio
@pytest.mark.parametrize(
    'transport_setup_fixture',
    [
        pytest.param('jsonrpc_setup', id='JSON-RPC'),
        pytest.param('rest_setup', id='REST'),
    ],
)
async def test_http_transport_set_task_callback(
    transport_setup_fixture: str, request
) -> None:
    transport_setup: TransportSetup = request.getfixturevalue(
        transport_setup_fixture
    )
    transport = transport_setup.transport
    handler = transport_setup.handler

    params = CALLBACK_CONFIG
    result = await transport.set_task_callback(request=params)

    assert result.task_id == CALLBACK_CONFIG.task_id
    assert (
        result.push_notification_config.id
        == CALLBACK_CONFIG.push_notification_config.id
    )
    assert (
        result.push_notification_config.url
        == CALLBACK_CONFIG.push_notification_config.url
    )
    handler.on_set_task_push_notification_config.assert_awaited_once_with(
        params, ANY
    )

    if hasattr(transport, 'close'):
        await transport.close()


@pytest.mark.asyncio
async def test_grpc_transport_set_task_callback(
    grpc_server_and_handler: tuple[str, AsyncMock],
    agent_card: AgentCard,
) -> None:
    server_address, handler = grpc_server_and_handler
    agent_card.url = server_address

    def channel_factory(address: str) -> Channel:
        return grpc.aio.insecure_channel(address)

    channel = channel_factory(server_address)
    transport = GrpcTransport(channel=channel, agent_card=agent_card)

    params = CALLBACK_CONFIG
    result = await transport.set_task_callback(request=params)

    assert result.task_id == CALLBACK_CONFIG.task_id
    assert (
        result.push_notification_config.id
        == CALLBACK_CONFIG.push_notification_config.id
    )
    assert (
        result.push_notification_config.url
        == CALLBACK_CONFIG.push_notification_config.url
    )
    handler.on_set_task_push_notification_config.assert_awaited_once()
    assert (
        handler.on_set_task_push_notification_config.call_args[0][0].task_id
        == CALLBACK_CONFIG.task_id
    )

    await transport.close()


@pytest.mark.asyncio
@pytest.mark.parametrize(
    'transport_setup_fixture',
    [
        pytest.param('jsonrpc_setup', id='JSON-RPC'),
        pytest.param('rest_setup', id='REST'),
    ],
)
async def test_http_transport_get_task_callback(
    transport_setup_fixture: str, request
) -> None:
    transport_setup: TransportSetup = request.getfixturevalue(
        transport_setup_fixture
    )
    transport = transport_setup.transport
    handler = transport_setup.handler

    params = GetTaskPushNotificationConfigParams(
        id=CALLBACK_CONFIG.task_id,
        push_notification_config_id=CALLBACK_CONFIG.push_notification_config.id,
    )
    result = await transport.get_task_callback(request=params)

    assert result.task_id == CALLBACK_CONFIG.task_id
    assert (
        result.push_notification_config.id
        == CALLBACK_CONFIG.push_notification_config.id
    )
    assert (
        result.push_notification_config.url
        == CALLBACK_CONFIG.push_notification_config.url
    )
    handler.on_get_task_push_notification_config.assert_awaited_once_with(
        params, ANY
    )

    if hasattr(transport, 'close'):
        await transport.close()


@pytest.mark.asyncio
async def test_grpc_transport_get_task_callback(
    grpc_server_and_handler: tuple[str, AsyncMock],
    agent_card: AgentCard,
) -> None:
    server_address, handler = grpc_server_and_handler
    agent_card.url = server_address

    def channel_factory(address: str) -> Channel:
        return grpc.aio.insecure_channel(address)

    channel = channel_factory(server_address)
    transport = GrpcTransport(channel=channel, agent_card=agent_card)

    params = GetTaskPushNotificationConfigParams(
        id=CALLBACK_CONFIG.task_id,
        push_notification_config_id=CALLBACK_CONFIG.push_notification_config.id,
    )
    result = await transport.get_task_callback(request=params)

    assert result.task_id == CALLBACK_CONFIG.task_id
    assert (
        result.push_notification_config.id
        == CALLBACK_CONFIG.push_notification_config.id
    )
    assert (
        result.push_notification_config.url
        == CALLBACK_CONFIG.push_notification_config.url
    )
    handler.on_get_task_push_notification_config.assert_awaited_once()
    assert (
        handler.on_get_task_push_notification_config.call_args[0][0].id
        == CALLBACK_CONFIG.task_id
    )

    await transport.close()


@pytest.mark.asyncio
@pytest.mark.parametrize(
    'transport_setup_fixture',
    [
        pytest.param('jsonrpc_setup', id='JSON-RPC'),
        pytest.param('rest_setup', id='REST'),
    ],
)
async def test_http_transport_resubscribe(
    transport_setup_fixture: str, request
) -> None:
    transport_setup: TransportSetup = request.getfixturevalue(
        transport_setup_fixture
    )
    transport = transport_setup.transport
    handler = transport_setup.handler

    params = TaskIdParams(id=RESUBSCRIBE_EVENT.task_id)
    stream = transport.resubscribe(request=params)
    first_event = await anext(stream)

    assert first_event.task_id == RESUBSCRIBE_EVENT.task_id
    handler.on_resubscribe_to_task.assert_called_once_with(params, ANY)

    if hasattr(transport, 'close'):
        await transport.close()


@pytest.mark.asyncio
async def test_grpc_transport_resubscribe(
    grpc_server_and_handler: tuple[str, AsyncMock],
    agent_card: AgentCard,
) -> None:
    server_address, handler = grpc_server_and_handler
    agent_card.url = server_address

    def channel_factory(address: str) -> Channel:
        return grpc.aio.insecure_channel(address)

    channel = channel_factory(server_address)
    transport = GrpcTransport(channel=channel, agent_card=agent_card)

    params = TaskIdParams(id=RESUBSCRIBE_EVENT.task_id)
    stream = transport.resubscribe(request=params)
    first_event = await anext(stream)

    assert first_event.task_id == RESUBSCRIBE_EVENT.task_id
    handler.on_resubscribe_to_task.assert_called_once()
    assert (
        handler.on_resubscribe_to_task.call_args[0][0].id
        == RESUBSCRIBE_EVENT.task_id
    )

    await transport.close()


@pytest.mark.asyncio
@pytest.mark.parametrize(
    'transport_setup_fixture',
    [
        pytest.param('jsonrpc_setup', id='JSON-RPC'),
        pytest.param('rest_setup', id='REST'),
    ],
)
async def test_http_transport_get_card(
    transport_setup_fixture: str, request, agent_card: AgentCard
) -> None:
    transport_setup: TransportSetup = request.getfixturevalue(
        transport_setup_fixture
    )
    transport = transport_setup.transport
    # Get the base card.
    result = await transport.get_card()

    assert result.name == agent_card.name
    assert transport.agent_card.name == agent_card.name
    assert transport._needs_extended_card is False

    if hasattr(transport, 'close'):
        await transport.close()


@pytest.mark.asyncio
async def test_http_transport_get_authenticated_card(
    agent_card: AgentCard,
    mock_request_handler: AsyncMock,
) -> None:
    agent_card.supports_authenticated_extended_card = True
    extended_agent_card = agent_card.model_copy(deep=True)
    extended_agent_card.name = 'Extended Agent Card'

    app_builder = A2ARESTFastAPIApplication(
        agent_card,
        mock_request_handler,
        extended_agent_card=extended_agent_card,
    )
    app = app_builder.build()
    httpx_client = httpx.AsyncClient(transport=httpx.ASGITransport(app=app))

    transport = RestTransport(httpx_client=httpx_client, agent_card=agent_card)
    result = await transport.get_card()
    assert result.name == extended_agent_card.name
    assert transport.agent_card.name == extended_agent_card.name
    assert transport._needs_extended_card is False

    if hasattr(transport, 'close'):
        await transport.close()


@pytest.mark.asyncio
async def test_grpc_transport_get_card(
    grpc_server_and_handler: tuple[str, AsyncMock],
    agent_card: AgentCard,
) -> None:
    server_address, _ = grpc_server_and_handler
    agent_card.url = server_address

    def channel_factory(address: str) -> Channel:
        return grpc.aio.insecure_channel(address)

    channel = channel_factory(server_address)
    transport = GrpcTransport(channel=channel, agent_card=agent_card)

    # The transport starts with a minimal card, get_card() fetches the full one
    transport.agent_card.supports_authenticated_extended_card = True
    result = await transport.get_card()

    assert result.name == agent_card.name
    assert transport.agent_card.name == agent_card.name
    assert transport._needs_extended_card is False

    await transport.close()



---
File: /a2a-python/tests/server/agent_execution/test_context.py
---

import uuid

from unittest.mock import Mock, patch

import pytest

from a2a.server.agent_execution import RequestContext
from a2a.server.context import ServerCallContext
from a2a.types import (
    Message,
    MessageSendParams,
    Task,
)
from a2a.utils.errors import ServerError


class TestRequestContext:
    """Tests for the RequestContext class."""

    @pytest.fixture
    def mock_message(self):
        """Fixture for a mock Message."""
        return Mock(spec=Message, task_id=None, context_id=None)

    @pytest.fixture
    def mock_params(self, mock_message):
        """Fixture for a mock MessageSendParams."""
        return Mock(spec=MessageSendParams, message=mock_message)

    @pytest.fixture
    def mock_task(self):
        """Fixture for a mock Task."""
        return Mock(spec=Task, id='task-123', context_id='context-456')

    def test_init_without_params(self):
        """Test initialization without parameters."""
        context = RequestContext()
        assert context.message is None
        assert context.task_id is None
        assert context.context_id is None
        assert context.current_task is None
        assert context.related_tasks == []

    def test_init_with_params_no_ids(self, mock_params):
        """Test initialization with params but no task or context IDs."""
        with patch(
            'uuid.uuid4',
            side_effect=[
                uuid.UUID('00000000-0000-0000-0000-000000000001'),
                uuid.UUID('00000000-0000-0000-0000-000000000002'),
            ],
        ):
            context = RequestContext(request=mock_params)

        assert context.message == mock_params.message
        assert context.task_id == '00000000-0000-0000-0000-000000000001'
        assert (
            mock_params.message.task_id
            == '00000000-0000-0000-0000-000000000001'
        )
        assert context.context_id == '00000000-0000-0000-0000-000000000002'
        assert (
            mock_params.message.context_id
            == '00000000-0000-0000-0000-000000000002'
        )

    def test_init_with_task_id(self, mock_params):
        """Test initialization with task ID provided."""
        task_id = 'task-123'
        context = RequestContext(request=mock_params, task_id=task_id)

        assert context.task_id == task_id
        assert mock_params.message.task_id == task_id

    def test_init_with_context_id(self, mock_params):
        """Test initialization with context ID provided."""
        context_id = 'context-456'
        context = RequestContext(request=mock_params, context_id=context_id)

        assert context.context_id == context_id
        assert mock_params.message.context_id == context_id

    def test_init_with_both_ids(self, mock_params):
        """Test initialization with both task and context IDs provided."""
        task_id = 'task-123'
        context_id = 'context-456'
        context = RequestContext(
            request=mock_params, task_id=task_id, context_id=context_id
        )

        assert context.task_id == task_id
        assert mock_params.message.task_id == task_id
        assert context.context_id == context_id
        assert mock_params.message.context_id == context_id

    def test_init_with_task(self, mock_params, mock_task):
        """Test initialization with a task object."""
        context = RequestContext(request=mock_params, task=mock_task)

        assert context.current_task == mock_task

    def test_get_user_input_no_params(self):
        """Test get_user_input with no params returns empty string."""
        context = RequestContext()
        assert context.get_user_input() == ''

    def test_attach_related_task(self, mock_task):
        """Test attach_related_task adds a task to related_tasks."""
        context = RequestContext()
        assert len(context.related_tasks) == 0

        context.attach_related_task(mock_task)
        assert len(context.related_tasks) == 1
        assert context.related_tasks[0] == mock_task

        # Test adding multiple tasks
        another_task = Mock(spec=Task)
        context.attach_related_task(another_task)
        assert len(context.related_tasks) == 2
        assert context.related_tasks[1] == another_task

    def test_current_task_property(self, mock_task):
        """Test current_task getter and setter."""
        context = RequestContext()
        assert context.current_task is None

        context.current_task = mock_task
        assert context.current_task == mock_task

        # Change current task
        new_task = Mock(spec=Task)
        context.current_task = new_task
        assert context.current_task == new_task

    def test_check_or_generate_task_id_no_params(self):
        """Test _check_or_generate_task_id with no params does nothing."""
        context = RequestContext()
        context._check_or_generate_task_id()
        assert context.task_id is None

    def test_check_or_generate_task_id_with_existing_task_id(self, mock_params):
        """Test _check_or_generate_task_id with existing task ID."""
        existing_id = 'existing-task-id'
        mock_params.message.task_id = existing_id

        context = RequestContext(request=mock_params)
        # The method is called during initialization

        assert context.task_id == existing_id
        assert mock_params.message.task_id == existing_id

    def test_check_or_generate_context_id_no_params(self):
        """Test _check_or_generate_context_id with no params does nothing."""
        context = RequestContext()
        context._check_or_generate_context_id()
        assert context.context_id is None

    def test_check_or_generate_context_id_with_existing_context_id(
        self, mock_params
    ):
        """Test _check_or_generate_context_id with existing context ID."""
        existing_id = 'existing-context-id'
        mock_params.message.context_id = existing_id

        context = RequestContext(request=mock_params)
        # The method is called during initialization

        assert context.context_id == existing_id
        assert mock_params.message.context_id == existing_id

    def test_init_raises_error_on_task_id_mismatch(
        self, mock_params, mock_task
    ):
        """Test that an error is raised if provided task_id mismatches task.id."""
        with pytest.raises(ServerError) as exc_info:
            RequestContext(
                request=mock_params, task_id='wrong-task-id', task=mock_task
            )
        assert 'bad task id' in str(exc_info.value.error.message)

    def test_init_raises_error_on_context_id_mismatch(
        self, mock_params, mock_task
    ):
        """Test that an error is raised if provided context_id mismatches task.context_id."""
        # Set a valid task_id to avoid that error
        mock_params.message.task_id = mock_task.id

        with pytest.raises(ServerError) as exc_info:
            RequestContext(
                request=mock_params,
                task_id=mock_task.id,
                context_id='wrong-context-id',
                task=mock_task,
            )

        assert 'bad context id' in str(exc_info.value.error.message)

    def test_with_related_tasks_provided(self, mock_task):
        """Test initialization with related tasks provided."""
        related_tasks = [mock_task, Mock(spec=Task)]
        context = RequestContext(related_tasks=related_tasks)

        assert context.related_tasks == related_tasks
        assert len(context.related_tasks) == 2

    def test_message_property_without_params(self):
        """Test message property returns None when no params are provided."""
        context = RequestContext()
        assert context.message is None

    def test_message_property_with_params(self, mock_params):
        """Test message property returns the message from params."""
        context = RequestContext(request=mock_params)
        assert context.message == mock_params.message

    def test_metadata_property_without_content(self):
        """Test metadata property returns empty dict when no content are provided."""
        context = RequestContext()
        assert context.metadata == {}

    def test_metadata_property_with_content(self, mock_params):
        """Test metadata property returns the metadata from params."""
        mock_params.metadata = {'key': 'value'}
        context = RequestContext(request=mock_params)
        assert context.metadata == {'key': 'value'}

    def test_init_with_existing_ids_in_message(self, mock_message, mock_params):
        """Test initialization with existing IDs in the message."""
        mock_message.task_id = 'existing-task-id'
        mock_message.context_id = 'existing-context-id'

        context = RequestContext(request=mock_params)

        assert context.task_id == 'existing-task-id'
        assert context.context_id == 'existing-context-id'
        # No new UUIDs should be generated

    def test_init_with_task_id_and_existing_task_id_match(
        self, mock_params, mock_task
    ):
        """Test initialization succeeds when task_id matches task.id."""
        mock_params.message.task_id = mock_task.id

        context = RequestContext(
            request=mock_params, task_id=mock_task.id, task=mock_task
        )

        assert context.task_id == mock_task.id
        assert context.current_task == mock_task

    def test_init_with_context_id_and_existing_context_id_match(
        self, mock_params, mock_task
    ):
        """Test initialization succeeds when context_id matches task.context_id."""
        mock_params.message.task_id = mock_task.id  # Set matching task ID
        mock_params.message.context_id = mock_task.context_id

        context = RequestContext(
            request=mock_params,
            task_id=mock_task.id,
            context_id=mock_task.context_id,
            task=mock_task,
        )

        assert context.context_id == mock_task.context_id
        assert context.current_task == mock_task

    def test_extension_handling(self):
        """Test extension handling in RequestContext."""
        call_context = ServerCallContext(requested_extensions={'foo', 'bar'})
        context = RequestContext(call_context=call_context)

        assert context.requested_extensions == {'foo', 'bar'}

        context.add_activated_extension('foo')
        assert call_context.activated_extensions == {'foo'}

        context.add_activated_extension('baz')
        assert call_context.activated_extensions == {'foo', 'baz'}



---
File: /a2a-python/tests/server/agent_execution/test_simple_request_context_builder.py
---

import unittest

from unittest.mock import AsyncMock

from a2a.auth.user import UnauthenticatedUser  # Import User types
from a2a.server.agent_execution.context import (
    RequestContext,  # Corrected import path
)
from a2a.server.agent_execution.simple_request_context_builder import (
    SimpleRequestContextBuilder,
)
from a2a.server.context import ServerCallContext
from a2a.server.tasks.task_store import TaskStore
from a2a.types import (
    Message,
    MessageSendParams,
    Part,
    # ServerCallContext, # Removed from a2a.types
    Role,
    Task,
    TaskState,
    TaskStatus,
    TextPart,
)


# Helper to create a simple message
def create_sample_message(
    content='test message',
    msg_id='msg1',
    role=Role.user,
    reference_task_ids=None,
):
    return Message(
        message_id=msg_id,
        role=role,
        parts=[Part(root=TextPart(text=content))],
        referenceTaskIds=reference_task_ids if reference_task_ids else [],
    )


# Helper to create a simple task
def create_sample_task(
    task_id='task1', status_state=TaskState.submitted, context_id='ctx1'
):
    return Task(
        id=task_id,
        context_id=context_id,
        status=TaskStatus(state=status_state),
    )


class TestSimpleRequestContextBuilder(unittest.IsolatedAsyncioTestCase):
    def setUp(self):
        self.mock_task_store = AsyncMock(spec=TaskStore)

    def test_init_with_populate_true_and_task_store(self):
        builder = SimpleRequestContextBuilder(
            should_populate_referred_tasks=True, task_store=self.mock_task_store
        )
        self.assertTrue(builder._should_populate_referred_tasks)
        self.assertEqual(builder._task_store, self.mock_task_store)

    def test_init_with_populate_false_task_store_none(self):
        builder = SimpleRequestContextBuilder(
            should_populate_referred_tasks=False, task_store=None
        )
        self.assertFalse(builder._should_populate_referred_tasks)
        self.assertIsNone(builder._task_store)

    def test_init_with_populate_false_task_store_provided(self):
        # Even if populate is false, task_store might still be provided (though not used by build for related_tasks)
        builder = SimpleRequestContextBuilder(
            should_populate_referred_tasks=False,
            task_store=self.mock_task_store,
        )
        self.assertFalse(builder._should_populate_referred_tasks)
        self.assertEqual(builder._task_store, self.mock_task_store)

    async def test_build_basic_context_no_populate(self):
        builder = SimpleRequestContextBuilder(
            should_populate_referred_tasks=False,
            task_store=self.mock_task_store,
        )

        params = MessageSendParams(message=create_sample_message())
        task_id = 'test_task_id_1'
        context_id = 'test_context_id_1'
        current_task = create_sample_task(
            task_id=task_id, context_id=context_id
        )
        # Pass a valid User instance, e.g., UnauthenticatedUser or a mock spec'd as User
        server_call_context = ServerCallContext(
            user=UnauthenticatedUser(), auth_token='dummy_token'
        )

        request_context = await builder.build(
            params=params,
            task_id=task_id,
            context_id=context_id,
            task=current_task,
            context=server_call_context,
        )

        self.assertIsInstance(request_context, RequestContext)
        # Access params via its properties message and configuration
        self.assertEqual(request_context.message, params.message)
        self.assertEqual(request_context.configuration, params.configuration)
        self.assertEqual(request_context.task_id, task_id)
        self.assertEqual(request_context.context_id, context_id)
        self.assertEqual(
            request_context.current_task, current_task
        )  # Property is current_task
        self.assertEqual(
            request_context.call_context, server_call_context
        )  # Property is call_context
        self.assertEqual(request_context.related_tasks, [])  # Initialized to []
        self.mock_task_store.get.assert_not_called()

    async def test_build_populate_true_with_reference_task_ids(self):
        builder = SimpleRequestContextBuilder(
            should_populate_referred_tasks=True, task_store=self.mock_task_store
        )
        ref_task_id1 = 'ref_task1'
        ref_task_id2 = 'ref_task2_missing'
        ref_task_id3 = 'ref_task3'

        mock_ref_task1 = create_sample_task(task_id=ref_task_id1)
        mock_ref_task3 = create_sample_task(task_id=ref_task_id3)

        # Configure task_store.get mock
        # Note: AsyncMock side_effect needs to handle multiple calls if they have different args.
        # A simple way is a list of return values, or a function.
        async def get_side_effect(task_id):
            if task_id == ref_task_id1:
                return mock_ref_task1
            if task_id == ref_task_id3:
                return mock_ref_task3
            return None

        self.mock_task_store.get = AsyncMock(side_effect=get_side_effect)

        params = MessageSendParams(
            message=create_sample_message(
                reference_task_ids=[ref_task_id1, ref_task_id2, ref_task_id3]
            )
        )
        server_call_context = ServerCallContext(user=UnauthenticatedUser())

        request_context = await builder.build(
            params=params,
            task_id='t1',
            context_id='c1',
            task=None,
            context=server_call_context,
        )

        self.assertEqual(self.mock_task_store.get.call_count, 3)
        self.mock_task_store.get.assert_any_call(ref_task_id1)
        self.mock_task_store.get.assert_any_call(ref_task_id2)
        self.mock_task_store.get.assert_any_call(ref_task_id3)

        self.assertIsNotNone(request_context.related_tasks)
        self.assertEqual(
            len(request_context.related_tasks), 2
        )  # Only non-None tasks
        self.assertIn(mock_ref_task1, request_context.related_tasks)
        self.assertIn(mock_ref_task3, request_context.related_tasks)

    async def test_build_populate_true_params_none(self):
        builder = SimpleRequestContextBuilder(
            should_populate_referred_tasks=True, task_store=self.mock_task_store
        )
        server_call_context = ServerCallContext(user=UnauthenticatedUser())
        request_context = await builder.build(
            params=None,
            task_id='t1',
            context_id='c1',
            task=None,
            context=server_call_context,
        )
        self.assertEqual(request_context.related_tasks, [])
        self.mock_task_store.get.assert_not_called()

    async def test_build_populate_true_reference_ids_empty_or_none(self):
        builder = SimpleRequestContextBuilder(
            should_populate_referred_tasks=True, task_store=self.mock_task_store
        )
        server_call_context = ServerCallContext(user=UnauthenticatedUser())

        # Test with empty list
        params_empty_refs = MessageSendParams(
            message=create_sample_message(reference_task_ids=[])
        )
        request_context_empty = await builder.build(
            params=params_empty_refs,
            task_id='t1',
            context_id='c1',
            task=None,
            context=server_call_context,
        )
        self.assertEqual(
            request_context_empty.related_tasks, []
        )  # Should be [] if list is empty
        self.mock_task_store.get.assert_not_called()

        self.mock_task_store.get.reset_mock()  # Reset for next call

        # Test with referenceTaskIds=None (Pydantic model might default it to empty list or handle it)
        # create_sample_message defaults to [] if None is passed, so this tests the same as above.
        # To explicitly test None in Message, we'd have to bypass Pydantic default or modify helper.
        # For now, this covers the "no IDs to process" case.
        msg_with_no_refs = Message(
            message_id='m2', role=Role.user, parts=[], referenceTaskIds=None
        )
        params_none_refs = MessageSendParams(message=msg_with_no_refs)
        request_context_none = await builder.build(
            params=params_none_refs,
            task_id='t2',
            context_id='c2',
            task=None,
            context=server_call_context,
        )
        self.assertEqual(request_context_none.related_tasks, [])
        self.mock_task_store.get.assert_not_called()

    async def test_build_populate_true_task_store_none(self):
        # This scenario might be prevented by constructor logic if should_populate_referred_tasks is True,
        # but testing defensively. The builder might allow task_store=None if it's set post-init,
        # or if constructor logic changes. Current SimpleRequestContextBuilder takes it at init.
        # If task_store is None, it should not attempt to call get.
        builder = SimpleRequestContextBuilder(
            should_populate_referred_tasks=True,
            task_store=None,  # Explicitly None
        )
        params = MessageSendParams(
            message=create_sample_message(reference_task_ids=['ref1'])
        )
        server_call_context = ServerCallContext(user=UnauthenticatedUser())

        request_context = await builder.build(
            params=params,
            task_id='t1',
            context_id='c1',
            task=None,
            context=server_call_context,
        )
        # Expect related_tasks to be an empty list as task_store is None
        self.assertEqual(request_context.related_tasks, [])
        # No mock_task_store to check calls on, this test is mostly for graceful handling.

    async def test_build_populate_false_with_reference_task_ids(self):
        builder = SimpleRequestContextBuilder(
            should_populate_referred_tasks=False,
            task_store=self.mock_task_store,
        )
        params = MessageSendParams(
            message=create_sample_message(
                reference_task_ids=['ref_task_should_not_be_fetched']
            )
        )
        server_call_context = ServerCallContext(user=UnauthenticatedUser())

        request_context = await builder.build(
            params=params,
            task_id='t1',
            context_id='c1',
            task=None,
            context=server_call_context,
        )
        self.assertEqual(request_context.related_tasks, [])
        self.mock_task_store.get.assert_not_called()


if __name__ == '__main__':
    unittest.main()



---
File: /a2a-python/tests/server/apps/jsonrpc/test_fastapi_app.py
---

from typing import Any
from unittest.mock import MagicMock

import pytest

from a2a.server.apps.jsonrpc import fastapi_app
from a2a.server.apps.jsonrpc.fastapi_app import A2AFastAPIApplication
from a2a.server.request_handlers.request_handler import (
    RequestHandler,  # For mock spec
)
from a2a.types import AgentCard  # For mock spec


# --- A2AFastAPIApplication Tests ---


class TestA2AFastAPIApplicationOptionalDeps:
    # Running tests in this class requires the optional dependency fastapi to be
    # present in the test environment.

    @pytest.fixture(scope='class', autouse=True)
    def ensure_pkg_fastapi_is_present(self):
        try:
            import fastapi as _fastapi  # noqa: F401
        except ImportError:
            pytest.fail(
                f'Running tests in {self.__class__.__name__} requires'
                ' the optional dependency fastapi to be present in the test'
                ' environment. Run `uv sync --dev ...` before running the test'
                ' suite.'
            )

    @pytest.fixture(scope='class')
    def mock_app_params(self) -> dict:
        # Mock http_handler
        mock_handler = MagicMock(spec=RequestHandler)
        # Mock agent_card with essential attributes accessed in __init__
        mock_agent_card = MagicMock(spec=AgentCard)
        # Ensure 'url' attribute exists on the mock_agent_card, as it's accessed
        # in __init__
        mock_agent_card.url = 'http://example.com'
        # Ensure 'supports_authenticated_extended_card' attribute exists
        mock_agent_card.supports_authenticated_extended_card = False
        return {'agent_card': mock_agent_card, 'http_handler': mock_handler}

    @pytest.fixture(scope='class')
    def mark_pkg_fastapi_not_installed(self):
        pkg_fastapi_installed_flag = fastapi_app._package_fastapi_installed
        fastapi_app._package_fastapi_installed = False
        yield
        fastapi_app._package_fastapi_installed = pkg_fastapi_installed_flag

    def test_create_a2a_fastapi_app_with_present_deps_succeeds(
        self, mock_app_params: dict
    ):
        try:
            _app = A2AFastAPIApplication(**mock_app_params)
        except ImportError:
            pytest.fail(
                'With the fastapi package present, creating a'
                ' A2AFastAPIApplication instance should not raise ImportError'
            )

    def test_create_a2a_fastapi_app_with_missing_deps_raises_importerror(
        self,
        mock_app_params: dict,
        mark_pkg_fastapi_not_installed: Any,
    ):
        with pytest.raises(
            ImportError,
            match=(
                'The `fastapi` package is required to use the'
                ' `A2AFastAPIApplication`'
            ),
        ):
            _app = A2AFastAPIApplication(**mock_app_params)


if __name__ == '__main__':
    pytest.main([__file__])



---
File: /a2a-python/tests/server/apps/jsonrpc/test_jsonrpc_app.py
---

from typing import Any
from unittest.mock import AsyncMock, MagicMock

import pytest

from starlette.testclient import TestClient


# Attempt to import StarletteBaseUser, fallback to MagicMock if not available
try:
    from starlette.authentication import BaseUser as StarletteBaseUser
except ImportError:
    StarletteBaseUser = MagicMock()  # type: ignore

from a2a.extensions.common import HTTP_EXTENSION_HEADER
from a2a.server.apps.jsonrpc import (
    jsonrpc_app,  # Keep this import for optional deps test
)
from a2a.server.apps.jsonrpc.jsonrpc_app import (
    JSONRPCApplication,
    StarletteUserProxy,
)
from a2a.server.apps.jsonrpc.starlette_app import A2AStarletteApplication
from a2a.server.context import ServerCallContext
from a2a.server.request_handlers.request_handler import (
    RequestHandler,
)  # For mock spec
from a2a.types import (
    AgentCard,
    Message,
    MessageSendParams,
    Part,
    Role,
    SendMessageRequest,
    SendMessageResponse,
    SendMessageSuccessResponse,
    TextPart,
)


# --- StarletteUserProxy Tests ---


class TestStarletteUserProxy:
    def test_starlette_user_proxy_is_authenticated_true(self):
        starlette_user_mock = MagicMock(spec=StarletteBaseUser)
        starlette_user_mock.is_authenticated = True
        proxy = StarletteUserProxy(starlette_user_mock)
        assert proxy.is_authenticated is True

    def test_starlette_user_proxy_is_authenticated_false(self):
        starlette_user_mock = MagicMock(spec=StarletteBaseUser)
        starlette_user_mock.is_authenticated = False
        proxy = StarletteUserProxy(starlette_user_mock)
        assert proxy.is_authenticated is False

    def test_starlette_user_proxy_user_name(self):
        starlette_user_mock = MagicMock(spec=StarletteBaseUser)
        starlette_user_mock.display_name = 'Test User DisplayName'
        proxy = StarletteUserProxy(starlette_user_mock)
        assert proxy.user_name == 'Test User DisplayName'

    def test_starlette_user_proxy_user_name_raises_attribute_error(self):
        """
        Tests that if the underlying starlette user object is missing the
        display_name attribute, the proxy currently raises an AttributeError.
        """
        starlette_user_mock = MagicMock(spec=StarletteBaseUser)
        # Ensure display_name is not present on the mock to trigger AttributeError
        del starlette_user_mock.display_name

        proxy = StarletteUserProxy(starlette_user_mock)
        with pytest.raises(AttributeError, match='display_name'):
            _ = proxy.user_name


# --- JSONRPCApplication Tests (Selected) ---


class TestJSONRPCApplicationSetup:  # Renamed to avoid conflict
    def test_jsonrpc_app_build_method_abstract_raises_typeerror(
        self,
    ):  # Renamed test
        mock_handler = MagicMock(spec=RequestHandler)
        # Mock agent_card with essential attributes accessed in JSONRPCApplication.__init__
        mock_agent_card = MagicMock(spec=AgentCard)
        # Ensure 'url' attribute exists on the mock_agent_card, as it's accessed in __init__
        mock_agent_card.url = 'http://mockurl.com'
        # Ensure 'supportsAuthenticatedExtendedCard' attribute exists
        mock_agent_card.supports_authenticated_extended_card = False

        # This will fail at definition time if an abstract method is not implemented
        with pytest.raises(
            TypeError,
            match=".*abstract class IncompleteJSONRPCApp .* abstract method '?build'?",
        ):

            class IncompleteJSONRPCApp(JSONRPCApplication):
                # Intentionally not implementing 'build'
                def some_other_method(self):
                    pass

            IncompleteJSONRPCApp(
                agent_card=mock_agent_card, http_handler=mock_handler
            )


class TestJSONRPCApplicationOptionalDeps:
    # Running tests in this class requires optional dependencies starlette and
    # sse-starlette to be present in the test environment.

    @pytest.fixture(scope='class', autouse=True)
    def ensure_pkg_starlette_is_present(self):
        try:
            import sse_starlette as _sse_starlette  # noqa: F401
            import starlette as _starlette  # noqa: F401
        except ImportError:
            pytest.fail(
                f'Running tests in {self.__class__.__name__} requires'
                ' optional dependencies starlette and sse-starlette to be'
                ' present in the test environment. Run `uv sync --dev ...`'
                ' before running the test suite.'
            )

    @pytest.fixture(scope='class')
    def mock_app_params(self) -> dict:
        # Mock http_handler
        mock_handler = MagicMock(spec=RequestHandler)
        # Mock agent_card with essential attributes accessed in __init__
        mock_agent_card = MagicMock(spec=AgentCard)
        # Ensure 'url' attribute exists on the mock_agent_card, as it's accessed
        # in __init__
        mock_agent_card.url = 'http://example.com'
        # Ensure 'supportsAuthenticatedExtendedCard' attribute exists
        mock_agent_card.supports_authenticated_extended_card = False
        return {'agent_card': mock_agent_card, 'http_handler': mock_handler}

    @pytest.fixture(scope='class')
    def mark_pkg_starlette_not_installed(self):
        pkg_starlette_installed_flag = jsonrpc_app._package_starlette_installed
        jsonrpc_app._package_starlette_installed = False
        yield
        jsonrpc_app._package_starlette_installed = pkg_starlette_installed_flag

    def test_create_jsonrpc_based_app_with_present_deps_succeeds(
        self, mock_app_params: dict
    ):
        class DummyJSONRPCApp(JSONRPCApplication):
            def build(
                self,
                agent_card_url='/.well-known/agent.json',
                rpc_url='/',
                **kwargs,
            ):
                return object()

        try:
            _app = DummyJSONRPCApp(**mock_app_params)
        except ImportError:
            pytest.fail(
                'With packages starlette and see-starlette present, creating a'
                ' JSONRPCApplication-based instance should not raise'
                ' ImportError'
            )

    def test_create_jsonrpc_based_app_with_missing_deps_raises_importerror(
        self, mock_app_params: dict, mark_pkg_starlette_not_installed: Any
    ):
        class DummyJSONRPCApp(JSONRPCApplication):
            def build(
                self,
                agent_card_url='/.well-known/agent.json',
                rpc_url='/',
                **kwargs,
            ):
                return object()

        with pytest.raises(
            ImportError,
            match=(
                'Packages `starlette` and `sse-starlette` are required to use'
                ' the `JSONRPCApplication`'
            ),
        ):
            _app = DummyJSONRPCApp(**mock_app_params)


class TestJSONRPCExtensions:
    @pytest.fixture
    def mock_handler(self):
        handler = AsyncMock(spec=RequestHandler)
        handler.on_message_send.return_value = SendMessageResponse(
            root=SendMessageSuccessResponse(
                id='1',
                result=Message(
                    message_id='test',
                    role=Role.agent,
                    parts=[Part(TextPart(text='response message'))],
                ),
            )
        )
        return handler

    @pytest.fixture
    def test_app(self, mock_handler):
        mock_agent_card = MagicMock(spec=AgentCard)
        mock_agent_card.url = 'http://mockurl.com'
        mock_agent_card.supports_authenticated_extended_card = False

        return A2AStarletteApplication(
            agent_card=mock_agent_card, http_handler=mock_handler
        )

    @pytest.fixture
    def client(self, test_app):
        return TestClient(test_app.build())

    def test_request_with_single_extension(self, client, mock_handler):
        headers = {HTTP_EXTENSION_HEADER: 'foo'}
        response = client.post(
            '/',
            headers=headers,
            json=SendMessageRequest(
                id='1',
                params=MessageSendParams(
                    message=Message(
                        message_id='1',
                        role=Role.user,
                        parts=[Part(TextPart(text='hi'))],
                    )
                ),
            ).model_dump(),
        )
        response.raise_for_status()

        mock_handler.on_message_send.assert_called_once()
        call_context = mock_handler.on_message_send.call_args[0][1]
        assert isinstance(call_context, ServerCallContext)
        assert call_context.requested_extensions == {'foo'}

    def test_request_with_comma_separated_extensions(
        self, client, mock_handler
    ):
        headers = {HTTP_EXTENSION_HEADER: 'foo, bar'}
        response = client.post(
            '/',
            headers=headers,
            json=SendMessageRequest(
                id='1',
                params=MessageSendParams(
                    message=Message(
                        message_id='1',
                        role=Role.user,
                        parts=[Part(TextPart(text='hi'))],
                    )
                ),
            ).model_dump(),
        )
        response.raise_for_status()

        mock_handler.on_message_send.assert_called_once()
        call_context = mock_handler.on_message_send.call_args[0][1]
        assert call_context.requested_extensions == {'foo', 'bar'}

    def test_request_with_comma_separated_extensions_no_space(
        self, client, mock_handler
    ):
        headers = [
            (HTTP_EXTENSION_HEADER, 'foo,  bar'),
            (HTTP_EXTENSION_HEADER, 'baz'),
        ]
        response = client.post(
            '/',
            headers=headers,
            json=SendMessageRequest(
                id='1',
                params=MessageSendParams(
                    message=Message(
                        message_id='1',
                        role=Role.user,
                        parts=[Part(TextPart(text='hi'))],
                    )
                ),
            ).model_dump(),
        )
        response.raise_for_status()

        mock_handler.on_message_send.assert_called_once()
        call_context = mock_handler.on_message_send.call_args[0][1]
        assert call_context.requested_extensions == {'foo', 'bar', 'baz'}

    def test_request_with_multiple_extension_headers(
        self, client, mock_handler
    ):
        headers = [
            (HTTP_EXTENSION_HEADER, 'foo'),
            (HTTP_EXTENSION_HEADER, 'bar'),
        ]
        response = client.post(
            '/',
            headers=headers,
            json=SendMessageRequest(
                id='1',
                params=MessageSendParams(
                    message=Message(
                        message_id='1',
                        role=Role.user,
                        parts=[Part(TextPart(text='hi'))],
                    )
                ),
            ).model_dump(),
        )
        response.raise_for_status()

        mock_handler.on_message_send.assert_called_once()
        call_context = mock_handler.on_message_send.call_args[0][1]
        assert call_context.requested_extensions == {'foo', 'bar'}

    def test_response_with_activated_extensions(self, client, mock_handler):
        def side_effect(request, context: ServerCallContext):
            context.activated_extensions.add('foo')
            context.activated_extensions.add('baz')
            return SendMessageResponse(
                root=SendMessageSuccessResponse(
                    id='1',
                    result=Message(
                        message_id='test',
                        role=Role.agent,
                        parts=[Part(TextPart(text='response message'))],
                    ),
                )
            )

        mock_handler.on_message_send.side_effect = side_effect

        response = client.post(
            '/',
            json=SendMessageRequest(
                id='1',
                params=MessageSendParams(
                    message=Message(
                        message_id='1',
                        role=Role.user,
                        parts=[Part(TextPart(text='hi'))],
                    )
                ),
            ).model_dump(),
        )
        response.raise_for_status()

        assert response.status_code == 200
        assert HTTP_EXTENSION_HEADER in response.headers
        assert set(response.headers[HTTP_EXTENSION_HEADER].split(', ')) == {
            'foo',
            'baz',
        }


if __name__ == '__main__':
    pytest.main([__file__])



---
File: /a2a-python/tests/server/apps/jsonrpc/test_serialization.py
---

from unittest import mock

import pytest

from fastapi import FastAPI
from pydantic import ValidationError
from starlette.testclient import TestClient

from a2a.server.apps import A2AFastAPIApplication, A2AStarletteApplication
from a2a.types import (
    APIKeySecurityScheme,
    AgentCapabilities,
    AgentCard,
    In,
    InvalidRequestError,
    JSONParseError,
    Message,
    Part,
    Role,
    SecurityScheme,
    TextPart,
)


@pytest.fixture
def agent_card_with_api_key():
    """Provides an AgentCard with an APIKeySecurityScheme for testing serialization."""
    # This data uses the alias 'in', which is correct for creating the model.
    api_key_scheme_data = {
        'type': 'apiKey',
        'name': 'X-API-KEY',
        'in': 'header',
    }
    api_key_scheme = APIKeySecurityScheme.model_validate(api_key_scheme_data)

    return AgentCard(
        name='APIKeyAgent',
        description='An agent that uses API Key auth.',
        url='http://example.com/apikey-agent',
        version='1.0.0',
        capabilities=AgentCapabilities(),
        default_input_modes=['text/plain'],
        default_output_modes=['text/plain'],
        skills=[],
        security_schemes={'api_key_auth': SecurityScheme(root=api_key_scheme)},
        security=[{'api_key_auth': []}],
    )


def test_starlette_agent_card_with_api_key_scheme_alias(
    agent_card_with_api_key: AgentCard,
):
    """
    Tests that the A2AStarletteApplication endpoint correctly serializes aliased fields.

    This verifies the fix for `APIKeySecurityScheme.in_` being serialized as `in_` instead of `in`.
    """
    handler = mock.AsyncMock()
    app_instance = A2AStarletteApplication(agent_card_with_api_key, handler)
    client = TestClient(app_instance.build())

    response = client.get('/.well-known/agent-card.json')
    assert response.status_code == 200
    response_data = response.json()

    security_scheme_json = response_data['securitySchemes']['api_key_auth']
    assert 'in' in security_scheme_json
    assert security_scheme_json['in'] == 'header'
    assert 'in_' not in security_scheme_json

    try:
        parsed_card = AgentCard.model_validate(response_data)
        parsed_scheme_wrapper = parsed_card.security_schemes['api_key_auth']
        assert isinstance(parsed_scheme_wrapper.root, APIKeySecurityScheme)
        assert parsed_scheme_wrapper.root.in_ == In.header
    except ValidationError as e:
        pytest.fail(
            f"AgentCard.model_validate failed on the server's response: {e}"
        )


def test_fastapi_agent_card_with_api_key_scheme_alias(
    agent_card_with_api_key: AgentCard,
):
    """
    Tests that the A2AFastAPIApplication endpoint correctly serializes aliased fields.

    This verifies the fix for `APIKeySecurityScheme.in_` being serialized as `in_` instead of `in`.
    """
    handler = mock.AsyncMock()
    app_instance = A2AFastAPIApplication(agent_card_with_api_key, handler)
    client = TestClient(app_instance.build())

    response = client.get('/.well-known/agent-card.json')
    assert response.status_code == 200
    response_data = response.json()

    security_scheme_json = response_data['securitySchemes']['api_key_auth']
    assert 'in' in security_scheme_json
    assert 'in_' not in security_scheme_json
    assert security_scheme_json['in'] == 'header'


def test_handle_invalid_json(agent_card_with_api_key: AgentCard):
    """Test handling of malformed JSON."""
    handler = mock.AsyncMock()
    app_instance = A2AStarletteApplication(agent_card_with_api_key, handler)
    client = TestClient(app_instance.build())

    response = client.post(
        '/',
        content='{ "jsonrpc": "2.0", "method": "test", "id": 1, "params": { "key": "value" }',
    )
    assert response.status_code == 200
    data = response.json()
    assert data['error']['code'] == JSONParseError().code


def test_handle_oversized_payload(agent_card_with_api_key: AgentCard):
    """Test handling of oversized JSON payloads."""
    handler = mock.AsyncMock()
    app_instance = A2AStarletteApplication(agent_card_with_api_key, handler)
    client = TestClient(app_instance.build())

    large_string = 'a' * 2_000_000  # 2MB string
    payload = {
        'jsonrpc': '2.0',
        'method': 'test',
        'id': 1,
        'params': {'data': large_string},
    }

    # Starlette/FastAPI's default max request size is around 1MB.
    # This test will likely fail with a 413 Payload Too Large if the default is not increased.
    # If the application is expected to handle larger payloads, the server configuration needs to be adjusted.
    # For this test, we expect a 413 or a graceful JSON-RPC error if the app handles it.

    try:
        response = client.post('/', json=payload)
        # If the app handles it gracefully and returns a JSON-RPC error
        if response.status_code == 200:
            data = response.json()
            assert data['error']['code'] == InvalidRequestError().code
        else:
            assert response.status_code == 413
    except Exception as e:
        # Depending on server setup, it might just drop the connection for very large payloads
        assert isinstance(e, ConnectionResetError | RuntimeError)


def test_handle_unicode_characters(agent_card_with_api_key: AgentCard):
    """Test handling of unicode characters in JSON payload."""
    handler = mock.AsyncMock()
    app_instance = A2AStarletteApplication(agent_card_with_api_key, handler)
    client = TestClient(app_instance.build())

    unicode_text = 'こんにちは世界'  # "Hello world" in Japanese
    unicode_payload = {
        'jsonrpc': '2.0',
        'method': 'message/send',
        'id': 'unicode_test',
        'params': {
            'message': {
                'role': 'user',
                'parts': [{'kind': 'text', 'text': unicode_text}],
                'message_id': 'msg-unicode',
            }
        },
    }

    # Mock a handler for this method
    handler.on_message_send.return_value = Message(
        role=Role.agent,
        parts=[Part(root=TextPart(text=f'Received: {unicode_text}'))],
        message_id='response-unicode',
    )

    response = client.post('/', json=unicode_payload)

    # We are not testing the handler logic here, just that the server can correctly
    # deserialize the unicode payload without errors. A 200 response with any valid
    # JSON-RPC response indicates success.
    assert response.status_code == 200
    data = response.json()
    assert 'error' not in data or data['error'] is None
    assert data['result']['parts'][0]['text'] == f'Received: {unicode_text}'


def test_fastapi_sub_application(agent_card_with_api_key: AgentCard):
    """
    Tests that the A2AFastAPIApplication endpoint correctly passes the url in sub-application.
    """
    handler = mock.AsyncMock()
    sub_app_instance = A2AFastAPIApplication(agent_card_with_api_key, handler)
    app_instance = FastAPI()
    app_instance.mount('/a2a', sub_app_instance.build())
    client = TestClient(app_instance)

    response = client.get('/a2a/openapi.json')
    assert response.status_code == 200
    response_data = response.json()

    assert 'servers' in response_data
    assert response_data['servers'] == [{'url': '/a2a'}]



---
File: /a2a-python/tests/server/apps/jsonrpc/test_starlette_app.py
---

from typing import Any
from unittest.mock import MagicMock

import pytest

from a2a.server.apps.jsonrpc import starlette_app
from a2a.server.apps.jsonrpc.starlette_app import A2AStarletteApplication
from a2a.server.request_handlers.request_handler import (
    RequestHandler,  # For mock spec
)
from a2a.types import AgentCard  # For mock spec


# --- A2AStarletteApplication Tests ---


class TestA2AStarletteApplicationOptionalDeps:
    # Running tests in this class requires optional dependencies starlette and
    # sse-starlette to be present in the test environment.

    @pytest.fixture(scope='class', autouse=True)
    def ensure_pkg_starlette_is_present(self):
        try:
            import sse_starlette as _sse_starlette  # noqa: F401
            import starlette as _starlette  # noqa: F401
        except ImportError:
            pytest.fail(
                f'Running tests in {self.__class__.__name__} requires'
                ' optional dependencies starlette and sse-starlette to be'
                ' present in the test environment. Run `uv sync --dev ...`'
                ' before running the test suite.'
            )

    @pytest.fixture(scope='class')
    def mock_app_params(self) -> dict:
        # Mock http_handler
        mock_handler = MagicMock(spec=RequestHandler)
        # Mock agent_card with essential attributes accessed in __init__
        mock_agent_card = MagicMock(spec=AgentCard)
        # Ensure 'url' attribute exists on the mock_agent_card, as it's accessed
        # in __init__
        mock_agent_card.url = 'http://example.com'
        # Ensure 'supports_authenticated_extended_card' attribute exists
        mock_agent_card.supports_authenticated_extended_card = False
        return {'agent_card': mock_agent_card, 'http_handler': mock_handler}

    @pytest.fixture(scope='class')
    def mark_pkg_starlette_not_installed(self):
        pkg_starlette_installed_flag = (
            starlette_app._package_starlette_installed
        )
        starlette_app._package_starlette_installed = False
        yield
        starlette_app._package_starlette_installed = (
            pkg_starlette_installed_flag
        )

    def test_create_a2a_starlette_app_with_present_deps_succeeds(
        self, mock_app_params: dict
    ):
        try:
            _app = A2AStarletteApplication(**mock_app_params)
        except ImportError:
            pytest.fail(
                'With packages starlette and see-starlette present, creating an'
                ' A2AStarletteApplication instance should not raise ImportError'
            )

    def test_create_a2a_starlette_app_with_missing_deps_raises_importerror(
        self,
        mock_app_params: dict,
        mark_pkg_starlette_not_installed: Any,
    ):
        with pytest.raises(
            ImportError,
            match='Packages `starlette` and `sse-starlette` are required',
        ):
            _app = A2AStarletteApplication(**mock_app_params)


if __name__ == '__main__':
    pytest.main([__file__])



---
File: /a2a-python/tests/server/apps/rest/test_rest_fastapi_app.py
---

import logging

from typing import Any
from unittest.mock import MagicMock

import pytest

from fastapi import FastAPI
from google.protobuf import json_format
from httpx import ASGITransport, AsyncClient

from a2a.grpc import a2a_pb2
from a2a.server.apps.rest import fastapi_app, rest_adapter
from a2a.server.apps.rest.fastapi_app import A2ARESTFastAPIApplication
from a2a.server.apps.rest.rest_adapter import RESTAdapter
from a2a.server.request_handlers.request_handler import RequestHandler
from a2a.types import (
    AgentCard,
    Message,
    Part,
    Role,
    Task,
    TaskState,
    TaskStatus,
    TextPart,
)


logger = logging.getLogger(__name__)


@pytest.fixture
async def agent_card() -> AgentCard:
    mock_agent_card = MagicMock(spec=AgentCard)
    mock_agent_card.url = 'http://mockurl.com'
    mock_agent_card.supports_authenticated_extended_card = False
    return mock_agent_card


@pytest.fixture
async def request_handler() -> RequestHandler:
    return MagicMock(spec=RequestHandler)


@pytest.fixture
async def app(
    agent_card: AgentCard, request_handler: RequestHandler
) -> FastAPI:
    """Builds the FastAPI application for testing."""

    return A2ARESTFastAPIApplication(agent_card, request_handler).build(
        agent_card_url='/well-known/agent.json', rpc_url=''
    )


@pytest.fixture
async def client(app: FastAPI) -> AsyncClient:
    return AsyncClient(
        transport=ASGITransport(app=app), base_url='http://testapp'
    )


@pytest.fixture
def mark_pkg_starlette_not_installed():
    pkg_starlette_installed_flag = rest_adapter._package_starlette_installed
    rest_adapter._package_starlette_installed = False
    yield
    rest_adapter._package_starlette_installed = pkg_starlette_installed_flag


@pytest.fixture
def mark_pkg_fastapi_not_installed():
    pkg_fastapi_installed_flag = fastapi_app._package_fastapi_installed
    fastapi_app._package_fastapi_installed = False
    yield
    fastapi_app._package_fastapi_installed = pkg_fastapi_installed_flag


@pytest.mark.anyio
async def test_create_rest_adapter_with_present_deps_succeeds(
    agent_card: AgentCard, request_handler: RequestHandler
):
    try:
        _app = RESTAdapter(agent_card, request_handler)
    except ImportError:
        pytest.fail(
            'With packages starlette and see-starlette present, creating an'
            ' RESTAdapter instance should not raise ImportError'
        )


@pytest.mark.anyio
async def test_create_rest_adapter_with_missing_deps_raises_importerror(
    agent_card: AgentCard,
    request_handler: RequestHandler,
    mark_pkg_starlette_not_installed: Any,
):
    with pytest.raises(
        ImportError,
        match=(
            'Packages `starlette` and `sse-starlette` are required to use'
            ' the `RESTAdapter`.'
        ),
    ):
        _app = RESTAdapter(agent_card, request_handler)


@pytest.mark.anyio
async def test_create_a2a_rest_fastapi_app_with_present_deps_succeeds(
    agent_card: AgentCard, request_handler: RequestHandler
):
    try:
        _app = A2ARESTFastAPIApplication(agent_card, request_handler).build(
            agent_card_url='/well-known/agent.json', rpc_url=''
        )
    except ImportError:
        pytest.fail(
            'With the fastapi package present, creating a'
            ' A2ARESTFastAPIApplication instance should not raise ImportError'
        )


@pytest.mark.anyio
async def test_create_a2a_rest_fastapi_app_with_missing_deps_raises_importerror(
    agent_card: AgentCard,
    request_handler: RequestHandler,
    mark_pkg_fastapi_not_installed: Any,
):
    with pytest.raises(
        ImportError,
        match=(
            'The `fastapi` package is required to use the'
            ' `A2ARESTFastAPIApplication`'
        ),
    ):
        _app = A2ARESTFastAPIApplication(agent_card, request_handler).build(
            agent_card_url='/well-known/agent.json', rpc_url=''
        )


@pytest.mark.anyio
async def test_send_message_success_message(
    client: AsyncClient, request_handler: MagicMock
) -> None:
    expected_response = a2a_pb2.SendMessageResponse(
        msg=a2a_pb2.Message(
            message_id='test',
            role=a2a_pb2.Role.ROLE_AGENT,
            content=[
                a2a_pb2.Part(text='response message'),
            ],
        ),
    )
    request_handler.on_message_send.return_value = Message(
        message_id='test',
        role=Role.agent,
        parts=[Part(TextPart(text='response message'))],
    )

    request = a2a_pb2.SendMessageRequest(
        request=a2a_pb2.Message(),
        configuration=a2a_pb2.SendMessageConfiguration(),
    )
    # To see log output, run pytest with '--log-cli=true --log-cli-level=INFO'
    response = await client.post(
        '/v1/message:send', json=json_format.MessageToDict(request)
    )
    # request should always be successful
    response.raise_for_status()

    actual_response = a2a_pb2.SendMessageResponse()
    json_format.Parse(response.text, actual_response)
    assert expected_response == actual_response


@pytest.mark.anyio
async def test_send_message_success_task(
    client: AsyncClient, request_handler: MagicMock
) -> None:
    expected_response = a2a_pb2.SendMessageResponse(
        task=a2a_pb2.Task(
            id='test_task_id',
            context_id='test_context_id',
            status=a2a_pb2.TaskStatus(
                state=a2a_pb2.TaskState.TASK_STATE_COMPLETED,
                update=a2a_pb2.Message(
                    message_id='test',
                    role=a2a_pb2.ROLE_AGENT,
                    content=[
                        a2a_pb2.Part(text='response task message'),
                    ],
                ),
            ),
        ),
    )
    request_handler.on_message_send.return_value = Task(
        id='test_task_id',
        context_id='test_context_id',
        status=TaskStatus(
            state=TaskState.completed,
            message=Message(
                message_id='test',
                role=Role.agent,
                parts=[Part(TextPart(text='response task message'))],
            ),
        ),
    )

    request = a2a_pb2.SendMessageRequest(
        request=a2a_pb2.Message(),
        configuration=a2a_pb2.SendMessageConfiguration(),
    )
    # To see log output, run pytest with '--log-cli=true --log-cli-level=INFO'
    response = await client.post(
        '/v1/message:send', json=json_format.MessageToDict(request)
    )
    # request should always be successful
    response.raise_for_status()

    actual_response = a2a_pb2.SendMessageResponse()
    json_format.Parse(response.text, actual_response)
    assert expected_response == actual_response


if __name__ == '__main__':
    pytest.main([__file__])



---
File: /a2a-python/tests/server/events/test_event_consumer.py
---

import asyncio

from typing import Any
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from pydantic import ValidationError

from a2a.server.events.event_consumer import EventConsumer, QueueClosed
from a2a.server.events.event_queue import EventQueue
from a2a.types import (
    A2AError,
    Artifact,
    InternalError,
    JSONRPCError,
    Message,
    Part,
    Task,
    TaskArtifactUpdateEvent,
    TaskState,
    TaskStatus,
    TaskStatusUpdateEvent,
    TextPart,
)
from a2a.utils.errors import ServerError


MINIMAL_TASK: dict[str, Any] = {
    'id': '123',
    'context_id': 'session-xyz',
    'status': {'state': 'submitted'},
    'kind': 'task',
}

MESSAGE_PAYLOAD: dict[str, Any] = {
    'role': 'agent',
    'parts': [{'text': 'test message'}],
    'message_id': '111',
}


@pytest.fixture
def mock_event_queue():
    return AsyncMock(spec=EventQueue)


@pytest.fixture
def event_consumer(mock_event_queue: EventQueue):
    return EventConsumer(queue=mock_event_queue)


def test_init_logs_debug_message(mock_event_queue: EventQueue):
    """Test that __init__ logs a debug message."""
    # Patch the logger instance within the module where EventConsumer is defined
    with patch('a2a.server.events.event_consumer.logger') as mock_logger:
        EventConsumer(queue=mock_event_queue)  # Instantiate to trigger __init__
        mock_logger.debug.assert_called_once_with('EventConsumer initialized')


@pytest.mark.asyncio
async def test_consume_one_task_event(
    event_consumer: MagicMock,
    mock_event_queue: MagicMock,
):
    task_event = Task(**MINIMAL_TASK)
    mock_event_queue.dequeue_event.return_value = task_event
    result = await event_consumer.consume_one()
    assert result == task_event
    mock_event_queue.task_done.assert_called_once()


@pytest.mark.asyncio
async def test_consume_one_message_event(
    event_consumer: MagicMock,
    mock_event_queue: MagicMock,
):
    message_event = Message(**MESSAGE_PAYLOAD)
    mock_event_queue.dequeue_event.return_value = message_event
    result = await event_consumer.consume_one()
    assert result == message_event
    mock_event_queue.task_done.assert_called_once()


@pytest.mark.asyncio
async def test_consume_one_a2a_error_event(
    event_consumer: MagicMock,
    mock_event_queue: MagicMock,
):
    error_event = A2AError(InternalError())
    mock_event_queue.dequeue_event.return_value = error_event
    result = await event_consumer.consume_one()
    assert result == error_event
    mock_event_queue.task_done.assert_called_once()


@pytest.mark.asyncio
async def test_consume_one_jsonrpc_error_event(
    event_consumer: MagicMock,
    mock_event_queue: MagicMock,
):
    error_event = JSONRPCError(code=123, message='Some Error')
    mock_event_queue.dequeue_event.return_value = error_event
    result = await event_consumer.consume_one()
    assert result == error_event
    mock_event_queue.task_done.assert_called_once()


@pytest.mark.asyncio
async def test_consume_one_queue_empty(
    event_consumer: MagicMock,
    mock_event_queue: MagicMock,
):
    mock_event_queue.dequeue_event.side_effect = asyncio.QueueEmpty
    try:
        result = await event_consumer.consume_one()
        assert result is not None
    except ServerError:
        pass
    mock_event_queue.task_done.assert_not_called()


@pytest.mark.asyncio
async def test_consume_all_multiple_events(
    event_consumer: MagicMock,
    mock_event_queue: MagicMock,
):
    events: list[Any] = [
        Task(**MINIMAL_TASK),
        TaskArtifactUpdateEvent(
            task_id='task_123',
            context_id='session-xyz',
            artifact=Artifact(
                artifact_id='11', parts=[Part(TextPart(text='text'))]
            ),
        ),
        TaskStatusUpdateEvent(
            task_id='task_123',
            context_id='session-xyz',
            status=TaskStatus(state=TaskState.working),
            final=True,
        ),
    ]
    cursor = 0

    async def mock_dequeue() -> Any:
        nonlocal cursor
        if cursor < len(events):
            event = events[cursor]
            cursor += 1
            return event
        return None

    mock_event_queue.dequeue_event = mock_dequeue
    consumed_events: list[Any] = []
    async for event in event_consumer.consume_all():
        consumed_events.append(event)
    assert len(consumed_events) == 3
    assert consumed_events[0] == events[0]
    assert consumed_events[1] == events[1]
    assert consumed_events[2] == events[2]
    assert mock_event_queue.task_done.call_count == 3


@pytest.mark.asyncio
async def test_consume_until_message(
    event_consumer: MagicMock,
    mock_event_queue: MagicMock,
):
    events: list[Any] = [
        Task(**MINIMAL_TASK),
        TaskArtifactUpdateEvent(
            task_id='task_123',
            context_id='session-xyz',
            artifact=Artifact(
                artifact_id='11', parts=[Part(TextPart(text='text'))]
            ),
        ),
        Message(**MESSAGE_PAYLOAD),
        TaskStatusUpdateEvent(
            task_id='task_123',
            context_id='session-xyz',
            status=TaskStatus(state=TaskState.working),
            final=True,
        ),
    ]
    cursor = 0

    async def mock_dequeue() -> Any:
        nonlocal cursor
        if cursor < len(events):
            event = events[cursor]
            cursor += 1
            return event
        return None

    mock_event_queue.dequeue_event = mock_dequeue
    consumed_events: list[Any] = []
    async for event in event_consumer.consume_all():
        consumed_events.append(event)
    assert len(consumed_events) == 3
    assert consumed_events[0] == events[0]
    assert consumed_events[1] == events[1]
    assert consumed_events[2] == events[2]
    assert mock_event_queue.task_done.call_count == 3


@pytest.mark.asyncio
async def test_consume_message_events(
    event_consumer: MagicMock,
    mock_event_queue: MagicMock,
):
    events = [
        Message(**MESSAGE_PAYLOAD),
        Message(**MESSAGE_PAYLOAD, final=True),
    ]
    cursor = 0

    async def mock_dequeue() -> Any:
        nonlocal cursor
        if cursor < len(events):
            event = events[cursor]
            cursor += 1
            return event
        return None

    mock_event_queue.dequeue_event = mock_dequeue
    consumed_events: list[Any] = []
    async for event in event_consumer.consume_all():
        consumed_events.append(event)
    # Upon first Message the stream is closed.
    assert len(consumed_events) == 1
    assert consumed_events[0] == events[0]
    assert mock_event_queue.task_done.call_count == 1


@pytest.mark.asyncio
async def test_consume_all_raises_stored_exception(
    event_consumer: EventConsumer,
):
    """Test that consume_all raises an exception if _exception is set."""
    sample_exception = RuntimeError('Simulated agent error')
    event_consumer._exception = sample_exception

    with pytest.raises(RuntimeError, match='Simulated agent error'):
        async for _ in event_consumer.consume_all():
            pass  # Should not reach here


@pytest.mark.asyncio
async def test_consume_all_stops_on_queue_closed_and_confirmed_closed(
    event_consumer: EventConsumer, mock_event_queue: AsyncMock
):
    """Test consume_all stops if QueueClosed is raised and queue.is_closed() is True."""
    # Simulate the queue raising QueueClosed (which is asyncio.QueueEmpty or QueueShutdown)
    mock_event_queue.dequeue_event.side_effect = QueueClosed(
        'Queue is empty/closed'
    )
    # Simulate the queue confirming it's closed
    mock_event_queue.is_closed.return_value = True

    consumed_events = []
    async for event in event_consumer.consume_all():
        consumed_events.append(event)  # Should not happen

    assert (
        len(consumed_events) == 0
    )  # No events should be consumed as it breaks on QueueClosed
    mock_event_queue.dequeue_event.assert_called_once()  # Should attempt to dequeue once
    mock_event_queue.is_closed.assert_called_once()  # Should check if closed


@pytest.mark.asyncio
async def test_consume_all_continues_on_queue_empty_if_not_really_closed(
    event_consumer: EventConsumer, mock_event_queue: AsyncMock
):
    """Test that QueueClosed with is_closed=False allows loop to continue via timeout."""
    payload = MESSAGE_PAYLOAD.copy()
    payload['message_id'] = 'final_event_id'
    final_event = Message(**payload)

    # Setup dequeue_event behavior:
    # 1. Raise QueueClosed (e.g., asyncio.QueueEmpty)
    # 2. Return the final_event
    # 3. Raise QueueClosed again (to terminate after final_event)
    dequeue_effects = [
        QueueClosed('Simulated temporary empty'),
        final_event,
        QueueClosed('Queue closed after final event'),
    ]
    mock_event_queue.dequeue_event.side_effect = dequeue_effects

    # Setup is_closed behavior:
    # 1. False when QueueClosed is first raised (so loop doesn't break)
    # 2. True after final_event is processed and QueueClosed is raised again
    is_closed_effects = [False, True]
    mock_event_queue.is_closed.side_effect = is_closed_effects

    # Patch asyncio.wait_for used inside consume_all
    # The goal is that the first QueueClosed leads to a TimeoutError inside consume_all,
    # the loop continues, and then the final_event is fetched.

    # To reliably test the timeout behavior within consume_all, we adjust the consumer's
    # internal timeout to be very short for the test.
    event_consumer._timeout = 0.001

    consumed_events = []
    async for event in event_consumer.consume_all():
        consumed_events.append(event)

    assert len(consumed_events) == 1
    assert consumed_events[0] == final_event

    # Dequeue attempts:
    # 1. Raises QueueClosed (is_closed=False, leads to TimeoutError, loop continues)
    # 2. Returns final_event (which is a Message, causing consume_all to break)
    assert (
        mock_event_queue.dequeue_event.call_count == 2
    )  # Only two calls needed

    # is_closed calls:
    # 1. After first QueueClosed (returns False)
    # The second QueueClosed is not reached because Message breaks the loop.
    assert mock_event_queue.is_closed.call_count == 1


def test_agent_task_callback_sets_exception(event_consumer: EventConsumer):
    """Test that agent_task_callback sets _exception if the task had one."""
    mock_task = MagicMock(spec=asyncio.Task)
    mock_task.cancelled.return_value = False
    mock_task.done.return_value = True
    sample_exception = ValueError('Task failed')
    mock_task.exception.return_value = sample_exception

    event_consumer.agent_task_callback(mock_task)

    assert event_consumer._exception == sample_exception
    mock_task.exception.assert_called_once()


def test_agent_task_callback_no_exception(event_consumer: EventConsumer):
    """Test that agent_task_callback does nothing if the task has no exception."""
    mock_task = MagicMock(spec=asyncio.Task)
    mock_task.cancelled.return_value = False
    mock_task.done.return_value = True
    mock_task.exception.return_value = None  # No exception

    event_consumer.agent_task_callback(mock_task)

    assert event_consumer._exception is None  # Should remain None
    mock_task.exception.assert_called_once()


def test_agent_task_callback_cancelled_task(event_consumer: EventConsumer):
    """Test that agent_task_callback does nothing if the task has no exception."""
    mock_task = MagicMock(spec=asyncio.Task)
    mock_task.cancelled.return_value = True
    mock_task.done.return_value = True
    sample_exception = ValueError('Task still running')
    mock_task.exception.return_value = sample_exception

    event_consumer.agent_task_callback(mock_task)

    assert event_consumer._exception is None  # Should remain None
    mock_task.exception.assert_not_called()


def test_agent_task_callback_not_done_task(event_consumer: EventConsumer):
    """Test that agent_task_callback does nothing if the task has no exception."""
    mock_task = MagicMock(spec=asyncio.Task)
    mock_task.cancelled.return_value = False
    mock_task.done.return_value = False
    sample_exception = ValueError('Task is cancelled')
    mock_task.exception.return_value = sample_exception

    event_consumer.agent_task_callback(mock_task)

    assert event_consumer._exception is None  # Should remain None
    mock_task.exception.assert_not_called()


@pytest.mark.asyncio
async def test_consume_all_handles_validation_error(
    event_consumer: EventConsumer, mock_event_queue: AsyncMock
):
    """Test that consume_all gracefully handles a pydantic.ValidationError."""
    # Simulate dequeue_event raising a ValidationError
    mock_event_queue.dequeue_event.side_effect = [
        ValidationError.from_exception_data(title='Test Error', line_errors=[]),
        asyncio.CancelledError,  # To stop the loop for the test
    ]

    with patch(
        'a2a.server.events.event_consumer.logger.error'
    ) as logger_error_mock:
        with pytest.raises(asyncio.CancelledError):
            async for _ in event_consumer.consume_all():
                pass

        # Check that the specific error was logged and the consumer continued
        logger_error_mock.assert_called_once()
        assert (
            'Invalid event format received' in logger_error_mock.call_args[0][0]
        )



---
File: /a2a-python/tests/server/events/test_event_queue.py
---

import asyncio
import sys

from typing import Any
from unittest.mock import (
    AsyncMock,
    MagicMock,
    patch,
)

import pytest

from a2a.server.events.event_queue import DEFAULT_MAX_QUEUE_SIZE, EventQueue
from a2a.types import (
    A2AError,
    Artifact,
    JSONRPCError,
    Message,
    Part,
    Task,
    TaskArtifactUpdateEvent,
    TaskNotFoundError,
    TaskState,
    TaskStatus,
    TaskStatusUpdateEvent,
    TextPart,
)


MINIMAL_TASK: dict[str, Any] = {
    'id': '123',
    'context_id': 'session-xyz',
    'status': {'state': 'submitted'},
    'kind': 'task',
}
MESSAGE_PAYLOAD: dict[str, Any] = {
    'role': 'agent',
    'parts': [{'text': 'test message'}],
    'message_id': '111',
}


@pytest.fixture
def event_queue() -> EventQueue:
    return EventQueue()


def test_constructor_default_max_queue_size():
    """Test that the queue is created with the default max size."""
    eq = EventQueue()
    assert eq.queue.maxsize == DEFAULT_MAX_QUEUE_SIZE


def test_constructor_max_queue_size():
    """Test that the asyncio.Queue is created with the specified max_queue_size."""
    custom_size = 123
    eq = EventQueue(max_queue_size=custom_size)
    assert eq.queue.maxsize == custom_size


def test_constructor_invalid_max_queue_size():
    """Test that a ValueError is raised for non-positive max_queue_size."""
    with pytest.raises(
        ValueError, match='max_queue_size must be greater than 0'
    ):
        EventQueue(max_queue_size=0)
    with pytest.raises(
        ValueError, match='max_queue_size must be greater than 0'
    ):
        EventQueue(max_queue_size=-10)


@pytest.mark.asyncio
async def test_enqueue_and_dequeue_event(event_queue: EventQueue) -> None:
    """Test that an event can be enqueued and dequeued."""
    event = Message(**MESSAGE_PAYLOAD)
    await event_queue.enqueue_event(event)
    dequeued_event = await event_queue.dequeue_event()
    assert dequeued_event == event


@pytest.mark.asyncio
async def test_dequeue_event_no_wait(event_queue: EventQueue) -> None:
    """Test dequeue_event with no_wait=True."""
    event = Task(**MINIMAL_TASK)
    await event_queue.enqueue_event(event)
    dequeued_event = await event_queue.dequeue_event(no_wait=True)
    assert dequeued_event == event


@pytest.mark.asyncio
async def test_dequeue_event_empty_queue_no_wait(
    event_queue: EventQueue,
) -> None:
    """Test dequeue_event with no_wait=True when the queue is empty."""
    with pytest.raises(asyncio.QueueEmpty):
        await event_queue.dequeue_event(no_wait=True)


@pytest.mark.asyncio
async def test_dequeue_event_wait(event_queue: EventQueue) -> None:
    """Test dequeue_event with the default wait behavior."""
    event = TaskStatusUpdateEvent(
        task_id='task_123',
        context_id='session-xyz',
        status=TaskStatus(state=TaskState.working),
        final=True,
    )
    await event_queue.enqueue_event(event)
    dequeued_event = await event_queue.dequeue_event()
    assert dequeued_event == event


@pytest.mark.asyncio
async def test_task_done(event_queue: EventQueue) -> None:
    """Test the task_done method."""
    event = TaskArtifactUpdateEvent(
        task_id='task_123',
        context_id='session-xyz',
        artifact=Artifact(
            artifact_id='11', parts=[Part(TextPart(text='text'))]
        ),
    )
    await event_queue.enqueue_event(event)
    _ = await event_queue.dequeue_event()
    event_queue.task_done()


@pytest.mark.asyncio
async def test_enqueue_different_event_types(
    event_queue: EventQueue,
) -> None:
    """Test enqueuing different types of events."""
    events: list[Any] = [
        A2AError(TaskNotFoundError()),
        JSONRPCError(code=111, message='rpc error'),
    ]
    for event in events:
        await event_queue.enqueue_event(event)
        dequeued_event = await event_queue.dequeue_event()
        assert dequeued_event == event


@pytest.mark.asyncio
async def test_enqueue_event_propagates_to_children(
    event_queue: EventQueue,
) -> None:
    """Test that events are enqueued to tapped child queues."""
    child_queue1 = event_queue.tap()
    child_queue2 = event_queue.tap()

    event1 = Message(**MESSAGE_PAYLOAD)
    event2 = Task(**MINIMAL_TASK)

    await event_queue.enqueue_event(event1)
    await event_queue.enqueue_event(event2)

    # Check parent queue
    assert await event_queue.dequeue_event(no_wait=True) == event1
    assert await event_queue.dequeue_event(no_wait=True) == event2

    # Check child queue 1
    assert await child_queue1.dequeue_event(no_wait=True) == event1
    assert await child_queue1.dequeue_event(no_wait=True) == event2

    # Check child queue 2
    assert await child_queue2.dequeue_event(no_wait=True) == event1
    assert await child_queue2.dequeue_event(no_wait=True) == event2


@pytest.mark.asyncio
async def test_enqueue_event_when_closed(event_queue: EventQueue) -> None:
    """Test that no event is enqueued if the parent queue is closed."""
    await event_queue.close()  # Close the queue first

    event = Message(**MESSAGE_PAYLOAD)
    # Attempt to enqueue, should do nothing or log a warning as per implementation
    await event_queue.enqueue_event(event)

    # Verify the queue is still empty
    with pytest.raises(asyncio.QueueEmpty):
        await event_queue.dequeue_event(no_wait=True)

    # Also verify child queues are not affected directly by parent's enqueue attempt when closed
    # (though they would be closed too by propagation)
    child_queue = (
        event_queue.tap()
    )  # Tap after close might be weird, but let's see
    # The current implementation would add it to _children
    # and then child.close() would be called.
    # A more robust test for child propagation is in test_close_propagates
    await (
        child_queue.close()
    )  # ensure child is also seen as closed for this test's purpose
    with pytest.raises(asyncio.QueueEmpty):
        await child_queue.dequeue_event(no_wait=True)


@pytest.fixture
def expected_queue_closed_exception():
    if sys.version_info < (3, 13):
        return asyncio.QueueEmpty
    return asyncio.QueueShutDown


@pytest.mark.asyncio
async def test_dequeue_event_closed_and_empty_no_wait(
    event_queue: EventQueue, expected_queue_closed_exception
) -> None:
    """Test dequeue_event raises QueueEmpty when closed, empty, and no_wait=True."""
    await event_queue.close()
    assert event_queue.is_closed()
    # Ensure queue is actually empty (e.g. by trying a non-blocking get on internal queue)
    with pytest.raises(expected_queue_closed_exception):
        event_queue.queue.get_nowait()

    with pytest.raises(asyncio.QueueEmpty, match='Queue is closed.'):
        await event_queue.dequeue_event(no_wait=True)


@pytest.mark.asyncio
async def test_dequeue_event_closed_and_empty_waits_then_raises(
    event_queue: EventQueue, expected_queue_closed_exception
) -> None:
    """Test dequeue_event raises QueueEmpty eventually when closed, empty, and no_wait=False."""
    await event_queue.close()
    assert event_queue.is_closed()
    with pytest.raises(expected_queue_closed_exception):
        event_queue.queue.get_nowait()  # verify internal queue is empty

    # This test is tricky because await event_queue.dequeue_event() would hang if not for the close check.
    # The current implementation's dequeue_event checks `is_closed` first.
    # If closed and empty, it raises QueueEmpty immediately.
    # The "waits_then_raises" scenario described in the subtask implies the `get()` might wait.
    # However, the current code:
    # async with self._lock:
    #     if self._is_closed and self.queue.empty():
    #         logger.warning('Queue is closed. Event will not be dequeued.')
    #         raise asyncio.QueueEmpty('Queue is closed.')
    # event = await self.queue.get() -> this line is not reached if closed and empty.

    # So, for the current implementation, it will raise QueueEmpty immediately.
    with pytest.raises(asyncio.QueueEmpty, match='Queue is closed.'):
        await event_queue.dequeue_event(no_wait=False)

    # If the implementation were to change to allow `await self.queue.get()`
    # to be called even when closed (to drain it), then a timeout test would be needed.
    # For now, testing the current behavior.
    # Example of a timeout test if it were to wait:
    # with pytest.raises(asyncio.TimeoutError): # Or QueueEmpty if that's what join/shutdown causes get() to raise
    #     await asyncio.wait_for(event_queue.dequeue_event(no_wait=False), timeout=0.01)


@pytest.mark.asyncio
async def test_tap_creates_child_queue(event_queue: EventQueue) -> None:
    """Test that tap creates a new EventQueue and adds it to children."""
    initial_children_count = len(event_queue._children)

    child_queue = event_queue.tap()

    assert isinstance(child_queue, EventQueue)
    assert child_queue != event_queue  # Ensure it's a new instance
    assert len(event_queue._children) == initial_children_count + 1
    assert child_queue in event_queue._children

    # Test that the new child queue has the default max size (or specific if tap could configure it)
    assert child_queue.queue.maxsize == DEFAULT_MAX_QUEUE_SIZE


@pytest.mark.asyncio
@patch(
    'asyncio.wait'
)  # To monitor calls to asyncio.wait for older Python versions
@patch(
    'asyncio.create_task'
)  # To monitor calls to asyncio.create_task for older Python versions
async def test_close_sets_flag_and_handles_internal_queue_old_python(
    mock_create_task: MagicMock,
    mock_asyncio_wait: AsyncMock,
    event_queue: EventQueue,
) -> None:
    """Test close behavior on Python < 3.13 (using queue.join)."""
    with patch('sys.version_info', (3, 12, 0)):  # Simulate older Python
        # Mock queue.join as it's called in older versions
        event_queue.queue.join = AsyncMock()

        await event_queue.close()

        assert event_queue.is_closed() is True
        event_queue.queue.join.assert_called_once()  # specific to <3.13
        mock_create_task.assert_called_once()  # create_task for join
        mock_asyncio_wait.assert_called_once()  # wait for join


@pytest.mark.asyncio
async def test_close_sets_flag_and_handles_internal_queue_new_python(
    event_queue: EventQueue,
) -> None:
    """Test close behavior on Python >= 3.13 (using queue.shutdown)."""
    with patch('sys.version_info', (3, 13, 0)):  # Simulate Python 3.13+
        # Mock queue.shutdown as it's called in newer versions
        event_queue.queue.shutdown = MagicMock()  # shutdown is not async

        await event_queue.close()

        assert event_queue.is_closed() is True
        event_queue.queue.shutdown.assert_called_once()  # specific to >=3.13


@pytest.mark.asyncio
async def test_close_propagates_to_children(event_queue: EventQueue) -> None:
    """Test that close() is called on all child queues."""
    child_queue1 = event_queue.tap()
    child_queue2 = event_queue.tap()

    # Mock the close method of children to verify they are called
    child_queue1.close = AsyncMock()
    child_queue2.close = AsyncMock()

    await event_queue.close()

    child_queue1.close.assert_awaited_once()
    child_queue2.close.assert_awaited_once()


@pytest.mark.asyncio
async def test_close_idempotent(event_queue: EventQueue) -> None:
    """Test that calling close() multiple times doesn't cause errors and only acts once."""
    # Mock the internal queue's join or shutdown to see how many times it's effectively called
    with patch(
        'sys.version_info', (3, 12, 0)
    ):  # Test with older version logic first
        event_queue.queue.join = AsyncMock()
        await event_queue.close()
        assert event_queue.is_closed() is True
        event_queue.queue.join.assert_called_once()  # Called first time

        # Call close again
        await event_queue.close()
        assert event_queue.is_closed() is True
        event_queue.queue.join.assert_called_once()  # Still only called once

    # Reset for new Python version test
    event_queue_new = EventQueue()  # New queue for fresh state
    with patch('sys.version_info', (3, 13, 0)):  # Test with newer version logic
        event_queue_new.queue.shutdown = MagicMock()
        await event_queue_new.close()
        assert event_queue_new.is_closed() is True
        event_queue_new.queue.shutdown.assert_called_once()

        await event_queue_new.close()
        assert event_queue_new.is_closed() is True
        event_queue_new.queue.shutdown.assert_called_once()  # Still only called once


@pytest.mark.asyncio
async def test_is_closed_reflects_state(event_queue: EventQueue) -> None:
    """Test that is_closed() returns the correct state before and after closing."""
    assert event_queue.is_closed() is False  # Initially open

    await event_queue.close()

    assert event_queue.is_closed() is True  # Closed after calling close()



---
File: /a2a-python/tests/server/events/test_inmemory_queue_manager.py
---

import asyncio

from unittest.mock import MagicMock

import pytest

from a2a.server.events import InMemoryQueueManager
from a2a.server.events.event_queue import EventQueue
from a2a.server.events.queue_manager import (
    NoTaskQueue,
    TaskQueueExists,
)


class TestInMemoryQueueManager:
    @pytest.fixture
    def queue_manager(self):
        """Fixture to create a fresh InMemoryQueueManager for each test."""
        return InMemoryQueueManager()

    @pytest.fixture
    def event_queue(self):
        """Fixture to create a mock EventQueue."""
        queue = MagicMock(spec=EventQueue)
        # Mock the tap method to return itself
        queue.tap.return_value = queue
        return queue

    @pytest.mark.asyncio
    async def test_init(self, queue_manager):
        """Test that the InMemoryQueueManager initializes with empty task queue and a lock."""
        assert queue_manager._task_queue == {}
        assert isinstance(queue_manager._lock, asyncio.Lock)

    @pytest.mark.asyncio
    async def test_add_new_queue(self, queue_manager, event_queue):
        """Test adding a new queue to the manager."""
        task_id = 'test_task_id'
        await queue_manager.add(task_id, event_queue)
        assert queue_manager._task_queue[task_id] == event_queue

    @pytest.mark.asyncio
    async def test_add_existing_queue(self, queue_manager, event_queue):
        """Test adding a queue with an existing task_id raises TaskQueueExists."""
        task_id = 'test_task_id'
        await queue_manager.add(task_id, event_queue)

        with pytest.raises(TaskQueueExists):
            await queue_manager.add(task_id, event_queue)

    @pytest.mark.asyncio
    async def test_get_existing_queue(self, queue_manager, event_queue):
        """Test getting an existing queue returns the queue."""
        task_id = 'test_task_id'
        await queue_manager.add(task_id, event_queue)

        result = await queue_manager.get(task_id)
        assert result == event_queue

    @pytest.mark.asyncio
    async def test_get_nonexistent_queue(self, queue_manager):
        """Test getting a nonexistent queue returns None."""
        result = await queue_manager.get('nonexistent_task_id')
        assert result is None

    @pytest.mark.asyncio
    async def test_tap_existing_queue(self, queue_manager, event_queue):
        """Test tapping an existing queue returns the tapped queue."""
        task_id = 'test_task_id'
        await queue_manager.add(task_id, event_queue)

        result = await queue_manager.tap(task_id)
        assert result == event_queue
        event_queue.tap.assert_called_once()

    @pytest.mark.asyncio
    async def test_tap_nonexistent_queue(self, queue_manager):
        """Test tapping a nonexistent queue returns None."""
        result = await queue_manager.tap('nonexistent_task_id')
        assert result is None

    @pytest.mark.asyncio
    async def test_close_existing_queue(self, queue_manager, event_queue):
        """Test closing an existing queue removes it from the manager."""
        task_id = 'test_task_id'
        await queue_manager.add(task_id, event_queue)

        await queue_manager.close(task_id)
        assert task_id not in queue_manager._task_queue

    @pytest.mark.asyncio
    async def test_close_nonexistent_queue(self, queue_manager):
        """Test closing a nonexistent queue raises NoTaskQueue."""
        with pytest.raises(NoTaskQueue):
            await queue_manager.close('nonexistent_task_id')

    @pytest.mark.asyncio
    async def test_create_or_tap_new_queue(self, queue_manager):
        """Test create_or_tap with a new task_id creates and returns a new queue."""
        task_id = 'test_task_id'

        result = await queue_manager.create_or_tap(task_id)
        assert isinstance(result, EventQueue)
        assert queue_manager._task_queue[task_id] == result

    @pytest.mark.asyncio
    async def test_create_or_tap_existing_queue(
        self, queue_manager, event_queue
    ):
        """Test create_or_tap with an existing task_id taps and returns the existing queue."""
        task_id = 'test_task_id'
        await queue_manager.add(task_id, event_queue)

        result = await queue_manager.create_or_tap(task_id)

        assert result == event_queue
        event_queue.tap.assert_called_once()

    @pytest.mark.asyncio
    async def test_concurrency(self, queue_manager):
        """Test concurrent access to the queue manager."""

        async def add_task(task_id):
            queue = EventQueue()
            await queue_manager.add(task_id, queue)
            return task_id

        async def get_task(task_id):
            return await queue_manager.get(task_id)

        # Create 10 different task IDs
        task_ids = [f'task_{i}' for i in range(10)]

        # Add tasks concurrently
        add_tasks = [add_task(task_id) for task_id in task_ids]
        added_task_ids = await asyncio.gather(*add_tasks)

        # Verify all tasks were added
        assert set(added_task_ids) == set(task_ids)

        # Get tasks concurrently
        get_tasks = [get_task(task_id) for task_id in task_ids]
        queues = await asyncio.gather(*get_tasks)

        # Verify all queues are not None
        assert all(queue is not None for queue in queues)

        # Verify all tasks are in the manager
        for task_id in task_ids:
            assert task_id in queue_manager._task_queue



---
File: /a2a-python/tests/server/request_handlers/test_default_request_handler.py
---

import asyncio
import logging
import time

from unittest.mock import (
    AsyncMock,
    MagicMock,
    PropertyMock,
    patch,
)

import pytest

from a2a.server.agent_execution import (
    AgentExecutor,
    RequestContext,
    RequestContextBuilder,
    SimpleRequestContextBuilder,
)
from a2a.server.context import ServerCallContext
from a2a.server.events import EventQueue, InMemoryQueueManager, QueueManager
from a2a.server.request_handlers import DefaultRequestHandler
from a2a.server.tasks import (
    InMemoryPushNotificationConfigStore,
    InMemoryTaskStore,
    PushNotificationConfigStore,
    PushNotificationSender,
    ResultAggregator,
    TaskStore,
    TaskUpdater,
)
from a2a.types import (
    DeleteTaskPushNotificationConfigParams,
    GetTaskPushNotificationConfigParams,
    InternalError,
    InvalidParamsError,
    ListTaskPushNotificationConfigParams,
    Message,
    MessageSendConfiguration,
    MessageSendParams,
    Part,
    PushNotificationConfig,
    Role,
    Task,
    TaskIdParams,
    TaskNotFoundError,
    TaskPushNotificationConfig,
    TaskQueryParams,
    TaskState,
    TaskStatus,
    TextPart,
    UnsupportedOperationError,
)
from a2a.utils import (
    new_task,
)


class DummyAgentExecutor(AgentExecutor):
    async def execute(self, context: RequestContext, event_queue: EventQueue):
        task_updater = TaskUpdater(
            event_queue, context.task_id, context.context_id
        )
        async for i in self._run():
            parts = [Part(root=TextPart(text=f'Event {i}'))]
            try:
                await task_updater.update_status(
                    TaskState.working,
                    message=task_updater.new_agent_message(parts),
                )
            except RuntimeError:
                # Stop processing when the event loop is closed
                break

    async def _run(self):
        for i in range(1_000_000):  # Simulate a long-running stream
            yield i

    async def cancel(self, context: RequestContext, event_queue: EventQueue):
        pass


# Helper to create a simple task for tests
def create_sample_task(
    task_id='task1', status_state=TaskState.submitted, context_id='ctx1'
) -> Task:
    return Task(
        id=task_id,
        context_id=context_id,
        status=TaskStatus(state=status_state),
    )


# Helper to create ServerCallContext
def create_server_call_context() -> ServerCallContext:
    # Assuming UnauthenticatedUser is available or can be imported
    from a2a.auth.user import UnauthenticatedUser

    return ServerCallContext(user=UnauthenticatedUser())


def test_init_default_dependencies():
    """Test that default dependencies are created if not provided."""
    agent_executor = DummyAgentExecutor()
    task_store = InMemoryTaskStore()

    handler = DefaultRequestHandler(
        agent_executor=agent_executor, task_store=task_store
    )

    assert isinstance(handler._queue_manager, InMemoryQueueManager)
    assert isinstance(
        handler._request_context_builder, SimpleRequestContextBuilder
    )
    assert handler._push_config_store is None
    assert handler._push_sender is None
    assert (
        handler._request_context_builder._should_populate_referred_tasks
        is False
    )
    assert handler._request_context_builder._task_store == task_store


@pytest.mark.asyncio
async def test_on_get_task_not_found():
    """Test on_get_task when task_store.get returns None."""
    mock_task_store = AsyncMock(spec=TaskStore)
    mock_task_store.get.return_value = None

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(), task_store=mock_task_store
    )

    params = TaskQueryParams(id='non_existent_task')

    from a2a.utils.errors import ServerError  # Local import for ServerError

    with pytest.raises(ServerError) as exc_info:
        await request_handler.on_get_task(params, create_server_call_context())

    assert isinstance(exc_info.value.error, TaskNotFoundError)
    mock_task_store.get.assert_awaited_once_with('non_existent_task')


@pytest.mark.asyncio
async def test_on_cancel_task_task_not_found():
    """Test on_cancel_task when the task is not found."""
    mock_task_store = AsyncMock(spec=TaskStore)
    mock_task_store.get.return_value = None

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(), task_store=mock_task_store
    )
    params = TaskIdParams(id='task_not_found_for_cancel')

    from a2a.utils.errors import ServerError  # Local import

    with pytest.raises(ServerError) as exc_info:
        await request_handler.on_cancel_task(
            params, create_server_call_context()
        )

    assert isinstance(exc_info.value.error, TaskNotFoundError)
    mock_task_store.get.assert_awaited_once_with('task_not_found_for_cancel')


@pytest.mark.asyncio
async def test_on_cancel_task_queue_tap_returns_none():
    """Test on_cancel_task when queue_manager.tap returns None."""
    mock_task_store = AsyncMock(spec=TaskStore)
    sample_task = create_sample_task(task_id='tap_none_task')
    mock_task_store.get.return_value = sample_task

    mock_queue_manager = AsyncMock(spec=QueueManager)
    mock_queue_manager.tap.return_value = (
        None  # Simulate queue not found / tap returns None
    )

    mock_agent_executor = AsyncMock(
        spec=AgentExecutor
    )  # Use AsyncMock for agent_executor

    # Mock ResultAggregator and its consume_all method
    mock_result_aggregator_instance = AsyncMock(spec=ResultAggregator)
    mock_result_aggregator_instance.consume_all.return_value = (
        create_sample_task(
            task_id='tap_none_task',
            status_state=TaskState.canceled,  # Expected final state
        )
    )

    request_handler = DefaultRequestHandler(
        agent_executor=mock_agent_executor,
        task_store=mock_task_store,
        queue_manager=mock_queue_manager,
    )

    with patch(
        'a2a.server.request_handlers.default_request_handler.ResultAggregator',
        return_value=mock_result_aggregator_instance,
    ):
        params = TaskIdParams(id='tap_none_task')
        result_task = await request_handler.on_cancel_task(
            params, create_server_call_context()
        )

    mock_task_store.get.assert_awaited_once_with('tap_none_task')
    mock_queue_manager.tap.assert_awaited_once_with('tap_none_task')
    # agent_executor.cancel should be called with a new EventQueue if tap returned None
    mock_agent_executor.cancel.assert_awaited_once()
    # Verify the EventQueue passed to cancel was a new one
    call_args_list = mock_agent_executor.cancel.call_args_list
    args, _ = call_args_list[0]
    assert isinstance(
        args[1], EventQueue
    )  # args[1] is the event_queue argument

    mock_result_aggregator_instance.consume_all.assert_awaited_once()
    assert result_task is not None
    assert result_task.status.state == TaskState.canceled


@pytest.mark.asyncio
async def test_on_cancel_task_cancels_running_agent():
    """Test on_cancel_task cancels a running agent task."""
    task_id = 'running_agent_task_to_cancel'
    sample_task = create_sample_task(task_id=task_id)
    mock_task_store = AsyncMock(spec=TaskStore)
    mock_task_store.get.return_value = sample_task

    mock_queue_manager = AsyncMock(spec=QueueManager)
    mock_event_queue = AsyncMock(spec=EventQueue)
    mock_queue_manager.tap.return_value = mock_event_queue

    mock_agent_executor = AsyncMock(spec=AgentExecutor)

    # Mock ResultAggregator
    mock_result_aggregator_instance = AsyncMock(spec=ResultAggregator)
    mock_result_aggregator_instance.consume_all.return_value = (
        create_sample_task(task_id=task_id, status_state=TaskState.canceled)
    )

    request_handler = DefaultRequestHandler(
        agent_executor=mock_agent_executor,
        task_store=mock_task_store,
        queue_manager=mock_queue_manager,
    )

    # Simulate a running agent task
    mock_producer_task = AsyncMock(spec=asyncio.Task)
    request_handler._running_agents[task_id] = mock_producer_task

    with patch(
        'a2a.server.request_handlers.default_request_handler.ResultAggregator',
        return_value=mock_result_aggregator_instance,
    ):
        params = TaskIdParams(id=task_id)
        await request_handler.on_cancel_task(
            params, create_server_call_context()
        )

    mock_producer_task.cancel.assert_called_once()
    mock_agent_executor.cancel.assert_awaited_once()


@pytest.mark.asyncio
async def test_on_cancel_task_invalid_result_type():
    """Test on_cancel_task when result_aggregator returns a Message instead of a Task."""
    task_id = 'cancel_invalid_result_task'
    sample_task = create_sample_task(task_id=task_id)
    mock_task_store = AsyncMock(spec=TaskStore)
    mock_task_store.get.return_value = sample_task

    mock_queue_manager = AsyncMock(spec=QueueManager)
    mock_event_queue = AsyncMock(spec=EventQueue)
    mock_queue_manager.tap.return_value = mock_event_queue

    mock_agent_executor = AsyncMock(spec=AgentExecutor)

    # Mock ResultAggregator to return a Message
    mock_result_aggregator_instance = AsyncMock(spec=ResultAggregator)
    mock_result_aggregator_instance.consume_all.return_value = Message(
        message_id='unexpected_msg', role=Role.agent, parts=[]
    )

    request_handler = DefaultRequestHandler(
        agent_executor=mock_agent_executor,
        task_store=mock_task_store,
        queue_manager=mock_queue_manager,
    )

    from a2a.utils.errors import ServerError  # Local import

    with patch(
        'a2a.server.request_handlers.default_request_handler.ResultAggregator',
        return_value=mock_result_aggregator_instance,
    ):
        params = TaskIdParams(id=task_id)
        with pytest.raises(ServerError) as exc_info:
            await request_handler.on_cancel_task(
                params, create_server_call_context()
            )

    assert isinstance(exc_info.value.error, InternalError)
    assert (
        'Agent did not return valid response for cancel'
        in exc_info.value.error.message
    )  # type: ignore


@pytest.mark.asyncio
async def test_on_message_send_with_push_notification():
    """Test on_message_send sets push notification info if provided."""
    mock_task_store = AsyncMock(spec=TaskStore)
    mock_push_notification_store = AsyncMock(spec=PushNotificationConfigStore)
    mock_agent_executor = AsyncMock(spec=AgentExecutor)
    mock_request_context_builder = AsyncMock(spec=RequestContextBuilder)

    task_id = 'push_task_1'
    context_id = 'push_ctx_1'
    sample_initial_task = create_sample_task(
        task_id=task_id, context_id=context_id, status_state=TaskState.submitted
    )

    # TaskManager will be created inside on_message_send.
    # We need to mock task_store.get to return None initially for TaskManager to create a new task.
    # Then, TaskManager.update_with_message will be called.
    # For simplicity in this unit test, let's assume TaskManager correctly sets up the task
    # and the task object (with IDs) is available for _request_context_builder.build

    mock_task_store.get.return_value = (
        None  # Simulate new task scenario for TaskManager
    )

    # Mock _request_context_builder.build to return a context with the generated/confirmed IDs
    mock_request_context = MagicMock(spec=RequestContext)
    mock_request_context.task_id = task_id
    mock_request_context.context_id = context_id
    mock_request_context_builder.build.return_value = mock_request_context

    request_handler = DefaultRequestHandler(
        agent_executor=mock_agent_executor,
        task_store=mock_task_store,
        push_config_store=mock_push_notification_store,
        request_context_builder=mock_request_context_builder,
    )

    push_config = PushNotificationConfig(url='http://callback.com/push')
    message_config = MessageSendConfiguration(
        push_notification_config=push_config,
        accepted_output_modes=['text/plain'],  # Added required field
    )
    params = MessageSendParams(
        message=Message(
            role=Role.user,
            message_id='msg_push',
            parts=[],
            task_id=task_id,
            context_id=context_id,
        ),
        configuration=message_config,
    )

    # Mock ResultAggregator and its consume_and_break_on_interrupt
    mock_result_aggregator_instance = AsyncMock(spec=ResultAggregator)
    final_task_result = create_sample_task(
        task_id=task_id, context_id=context_id, status_state=TaskState.completed
    )
    mock_result_aggregator_instance.consume_and_break_on_interrupt.return_value = (
        final_task_result,
        False,
    )

    # Mock the current_result property to return the final task result
    async def get_current_result():
        return final_task_result

    # Configure the 'current_result' property on the type of the mock instance
    type(mock_result_aggregator_instance).current_result = PropertyMock(
        return_value=get_current_result()
    )

    with (
        patch(
            'a2a.server.request_handlers.default_request_handler.ResultAggregator',
            return_value=mock_result_aggregator_instance,
        ),
        patch(
            'a2a.server.request_handlers.default_request_handler.TaskManager.get_task',
            return_value=sample_initial_task,
        ),
        patch(
            'a2a.server.request_handlers.default_request_handler.TaskManager.update_with_message',
            return_value=sample_initial_task,
        ),
    ):  # Ensure task object is returned
        await request_handler.on_message_send(
            params, create_server_call_context()
        )

    mock_push_notification_store.set_info.assert_awaited_once_with(
        task_id, push_config
    )
    # Other assertions for full flow if needed (e.g., agent execution)
    mock_agent_executor.execute.assert_awaited_once()


@pytest.mark.asyncio
async def test_on_message_send_with_push_notification_no_existing_Task():
    """Test on_message_send for new task sets push notification info if provided."""
    mock_task_store = AsyncMock(spec=TaskStore)
    mock_push_notification_store = AsyncMock(spec=PushNotificationConfigStore)
    mock_agent_executor = AsyncMock(spec=AgentExecutor)
    mock_request_context_builder = AsyncMock(spec=RequestContextBuilder)

    task_id = 'push_task_1'
    context_id = 'push_ctx_1'

    mock_task_store.get.return_value = (
        None  # Simulate new task scenario for TaskManager
    )

    # Mock _request_context_builder.build to return a context with the generated/confirmed IDs
    mock_request_context = MagicMock(spec=RequestContext)
    mock_request_context.task_id = task_id
    mock_request_context.context_id = context_id
    mock_request_context_builder.build.return_value = mock_request_context

    request_handler = DefaultRequestHandler(
        agent_executor=mock_agent_executor,
        task_store=mock_task_store,
        push_config_store=mock_push_notification_store,
        request_context_builder=mock_request_context_builder,
    )

    push_config = PushNotificationConfig(url='http://callback.com/push')
    message_config = MessageSendConfiguration(
        push_notification_config=push_config,
        accepted_output_modes=['text/plain'],  # Added required field
    )
    params = MessageSendParams(
        message=Message(role=Role.user, message_id='msg_push', parts=[]),
        configuration=message_config,
    )

    # Mock ResultAggregator and its consume_and_break_on_interrupt
    mock_result_aggregator_instance = AsyncMock(spec=ResultAggregator)
    final_task_result = create_sample_task(
        task_id=task_id, context_id=context_id, status_state=TaskState.completed
    )
    mock_result_aggregator_instance.consume_and_break_on_interrupt.return_value = (
        final_task_result,
        False,
    )

    # Mock the current_result property to return the final task result
    async def get_current_result():
        return final_task_result

    # Configure the 'current_result' property on the type of the mock instance
    type(mock_result_aggregator_instance).current_result = PropertyMock(
        return_value=get_current_result()
    )

    with (
        patch(
            'a2a.server.request_handlers.default_request_handler.ResultAggregator',
            return_value=mock_result_aggregator_instance,
        ),
        patch(
            'a2a.server.request_handlers.default_request_handler.TaskManager.get_task',
            return_value=None,
        ),
    ):
        await request_handler.on_message_send(
            params, create_server_call_context()
        )

    mock_push_notification_store.set_info.assert_awaited_once_with(
        task_id, push_config
    )
    # Other assertions for full flow if needed (e.g., agent execution)
    mock_agent_executor.execute.assert_awaited_once()


@pytest.mark.asyncio
async def test_on_message_send_no_result_from_aggregator():
    """Test on_message_send when aggregator returns (None, False)."""
    mock_task_store = AsyncMock(spec=TaskStore)
    mock_agent_executor = AsyncMock(spec=AgentExecutor)
    mock_request_context_builder = AsyncMock(spec=RequestContextBuilder)

    task_id = 'no_result_task'
    # Mock _request_context_builder.build
    mock_request_context = MagicMock(spec=RequestContext)
    mock_request_context.task_id = task_id
    mock_request_context_builder.build.return_value = mock_request_context

    request_handler = DefaultRequestHandler(
        agent_executor=mock_agent_executor,
        task_store=mock_task_store,
        request_context_builder=mock_request_context_builder,
    )
    params = MessageSendParams(
        message=Message(role=Role.user, message_id='msg_no_res', parts=[])
    )

    mock_result_aggregator_instance = AsyncMock(spec=ResultAggregator)
    mock_result_aggregator_instance.consume_and_break_on_interrupt.return_value = (
        None,
        False,
    )

    from a2a.utils.errors import ServerError  # Local import

    with (
        patch(
            'a2a.server.request_handlers.default_request_handler.ResultAggregator',
            return_value=mock_result_aggregator_instance,
        ),
        patch(
            'a2a.server.request_handlers.default_request_handler.TaskManager.get_task',
            return_value=None,
        ),
    ):  # TaskManager.get_task for initial task
        with pytest.raises(ServerError) as exc_info:
            await request_handler.on_message_send(
                params, create_server_call_context()
            )

    assert isinstance(exc_info.value.error, InternalError)


@pytest.mark.asyncio
async def test_on_message_send_task_id_mismatch():
    """Test on_message_send when result task ID doesn't match request context task ID."""
    mock_task_store = AsyncMock(spec=TaskStore)
    mock_agent_executor = AsyncMock(spec=AgentExecutor)
    mock_request_context_builder = AsyncMock(spec=RequestContextBuilder)

    context_task_id = 'context_task_id_1'
    result_task_id = 'DIFFERENT_task_id_1'  # Mismatch

    # Mock _request_context_builder.build
    mock_request_context = MagicMock(spec=RequestContext)
    mock_request_context.task_id = context_task_id
    mock_request_context_builder.build.return_value = mock_request_context

    request_handler = DefaultRequestHandler(
        agent_executor=mock_agent_executor,
        task_store=mock_task_store,
        request_context_builder=mock_request_context_builder,
    )
    params = MessageSendParams(
        message=Message(role=Role.user, message_id='msg_id_mismatch', parts=[])
    )

    mock_result_aggregator_instance = AsyncMock(spec=ResultAggregator)
    mismatched_task = create_sample_task(task_id=result_task_id)
    mock_result_aggregator_instance.consume_and_break_on_interrupt.return_value = (
        mismatched_task,
        False,
    )

    from a2a.utils.errors import ServerError  # Local import

    with (
        patch(
            'a2a.server.request_handlers.default_request_handler.ResultAggregator',
            return_value=mock_result_aggregator_instance,
        ),
        patch(
            'a2a.server.request_handlers.default_request_handler.TaskManager.get_task',
            return_value=None,
        ),
    ):
        with pytest.raises(ServerError) as exc_info:
            await request_handler.on_message_send(
                params, create_server_call_context()
            )

    assert isinstance(exc_info.value.error, InternalError)
    assert 'Task ID mismatch' in exc_info.value.error.message  # type: ignore


class HelloAgentExecutor(AgentExecutor):
    async def execute(self, context: RequestContext, event_queue: EventQueue):
        task = context.current_task
        if not task:
            assert context.message is not None, (
                'A message is required to create a new task'
            )
            task = new_task(context.message)  # type: ignore
            await event_queue.enqueue_event(task)
        updater = TaskUpdater(event_queue, task.id, task.context_id)

        try:
            parts = [Part(root=TextPart(text='I am working'))]
            await updater.update_status(
                TaskState.working,
                message=updater.new_agent_message(parts),
            )
        except Exception as e:
            # Stop processing when the event loop is closed
            logging.warning('Error: %s', e)
            return
        await updater.add_artifact(
            [Part(root=TextPart(text='Hello world!'))],
            name='conversion_result',
        )
        await updater.complete()

    async def cancel(self, context: RequestContext, event_queue: EventQueue):
        pass


@pytest.mark.asyncio
async def test_on_message_send_non_blocking():
    task_store = InMemoryTaskStore()
    push_store = InMemoryPushNotificationConfigStore()

    request_handler = DefaultRequestHandler(
        agent_executor=HelloAgentExecutor(),
        task_store=task_store,
        push_config_store=push_store,
    )
    params = MessageSendParams(
        message=Message(
            role=Role.user,
            message_id='msg_push',
            parts=[Part(root=TextPart(text='Hi'))],
        ),
        configuration=MessageSendConfiguration(
            blocking=False, accepted_output_modes=['text/plain']
        ),
    )

    result = await request_handler.on_message_send(
        params, create_server_call_context()
    )

    assert result is not None
    assert isinstance(result, Task)
    assert result.status.state == TaskState.submitted

    # Polling for 500ms until task is completed.
    task: Task | None = None
    for _ in range(5):
        await asyncio.sleep(0.1)
        task = await task_store.get(result.id)
        assert task is not None
        if task.status.state == TaskState.completed:
            break

    assert task is not None
    assert task.status.state == TaskState.completed


@pytest.mark.asyncio
async def test_on_message_send_interrupted_flow():
    """Test on_message_send when flow is interrupted (e.g., auth_required)."""
    mock_task_store = AsyncMock(spec=TaskStore)
    mock_agent_executor = AsyncMock(spec=AgentExecutor)
    mock_request_context_builder = AsyncMock(spec=RequestContextBuilder)

    task_id = 'interrupted_task_1'
    # Mock _request_context_builder.build
    mock_request_context = MagicMock(spec=RequestContext)
    mock_request_context.task_id = task_id
    mock_request_context_builder.build.return_value = mock_request_context

    request_handler = DefaultRequestHandler(
        agent_executor=mock_agent_executor,
        task_store=mock_task_store,
        request_context_builder=mock_request_context_builder,
    )
    params = MessageSendParams(
        message=Message(role=Role.user, message_id='msg_interrupt', parts=[])
    )

    mock_result_aggregator_instance = AsyncMock(spec=ResultAggregator)
    interrupt_task_result = create_sample_task(
        task_id=task_id, status_state=TaskState.auth_required
    )
    mock_result_aggregator_instance.consume_and_break_on_interrupt.return_value = (
        interrupt_task_result,
        True,
    )  # Interrupted = True

    # Patch asyncio.create_task to verify _cleanup_producer is scheduled
    with (
        patch('asyncio.create_task') as mock_asyncio_create_task,
        patch(
            'a2a.server.request_handlers.default_request_handler.ResultAggregator',
            return_value=mock_result_aggregator_instance,
        ),
        patch(
            'a2a.server.request_handlers.default_request_handler.TaskManager.get_task',
            return_value=None,
        ),
    ):
        result = await request_handler.on_message_send(
            params, create_server_call_context()
        )

    assert result == interrupt_task_result
    assert (
        mock_asyncio_create_task.call_count == 2
    )  # First for _run_event_stream, second for _cleanup_producer

    # Check that the second call to create_task was for _cleanup_producer
    found_cleanup_call = False
    for call_args_tuple in mock_asyncio_create_task.call_args_list:
        created_coro = call_args_tuple[0][0]
        if (
            hasattr(created_coro, '__name__')
            and created_coro.__name__ == '_cleanup_producer'
        ):
            found_cleanup_call = True
            break
    assert found_cleanup_call, (
        '_cleanup_producer was not scheduled with asyncio.create_task'
    )


@pytest.mark.asyncio
async def test_on_message_send_stream_with_push_notification():
    """Test on_message_send_stream sets and uses push notification info."""
    mock_task_store = AsyncMock(spec=TaskStore)
    mock_push_config_store = AsyncMock(spec=PushNotificationConfigStore)
    mock_push_sender = AsyncMock(spec=PushNotificationSender)
    mock_agent_executor = AsyncMock(spec=AgentExecutor)
    mock_request_context_builder = AsyncMock(spec=RequestContextBuilder)

    task_id = 'stream_push_task_1'
    context_id = 'stream_push_ctx_1'

    # Initial task state for TaskManager
    initial_task_for_tm = create_sample_task(
        task_id=task_id, context_id=context_id, status_state=TaskState.submitted
    )

    # Task state for RequestContext
    task_for_rc = create_sample_task(
        task_id=task_id, context_id=context_id, status_state=TaskState.working
    )  # Example state after message update

    mock_task_store.get.return_value = None  # New task for TaskManager

    mock_request_context = MagicMock(spec=RequestContext)
    mock_request_context.task_id = task_id
    mock_request_context.context_id = context_id
    mock_request_context_builder.build.return_value = mock_request_context

    request_handler = DefaultRequestHandler(
        agent_executor=mock_agent_executor,
        task_store=mock_task_store,
        push_config_store=mock_push_config_store,
        push_sender=mock_push_sender,
        request_context_builder=mock_request_context_builder,
    )

    push_config = PushNotificationConfig(url='http://callback.stream.com/push')
    message_config = MessageSendConfiguration(
        push_notification_config=push_config,
        accepted_output_modes=['text/plain'],  # Added required field
    )
    params = MessageSendParams(
        message=Message(
            role=Role.user,
            message_id='msg_stream_push',
            parts=[],
            task_id=task_id,
            context_id=context_id,
        ),
        configuration=message_config,
    )

    # Mock ResultAggregator and its consume_and_emit
    mock_result_aggregator_instance = MagicMock(
        spec=ResultAggregator
    )  # Use MagicMock for easier property mocking

    # Events to be yielded by consume_and_emit
    event1_task_update = create_sample_task(
        task_id=task_id, context_id=context_id, status_state=TaskState.working
    )
    event2_final_task = create_sample_task(
        task_id=task_id, context_id=context_id, status_state=TaskState.completed
    )

    async def event_stream_gen():
        yield event1_task_update
        yield event2_final_task

    # consume_and_emit is called by `async for ... in result_aggregator.consume_and_emit(consumer)`
    # This means result_aggregator.consume_and_emit(consumer) must directly return an async iterable.
    # If consume_and_emit is an async method, this is problematic in the product code.
    # For the test, we make the mock of consume_and_emit a synchronous method
    # that returns the async generator object.
    def sync_get_event_stream_gen(*args, **kwargs):
        return event_stream_gen()

    mock_result_aggregator_instance.consume_and_emit = MagicMock(
        side_effect=sync_get_event_stream_gen
    )

    # Mock current_result property to return appropriate awaitables
    # Coroutines that will be returned by successive accesses to current_result
    async def current_result_coro1():
        return event1_task_update

    async def current_result_coro2():
        return event2_final_task

    # Use unittest.mock.PropertyMock for async property
    # We need to patch 'ResultAggregator.current_result' when this instance is used.
    # This is complex because ResultAggregator is instantiated inside the handler.
    # Easier: If mock_result_aggregator_instance is a MagicMock, we can assign a callable.
    # This part is tricky. Let's assume current_result is an async method for easier mocking first.
    # If it's truly a property, the mocking is harder with instance mocks.
    # Let's adjust the mock_result_aggregator_instance.current_result to be an AsyncMock directly
    # This means the code would call `await result_aggregator.current_result()`
    # But the actual code is `await result_aggregator.current_result`
    # This implies `result_aggregator.current_result` IS an awaitable.
    # So, we can mock it with a side_effect that returns awaitables (coroutines).

    # Create simple awaitables (coroutines) for side_effect
    async def get_event1():
        return event1_task_update

    async def get_event2():
        return event2_final_task

    # Make the current_result attribute of the mock instance itself an awaitable
    # This still means current_result is not callable.
    # For an async property, the mock needs to have current_result as a non-AsyncMock attribute
    # that is itself an awaitable.

    # Let's try to mock the property at the type level for ResultAggregator temporarily
    # This is not ideal as it affects all instances.

    # Alternative: Configure the AsyncMock for current_result to return a coroutine
    # when it's awaited. This is not directly supported by AsyncMock for property access.

    # Simplest for now: Assume `current_result` attribute of the mocked `ResultAggregator` instance
    # can be sequentially awaited if it's a list of awaitables that a test runner can handle.
    # This is likely to fail again but will clarify the exact point of await.
    # The error "TypeError: object AsyncMock can't be used in 'await' expression" means
    # `mock_result_aggregator_instance.current_result` is an AsyncMock, and that's what's awaited.
    # This AsyncMock needs to have a __await__ method.

    # Let's make the side_effect of the AsyncMock `current_result` provide the values.
    # This assumes that `await mock.property` somehow triggers a call to the mock.
    # This is not how AsyncMock works.

    # The code is `await result_aggregator.current_result`.
    # `result_aggregator` is an instance of `ResultAggregator`.
    # `current_result` is an async property.
    # So `result_aggregator.current_result` evaluates to a coroutine.
    # We need `mock_result_aggregator_instance.current_result` to be a coroutine,
    # or a list of coroutines if accessed multiple times.
    # This is best done by mocking the property itself.
    # Let's assume it's called twice.

    # We will patch ResultAggregator to be our mock_result_aggregator_instance
    # Then, we need to control what its `current_result` property returns.
    # We can use a PropertyMock for this, attached to the type of mock_result_aggregator_instance.

    # For this specific test, let's make current_result a simple async def method on the mock instance
    # This means we are slightly diverging from the "property" nature just for this mock.
    # Mock current_result property to return appropriate awaitables (coroutines) sequentially.
    async def get_event1_coro():
        return event1_task_update

    async def get_event2_coro():
        return event2_final_task

    # Configure the 'current_result' property on the type of the mock instance
    # This makes accessing `instance.current_result` call the side_effect function,
    # which then cycles through our list of coroutines.
    # We need a new PropertyMock for each instance, or patch the class.
    # Since mock_result_aggregator_instance is already created, we attach to its type.
    # This can be tricky. A more direct way is to ensure the instance's attribute `current_result`
    # behaves as desired. If `mock_result_aggregator_instance` is a `MagicMock`, its attributes are also mocks.

    # Let's make `current_result` a MagicMock whose side_effect returns the coroutines.
    # This means when `result_aggregator.current_result` is accessed, this mock is "called".
    # This isn't quite right for a property. A property isn't "called" on access.

    # Correct approach for mocking an async property on an instance mock:
    # Set the attribute `current_result` on the instance `mock_result_aggregator_instance`
    # to be a `PropertyMock` if we were patching the class.
    # Since we have the instance, we can try to replace its `current_result` attribute.
    # The instance `mock_result_aggregator_instance` is a `MagicMock`.
    # We can make `mock_result_aggregator_instance.current_result` a `PropertyMock`
    # that returns a coroutine. For multiple calls, `side_effect` on `PropertyMock` is a list of return_values.

    # Create a PropertyMock that will cycle through coroutines
    # This requires Python 3.8+ for PropertyMock to be directly usable with side_effect list for properties.
    # For older versions or for clarity with async properties, directly mocking the attribute
    # to be a series of awaitables is hard.
    # The easiest is to ensure `current_result` is an AsyncMock that returns the values.
    # The product code `await result_aggregator.current_result` means `current_result` must be an awaitable.

    # Let's make current_result an AsyncMock whose __call__ returns the sequence.
    # Mock current_result as an async property
    # Create coroutines that will be the "result" of awaiting the property
    async def get_current_result_coro1():
        return event1_task_update

    async def get_current_result_coro2():
        return event2_final_task

    # Configure the 'current_result' property on the mock_result_aggregator_instance
    # using PropertyMock attached to its type. This makes instance.current_result return
    # items from side_effect sequentially on each access.
    # Since current_result is an async property, these items should be coroutines.
    # We need to ensure that mock_result_aggregator_instance itself is the one patched.
    # The patch for ResultAggregator returns this instance.
    # So, we configure PropertyMock on the type of this specific mock instance.
    # This is slightly unusual; typically PropertyMock is used when patching a class.
    # A more straightforward approach for an instance is if its type is already a mock.
    # As mock_result_aggregator_instance is a MagicMock, we can configure its 'current_result'
    # attribute to be a PropertyMock.

    # Let's directly assign a PropertyMock to the type of the instance for `current_result`
    # This ensures that when `instance.current_result` is accessed, the PropertyMock's logic is triggered.
    # However, PropertyMock is usually used with `patch.object` or by setting it on the class.
    #
    # A simpler way for MagicMock instance:
    # `mock_result_aggregator_instance.current_result` is already a MagicMock (or AsyncMock if spec'd).
    # We need to make it return a coroutine upon access.
    # The most direct way to mock an async property on a MagicMock instance
    # such that it returns a sequence of awaitables:
    async def side_effect_current_result():
        yield event1_task_update
        yield event2_final_task

    # Create an async generator from the side effect
    current_result_gen = side_effect_current_result()

    # Make current_result return the next item from this generator (wrapped in a coroutine)
    # each time it's accessed.
    async def get_next_current_result():
        try:
            return await current_result_gen.__anext__()
        except StopAsyncIteration:
            # Handle case where it's awaited more times than values provided
            return None  # Or raise an error

    # Since current_result is a property, accessing it should return a coroutine.
    # We can achieve this by making mock_result_aggregator_instance.current_result
    # a MagicMock whose side_effect returns these coroutines.
    # This is still tricky because it's a property access.

    # Let's use the PropertyMock on the class being mocked via the patch.
    # Setup for consume_and_emit
    def sync_get_event_stream_gen_for_prop_test(*args, **kwargs):
        return event_stream_gen()

    mock_result_aggregator_instance.consume_and_emit = MagicMock(
        side_effect=sync_get_event_stream_gen_for_prop_test
    )

    # Configure current_result on the type of the mock_result_aggregator_instance
    # This makes it behave like a property that returns items from side_effect on access.
    type(mock_result_aggregator_instance).current_result = PropertyMock(
        side_effect=[get_current_result_coro1(), get_current_result_coro2()]
    )

    with (
        patch(
            'a2a.server.request_handlers.default_request_handler.ResultAggregator',
            return_value=mock_result_aggregator_instance,
        ),
        patch(
            'a2a.server.request_handlers.default_request_handler.TaskManager.get_task',
            return_value=initial_task_for_tm,
        ),
        patch(
            'a2a.server.request_handlers.default_request_handler.TaskManager.update_with_message',
            return_value=task_for_rc,
        ),
    ):
        # Consume the stream
        async for _ in request_handler.on_message_send_stream(
            params, create_server_call_context()
        ):
            pass

    # Assertions
    # 1. set_info called once at the beginning if task exists (or after task is created from message)
    mock_push_config_store.set_info.assert_any_call(task_id, push_config)

    # 2. send_notification called for each task event yielded by aggregator
    assert mock_push_sender.send_notification.await_count == 2
    mock_push_sender.send_notification.assert_any_await(event1_task_update)
    mock_push_sender.send_notification.assert_any_await(event2_final_task)

    mock_agent_executor.execute.assert_awaited_once()


@pytest.mark.asyncio
async def test_on_message_send_stream_task_id_mismatch():
    """Test on_message_send_stream raises error if yielded task ID mismatches."""
    mock_task_store = AsyncMock(spec=TaskStore)
    mock_agent_executor = AsyncMock(
        spec=AgentExecutor
    )  # Only need a basic mock
    mock_request_context_builder = AsyncMock(spec=RequestContextBuilder)

    context_task_id = 'stream_task_id_ctx'
    mismatched_task_id = 'DIFFERENT_stream_task_id'

    mock_request_context = MagicMock(spec=RequestContext)
    mock_request_context.task_id = context_task_id
    mock_request_context_builder.build.return_value = mock_request_context

    request_handler = DefaultRequestHandler(
        agent_executor=mock_agent_executor,
        task_store=mock_task_store,
        request_context_builder=mock_request_context_builder,
    )
    params = MessageSendParams(
        message=Message(
            role=Role.user, message_id='msg_stream_mismatch', parts=[]
        )
    )

    mock_result_aggregator_instance = AsyncMock(spec=ResultAggregator)
    mismatched_task_event = create_sample_task(
        task_id=mismatched_task_id
    )  # Task with different ID

    async def event_stream_gen_mismatch():
        yield mismatched_task_event

    mock_result_aggregator_instance.consume_and_emit.return_value = (
        event_stream_gen_mismatch()
    )

    from a2a.utils.errors import ServerError  # Local import

    with (
        patch(
            'a2a.server.request_handlers.default_request_handler.ResultAggregator',
            return_value=mock_result_aggregator_instance,
        ),
        patch(
            'a2a.server.request_handlers.default_request_handler.TaskManager.get_task',
            return_value=None,
        ),
    ):
        with pytest.raises(ServerError) as exc_info:
            async for _ in request_handler.on_message_send_stream(
                params, create_server_call_context()
            ):
                pass  # Consume the stream to trigger the error

    assert isinstance(exc_info.value.error, InternalError)
    assert 'Task ID mismatch' in exc_info.value.error.message  # type: ignore


@pytest.mark.asyncio
async def test_cleanup_producer_task_id_not_in_running_agents():
    """Test _cleanup_producer when task_id is not in _running_agents (e.g., already cleaned up)."""
    mock_task_store = AsyncMock(spec=TaskStore)
    mock_queue_manager = AsyncMock(spec=QueueManager)
    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=mock_task_store,
        queue_manager=mock_queue_manager,
    )

    task_id = 'task_already_cleaned'

    # Create a real, completed asyncio.Task for the test
    async def dummy_coro_for_task():
        pass

    mock_producer_task = asyncio.create_task(dummy_coro_for_task())
    await asyncio.sleep(
        0
    )  # Ensure the task has a chance to complete/be scheduled

    # Call cleanup directly, ensuring task_id is NOT in _running_agents
    # This simulates a race condition or double cleanup.
    if task_id in request_handler._running_agents:
        del request_handler._running_agents[task_id]  # Ensure it's not there

    try:
        await request_handler._cleanup_producer(mock_producer_task, task_id)
    except Exception as e:
        pytest.fail(f'_cleanup_producer raised an exception unexpectedly: {e}')

    # Verify queue_manager.close was still called
    mock_queue_manager.close.assert_awaited_once_with(task_id)
    # No error should be raised by pop if key is missing and default is None.


@pytest.mark.asyncio
async def test_set_task_push_notification_config_no_notifier():
    """Test on_set_task_push_notification_config when _push_config_store is None."""
    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=AsyncMock(spec=TaskStore),
        push_config_store=None,  # Explicitly None
    )
    params = TaskPushNotificationConfig(
        task_id='task1',
        push_notification_config=PushNotificationConfig(
            url='http://example.com'
        ),
    )
    from a2a.utils.errors import ServerError  # Local import

    with pytest.raises(ServerError) as exc_info:
        await request_handler.on_set_task_push_notification_config(
            params, create_server_call_context()
        )
    assert isinstance(exc_info.value.error, UnsupportedOperationError)


@pytest.mark.asyncio
async def test_set_task_push_notification_config_task_not_found():
    """Test on_set_task_push_notification_config when task is not found."""
    mock_task_store = AsyncMock(spec=TaskStore)
    mock_task_store.get.return_value = None  # Task not found
    mock_push_store = AsyncMock(spec=PushNotificationConfigStore)
    mock_push_sender = AsyncMock(spec=PushNotificationSender)

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=mock_task_store,
        push_config_store=mock_push_store,
        push_sender=mock_push_sender,
    )
    params = TaskPushNotificationConfig(
        task_id='non_existent_task',
        push_notification_config=PushNotificationConfig(
            url='http://example.com'
        ),
    )
    from a2a.utils.errors import ServerError  # Local import

    with pytest.raises(ServerError) as exc_info:
        await request_handler.on_set_task_push_notification_config(
            params, create_server_call_context()
        )

    assert isinstance(exc_info.value.error, TaskNotFoundError)
    mock_task_store.get.assert_awaited_once_with('non_existent_task')
    mock_push_store.set_info.assert_not_awaited()


@pytest.mark.asyncio
async def test_get_task_push_notification_config_no_store():
    """Test on_get_task_push_notification_config when _push_config_store is None."""
    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=AsyncMock(spec=TaskStore),
        push_config_store=None,  # Explicitly None
    )
    params = GetTaskPushNotificationConfigParams(id='task1')
    from a2a.utils.errors import ServerError  # Local import

    with pytest.raises(ServerError) as exc_info:
        await request_handler.on_get_task_push_notification_config(
            params, create_server_call_context()
        )
    assert isinstance(exc_info.value.error, UnsupportedOperationError)


@pytest.mark.asyncio
async def test_get_task_push_notification_config_task_not_found():
    """Test on_get_task_push_notification_config when task is not found."""
    mock_task_store = AsyncMock(spec=TaskStore)
    mock_task_store.get.return_value = None  # Task not found
    mock_push_store = AsyncMock(spec=PushNotificationConfigStore)

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=mock_task_store,
        push_config_store=mock_push_store,
    )
    params = GetTaskPushNotificationConfigParams(id='non_existent_task')
    from a2a.utils.errors import ServerError  # Local import

    with pytest.raises(ServerError) as exc_info:
        await request_handler.on_get_task_push_notification_config(
            params, create_server_call_context()
        )

    assert isinstance(exc_info.value.error, TaskNotFoundError)
    mock_task_store.get.assert_awaited_once_with('non_existent_task')
    mock_push_store.get_info.assert_not_awaited()


@pytest.mark.asyncio
async def test_get_task_push_notification_config_info_not_found():
    """Test on_get_task_push_notification_config when push_config_store.get_info returns None."""
    mock_task_store = AsyncMock(spec=TaskStore)

    sample_task = create_sample_task(task_id='non_existent_task')
    mock_task_store.get.return_value = sample_task

    mock_push_store = AsyncMock(spec=PushNotificationConfigStore)
    mock_push_store.get_info.return_value = None  # Info not found

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=mock_task_store,
        push_config_store=mock_push_store,
    )
    params = GetTaskPushNotificationConfigParams(id='non_existent_task')
    from a2a.utils.errors import ServerError  # Local import

    with pytest.raises(ServerError) as exc_info:
        await request_handler.on_get_task_push_notification_config(
            params, create_server_call_context()
        )

    assert isinstance(
        exc_info.value.error, InternalError
    )  # Current code raises InternalError
    mock_task_store.get.assert_awaited_once_with('non_existent_task')
    mock_push_store.get_info.assert_awaited_once_with('non_existent_task')


@pytest.mark.asyncio
async def test_get_task_push_notification_config_info_with_config():
    """Test on_get_task_push_notification_config with valid push config id"""
    mock_task_store = AsyncMock(spec=TaskStore)

    push_store = InMemoryPushNotificationConfigStore()

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=mock_task_store,
        push_config_store=push_store,
    )

    set_config_params = TaskPushNotificationConfig(
        task_id='task_1',
        push_notification_config=PushNotificationConfig(
            id='config_id', url='http://1.example.com'
        ),
    )
    await request_handler.on_set_task_push_notification_config(
        set_config_params, create_server_call_context()
    )

    params = GetTaskPushNotificationConfigParams(
        id='task_1', push_notification_config_id='config_id'
    )

    result: TaskPushNotificationConfig = (
        await request_handler.on_get_task_push_notification_config(
            params, create_server_call_context()
        )
    )

    assert result is not None
    assert result.task_id == 'task_1'
    assert (
        result.push_notification_config.url
        == set_config_params.push_notification_config.url
    )
    assert result.push_notification_config.id == 'config_id'


@pytest.mark.asyncio
async def test_get_task_push_notification_config_info_with_config_no_id():
    """Test on_get_task_push_notification_config with no push config id"""
    mock_task_store = AsyncMock(spec=TaskStore)

    push_store = InMemoryPushNotificationConfigStore()

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=mock_task_store,
        push_config_store=push_store,
    )

    set_config_params = TaskPushNotificationConfig(
        task_id='task_1',
        push_notification_config=PushNotificationConfig(
            url='http://1.example.com'
        ),
    )
    await request_handler.on_set_task_push_notification_config(
        set_config_params, create_server_call_context()
    )

    params = TaskIdParams(id='task_1')

    result: TaskPushNotificationConfig = (
        await request_handler.on_get_task_push_notification_config(
            params, create_server_call_context()
        )
    )

    assert result is not None
    assert result.task_id == 'task_1'
    assert (
        result.push_notification_config.url
        == set_config_params.push_notification_config.url
    )
    assert result.push_notification_config.id == 'task_1'


@pytest.mark.asyncio
async def test_on_resubscribe_to_task_task_not_found():
    """Test on_resubscribe_to_task when the task is not found."""
    mock_task_store = AsyncMock(spec=TaskStore)
    mock_task_store.get.return_value = None  # Task not found

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(), task_store=mock_task_store
    )
    params = TaskIdParams(id='resub_task_not_found')

    from a2a.utils.errors import ServerError  # Local import

    with pytest.raises(ServerError) as exc_info:
        # Need to consume the async generator to trigger the error
        async for _ in request_handler.on_resubscribe_to_task(
            params, create_server_call_context()
        ):
            pass

    assert isinstance(exc_info.value.error, TaskNotFoundError)
    mock_task_store.get.assert_awaited_once_with('resub_task_not_found')


@pytest.mark.asyncio
async def test_on_resubscribe_to_task_queue_not_found():
    """Test on_resubscribe_to_task when the queue is not found by queue_manager.tap."""
    mock_task_store = AsyncMock(spec=TaskStore)
    sample_task = create_sample_task(task_id='resub_queue_not_found')
    mock_task_store.get.return_value = sample_task

    mock_queue_manager = AsyncMock(spec=QueueManager)
    mock_queue_manager.tap.return_value = None  # Queue not found

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=mock_task_store,
        queue_manager=mock_queue_manager,
    )
    params = TaskIdParams(id='resub_queue_not_found')

    from a2a.utils.errors import ServerError  # Local import

    with pytest.raises(ServerError) as exc_info:
        async for _ in request_handler.on_resubscribe_to_task(
            params, create_server_call_context()
        ):
            pass

    assert isinstance(
        exc_info.value.error, TaskNotFoundError
    )  # Should be TaskNotFoundError as per spec
    mock_task_store.get.assert_awaited_once_with('resub_queue_not_found')
    mock_queue_manager.tap.assert_awaited_once_with('resub_queue_not_found')


@pytest.mark.asyncio
async def test_on_message_send_stream():
    request_handler = DefaultRequestHandler(
        DummyAgentExecutor(), InMemoryTaskStore()
    )
    message_params = MessageSendParams(
        message=Message(
            role=Role.user,
            message_id='msg-123',
            parts=[Part(root=TextPart(text='How are you?'))],
        ),
    )

    async def consume_stream():
        events = []
        async for event in request_handler.on_message_send_stream(
            message_params
        ):
            events.append(event)
            if len(events) >= 3:
                break  # Stop after a few events

        return events

    # Consume first 3 events from the stream and measure time
    start = time.perf_counter()
    events = await consume_stream()
    elapsed = time.perf_counter() - start

    # Assert we received events quickly
    assert len(events) == 3
    assert elapsed < 0.5

    texts = [p.root.text for e in events for p in e.status.message.parts]
    assert texts == ['Event 0', 'Event 1', 'Event 2']


@pytest.mark.asyncio
async def test_list_task_push_notification_config_no_store():
    """Test on_list_task_push_notification_config when _push_config_store is None."""
    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=AsyncMock(spec=TaskStore),
        push_config_store=None,  # Explicitly None
    )
    params = ListTaskPushNotificationConfigParams(id='task1')
    from a2a.utils.errors import ServerError  # Local import

    with pytest.raises(ServerError) as exc_info:
        await request_handler.on_list_task_push_notification_config(
            params, create_server_call_context()
        )
    assert isinstance(exc_info.value.error, UnsupportedOperationError)


@pytest.mark.asyncio
async def test_list_task_push_notification_config_task_not_found():
    """Test on_list_task_push_notification_config when task is not found."""
    mock_task_store = AsyncMock(spec=TaskStore)
    mock_task_store.get.return_value = None  # Task not found
    mock_push_store = AsyncMock(spec=PushNotificationConfigStore)

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=mock_task_store,
        push_config_store=mock_push_store,
    )
    params = ListTaskPushNotificationConfigParams(id='non_existent_task')
    from a2a.utils.errors import ServerError  # Local import

    with pytest.raises(ServerError) as exc_info:
        await request_handler.on_list_task_push_notification_config(
            params, create_server_call_context()
        )

    assert isinstance(exc_info.value.error, TaskNotFoundError)
    mock_task_store.get.assert_awaited_once_with('non_existent_task')
    mock_push_store.get_info.assert_not_awaited()


@pytest.mark.asyncio
async def test_list_no_task_push_notification_config_info():
    """Test on_get_task_push_notification_config when push_config_store.get_info returns []"""
    mock_task_store = AsyncMock(spec=TaskStore)

    sample_task = create_sample_task(task_id='non_existent_task')
    mock_task_store.get.return_value = sample_task

    push_store = InMemoryPushNotificationConfigStore()

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=mock_task_store,
        push_config_store=push_store,
    )
    params = ListTaskPushNotificationConfigParams(id='non_existent_task')

    result = await request_handler.on_list_task_push_notification_config(
        params, create_server_call_context()
    )
    assert result == []


@pytest.mark.asyncio
async def test_list_task_push_notification_config_info_with_config():
    """Test on_list_task_push_notification_config with push config+id"""
    mock_task_store = AsyncMock(spec=TaskStore)

    sample_task = create_sample_task(task_id='non_existent_task')
    mock_task_store.get.return_value = sample_task

    push_config1 = PushNotificationConfig(
        id='config_1', url='http://example.com'
    )
    push_config2 = PushNotificationConfig(
        id='config_2', url='http://example.com'
    )

    push_store = InMemoryPushNotificationConfigStore()
    await push_store.set_info('task_1', push_config1)
    await push_store.set_info('task_1', push_config2)

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=mock_task_store,
        push_config_store=push_store,
    )
    params = ListTaskPushNotificationConfigParams(id='task_1')

    result: list[
        TaskPushNotificationConfig
    ] = await request_handler.on_list_task_push_notification_config(
        params, create_server_call_context()
    )

    assert len(result) == 2
    assert result[0].task_id == 'task_1'
    assert result[0].push_notification_config == push_config1
    assert result[1].task_id == 'task_1'
    assert result[1].push_notification_config == push_config2


@pytest.mark.asyncio
async def test_list_task_push_notification_config_info_with_config_and_no_id():
    """Test on_list_task_push_notification_config with no push config id"""
    mock_task_store = AsyncMock(spec=TaskStore)

    push_store = InMemoryPushNotificationConfigStore()

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=mock_task_store,
        push_config_store=push_store,
    )

    # multiple calls without config id should replace the existing
    set_config_params1 = TaskPushNotificationConfig(
        task_id='task_1',
        push_notification_config=PushNotificationConfig(
            url='http://1.example.com'
        ),
    )
    await request_handler.on_set_task_push_notification_config(
        set_config_params1, create_server_call_context()
    )

    set_config_params2 = TaskPushNotificationConfig(
        task_id='task_1',
        push_notification_config=PushNotificationConfig(
            url='http://2.example.com'
        ),
    )
    await request_handler.on_set_task_push_notification_config(
        set_config_params2, create_server_call_context()
    )

    params = ListTaskPushNotificationConfigParams(id='task_1')

    result: list[
        TaskPushNotificationConfig
    ] = await request_handler.on_list_task_push_notification_config(
        params, create_server_call_context()
    )

    assert len(result) == 1
    assert result[0].task_id == 'task_1'
    assert (
        result[0].push_notification_config.url
        == set_config_params2.push_notification_config.url
    )
    assert result[0].push_notification_config.id == 'task_1'


@pytest.mark.asyncio
async def test_delete_task_push_notification_config_no_store():
    """Test on_delete_task_push_notification_config when _push_config_store is None."""
    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=AsyncMock(spec=TaskStore),
        push_config_store=None,  # Explicitly None
    )
    params = DeleteTaskPushNotificationConfigParams(
        id='task1', push_notification_config_id='config1'
    )
    from a2a.utils.errors import ServerError  # Local import

    with pytest.raises(ServerError) as exc_info:
        await request_handler.on_delete_task_push_notification_config(
            params, create_server_call_context()
        )
    assert isinstance(exc_info.value.error, UnsupportedOperationError)


@pytest.mark.asyncio
async def test_delete_task_push_notification_config_task_not_found():
    """Test on_delete_task_push_notification_config when task is not found."""
    mock_task_store = AsyncMock(spec=TaskStore)
    mock_task_store.get.return_value = None  # Task not found
    mock_push_store = AsyncMock(spec=PushNotificationConfigStore)

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=mock_task_store,
        push_config_store=mock_push_store,
    )
    params = DeleteTaskPushNotificationConfigParams(
        id='non_existent_task', push_notification_config_id='config1'
    )
    from a2a.utils.errors import ServerError  # Local import

    with pytest.raises(ServerError) as exc_info:
        await request_handler.on_delete_task_push_notification_config(
            params, create_server_call_context()
        )

    assert isinstance(exc_info.value.error, TaskNotFoundError)
    mock_task_store.get.assert_awaited_once_with('non_existent_task')
    mock_push_store.get_info.assert_not_awaited()


@pytest.mark.asyncio
async def test_delete_no_task_push_notification_config_info():
    """Test on_delete_task_push_notification_config without config info"""
    mock_task_store = AsyncMock(spec=TaskStore)

    sample_task = create_sample_task(task_id='task_1')
    mock_task_store.get.return_value = sample_task

    push_store = InMemoryPushNotificationConfigStore()
    await push_store.set_info(
        'task_2',
        PushNotificationConfig(id='config_1', url='http://example.com'),
    )

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=mock_task_store,
        push_config_store=push_store,
    )
    params = DeleteTaskPushNotificationConfigParams(
        id='task1', push_notification_config_id='config_non_existant'
    )

    result = await request_handler.on_delete_task_push_notification_config(
        params, create_server_call_context()
    )
    assert result is None

    params = DeleteTaskPushNotificationConfigParams(
        id='task2', push_notification_config_id='config_non_existant'
    )

    result = await request_handler.on_delete_task_push_notification_config(
        params, create_server_call_context()
    )
    assert result is None


@pytest.mark.asyncio
async def test_delete_task_push_notification_config_info_with_config():
    """Test on_list_task_push_notification_config with push config+id"""
    mock_task_store = AsyncMock(spec=TaskStore)

    sample_task = create_sample_task(task_id='non_existent_task')
    mock_task_store.get.return_value = sample_task

    push_config1 = PushNotificationConfig(
        id='config_1', url='http://example.com'
    )
    push_config2 = PushNotificationConfig(
        id='config_2', url='http://example.com'
    )

    push_store = InMemoryPushNotificationConfigStore()
    await push_store.set_info('task_1', push_config1)
    await push_store.set_info('task_1', push_config2)
    await push_store.set_info('task_2', push_config1)

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=mock_task_store,
        push_config_store=push_store,
    )
    params = DeleteTaskPushNotificationConfigParams(
        id='task_1', push_notification_config_id='config_1'
    )

    result1 = await request_handler.on_delete_task_push_notification_config(
        params, create_server_call_context()
    )

    assert result1 is None

    result2 = await request_handler.on_list_task_push_notification_config(
        ListTaskPushNotificationConfigParams(id='task_1'),
        create_server_call_context(),
    )

    assert len(result2) == 1
    assert result2[0].task_id == 'task_1'
    assert result2[0].push_notification_config == push_config2


@pytest.mark.asyncio
async def test_delete_task_push_notification_config_info_with_config_and_no_id():
    """Test on_list_task_push_notification_config with no push config id"""
    mock_task_store = AsyncMock(spec=TaskStore)

    sample_task = create_sample_task(task_id='non_existent_task')
    mock_task_store.get.return_value = sample_task

    push_config = PushNotificationConfig(url='http://example.com')

    # insertion without id should replace the existing config
    push_store = InMemoryPushNotificationConfigStore()
    await push_store.set_info('task_1', push_config)
    await push_store.set_info('task_1', push_config)

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=mock_task_store,
        push_config_store=push_store,
    )
    params = DeleteTaskPushNotificationConfigParams(
        id='task_1', push_notification_config_id='task_1'
    )

    result = await request_handler.on_delete_task_push_notification_config(
        params, create_server_call_context()
    )

    assert result is None

    result2 = await request_handler.on_list_task_push_notification_config(
        ListTaskPushNotificationConfigParams(id='task_1'),
        create_server_call_context(),
    )

    assert len(result2) == 0


TERMINAL_TASK_STATES = {
    TaskState.completed,
    TaskState.canceled,
    TaskState.failed,
    TaskState.rejected,
}


@pytest.mark.asyncio
@pytest.mark.parametrize('terminal_state', TERMINAL_TASK_STATES)
async def test_on_message_send_task_in_terminal_state(terminal_state):
    """Test on_message_send when task is already in a terminal state."""
    task_id = f'terminal_task_{terminal_state.value}'
    terminal_task = create_sample_task(
        task_id=task_id, status_state=terminal_state
    )

    mock_task_store = AsyncMock(spec=TaskStore)
    # The get method of TaskManager calls task_store.get.
    # We mock TaskManager.get_task which is an async method.
    # So we should patch that instead.

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(), task_store=mock_task_store
    )

    params = MessageSendParams(
        message=Message(
            role=Role.user,
            message_id='msg_terminal',
            parts=[],
            task_id=task_id,
        )
    )

    from a2a.utils.errors import ServerError

    # Patch the TaskManager's get_task method to return our terminal task
    with patch(
        'a2a.server.request_handlers.default_request_handler.TaskManager.get_task',
        return_value=terminal_task,
    ):
        with pytest.raises(ServerError) as exc_info:
            await request_handler.on_message_send(
                params, create_server_call_context()
            )

    assert isinstance(exc_info.value.error, InvalidParamsError)
    assert exc_info.value.error.message
    assert (
        f'Task {task_id} is in terminal state: {terminal_state.value}'
        in exc_info.value.error.message
    )


@pytest.mark.asyncio
@pytest.mark.parametrize('terminal_state', TERMINAL_TASK_STATES)
async def test_on_message_send_stream_task_in_terminal_state(terminal_state):
    """Test on_message_send_stream when task is already in a terminal state."""
    task_id = f'terminal_stream_task_{terminal_state.value}'
    terminal_task = create_sample_task(
        task_id=task_id, status_state=terminal_state
    )

    mock_task_store = AsyncMock(spec=TaskStore)

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(), task_store=mock_task_store
    )

    params = MessageSendParams(
        message=Message(
            role=Role.user,
            message_id='msg_terminal_stream',
            parts=[],
            task_id=task_id,
        )
    )

    from a2a.utils.errors import ServerError

    with patch(
        'a2a.server.request_handlers.default_request_handler.TaskManager.get_task',
        return_value=terminal_task,
    ):
        with pytest.raises(ServerError) as exc_info:
            async for _ in request_handler.on_message_send_stream(
                params, create_server_call_context()
            ):
                pass  # pragma: no cover

    assert isinstance(exc_info.value.error, InvalidParamsError)
    assert exc_info.value.error.message
    assert (
        f'Task {task_id} is in terminal state: {terminal_state.value}'
        in exc_info.value.error.message
    )


@pytest.mark.asyncio
@pytest.mark.parametrize('terminal_state', TERMINAL_TASK_STATES)
async def test_on_resubscribe_to_task_in_terminal_state(terminal_state):
    """Test on_resubscribe_to_task when task is in a terminal state."""
    task_id = f'resub_terminal_task_{terminal_state.value}'
    terminal_task = create_sample_task(
        task_id=task_id, status_state=terminal_state
    )

    mock_task_store = AsyncMock(spec=TaskStore)
    mock_task_store.get.return_value = terminal_task

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(),
        task_store=mock_task_store,
        queue_manager=AsyncMock(spec=QueueManager),
    )
    params = TaskIdParams(id=task_id)

    from a2a.utils.errors import ServerError

    with pytest.raises(ServerError) as exc_info:
        async for _ in request_handler.on_resubscribe_to_task(
            params, create_server_call_context()
        ):
            pass  # pragma: no cover

    assert isinstance(exc_info.value.error, InvalidParamsError)
    assert exc_info.value.error.message
    assert (
        f'Task {task_id} is in terminal state: {terminal_state.value}'
        in exc_info.value.error.message
    )
    mock_task_store.get.assert_awaited_once_with(task_id)


@pytest.mark.asyncio
async def test_on_message_send_task_id_provided_but_task_not_found():
    """Test on_message_send when task_id is provided but task doesn't exist."""
    task_id = 'nonexistent_task'
    mock_task_store = AsyncMock(spec=TaskStore)

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(), task_store=mock_task_store
    )

    params = MessageSendParams(
        message=Message(
            role=Role.user,
            message_id='msg_nonexistent',
            parts=[Part(root=TextPart(text='Hello'))],
            task_id=task_id,
            context_id='ctx1',
        )
    )

    from a2a.utils.errors import ServerError

    # Mock TaskManager.get_task to return None (task not found)
    with patch(
        'a2a.server.request_handlers.default_request_handler.TaskManager.get_task',
        return_value=None,
    ):
        with pytest.raises(ServerError) as exc_info:
            await request_handler.on_message_send(
                params, create_server_call_context()
            )

    assert isinstance(exc_info.value.error, TaskNotFoundError)
    assert exc_info.value.error.message
    assert (
        f'Task {task_id} was specified but does not exist'
        in exc_info.value.error.message
    )


@pytest.mark.asyncio
async def test_on_message_send_stream_task_id_provided_but_task_not_found():
    """Test on_message_send_stream when task_id is provided but task doesn't exist."""
    task_id = 'nonexistent_stream_task'
    mock_task_store = AsyncMock(spec=TaskStore)

    request_handler = DefaultRequestHandler(
        agent_executor=DummyAgentExecutor(), task_store=mock_task_store
    )

    params = MessageSendParams(
        message=Message(
            role=Role.user,
            message_id='msg_nonexistent_stream',
            parts=[Part(root=TextPart(text='Hello'))],
            task_id=task_id,
            context_id='ctx1',
        )
    )

    from a2a.utils.errors import ServerError

    # Mock TaskManager.get_task to return None (task not found)
    with patch(
        'a2a.server.request_handlers.default_request_handler.TaskManager.get_task',
        return_value=None,
    ):
        with pytest.raises(ServerError) as exc_info:
            # Need to consume the async generator to trigger the error
            async for _ in request_handler.on_message_send_stream(
                params, create_server_call_context()
            ):
                pass

    assert isinstance(exc_info.value.error, TaskNotFoundError)
    assert exc_info.value.error.message
    assert (
        f'Task {task_id} was specified but does not exist'
        in exc_info.value.error.message
    )



---
File: /a2a-python/tests/server/request_handlers/test_grpc_handler.py
---

from unittest.mock import AsyncMock, MagicMock

import grpc
import grpc.aio
import pytest

from a2a import types
from a2a.extensions.common import HTTP_EXTENSION_HEADER
from a2a.grpc import a2a_pb2
from a2a.server.context import ServerCallContext
from a2a.server.request_handlers import GrpcHandler, RequestHandler
from a2a.utils.errors import ServerError


# --- Fixtures ---


@pytest.fixture
def mock_request_handler() -> AsyncMock:
    return AsyncMock(spec=RequestHandler)


@pytest.fixture
def mock_grpc_context() -> AsyncMock:
    context = AsyncMock(spec=grpc.aio.ServicerContext)
    context.abort = AsyncMock()
    context.set_trailing_metadata = MagicMock()
    return context


@pytest.fixture
def sample_agent_card() -> types.AgentCard:
    return types.AgentCard(
        name='Test Agent',
        description='A test agent',
        url='http://localhost',
        version='1.0.0',
        capabilities=types.AgentCapabilities(
            streaming=True, push_notifications=True
        ),
        default_input_modes=['text/plain'],
        default_output_modes=['text/plain'],
        skills=[],
    )


@pytest.fixture
def grpc_handler(
    mock_request_handler: AsyncMock, sample_agent_card: types.AgentCard
) -> GrpcHandler:
    return GrpcHandler(
        agent_card=sample_agent_card, request_handler=mock_request_handler
    )


# --- Test Cases ---


@pytest.mark.asyncio
async def test_send_message_success(
    grpc_handler: GrpcHandler,
    mock_request_handler: AsyncMock,
    mock_grpc_context: AsyncMock,
):
    """Test successful SendMessage call."""
    request_proto = a2a_pb2.SendMessageRequest(
        request=a2a_pb2.Message(message_id='msg-1')
    )
    response_model = types.Task(
        id='task-1',
        context_id='ctx-1',
        status=types.TaskStatus(state=types.TaskState.completed),
    )
    mock_request_handler.on_message_send.return_value = response_model

    response = await grpc_handler.SendMessage(request_proto, mock_grpc_context)

    mock_request_handler.on_message_send.assert_awaited_once()
    assert isinstance(response, a2a_pb2.SendMessageResponse)
    assert response.HasField('task')
    assert response.task.id == 'task-1'


@pytest.mark.asyncio
async def test_send_message_server_error(
    grpc_handler: GrpcHandler,
    mock_request_handler: AsyncMock,
    mock_grpc_context: AsyncMock,
):
    """Test SendMessage call when handler raises a ServerError."""
    request_proto = a2a_pb2.SendMessageRequest()
    error = ServerError(error=types.InvalidParamsError(message='Bad params'))
    mock_request_handler.on_message_send.side_effect = error

    await grpc_handler.SendMessage(request_proto, mock_grpc_context)

    mock_grpc_context.abort.assert_awaited_once_with(
        grpc.StatusCode.INVALID_ARGUMENT, 'InvalidParamsError: Bad params'
    )


@pytest.mark.asyncio
async def test_get_task_success(
    grpc_handler: GrpcHandler,
    mock_request_handler: AsyncMock,
    mock_grpc_context: AsyncMock,
):
    """Test successful GetTask call."""
    request_proto = a2a_pb2.GetTaskRequest(name='tasks/task-1')
    response_model = types.Task(
        id='task-1',
        context_id='ctx-1',
        status=types.TaskStatus(state=types.TaskState.working),
    )
    mock_request_handler.on_get_task.return_value = response_model

    response = await grpc_handler.GetTask(request_proto, mock_grpc_context)

    mock_request_handler.on_get_task.assert_awaited_once()
    assert isinstance(response, a2a_pb2.Task)
    assert response.id == 'task-1'


@pytest.mark.asyncio
async def test_get_task_not_found(
    grpc_handler: GrpcHandler,
    mock_request_handler: AsyncMock,
    mock_grpc_context: AsyncMock,
):
    """Test GetTask call when task is not found."""
    request_proto = a2a_pb2.GetTaskRequest(name='tasks/task-1')
    mock_request_handler.on_get_task.return_value = None

    await grpc_handler.GetTask(request_proto, mock_grpc_context)

    mock_grpc_context.abort.assert_awaited_once_with(
        grpc.StatusCode.NOT_FOUND, 'TaskNotFoundError: Task not found'
    )


@pytest.mark.asyncio
async def test_cancel_task_server_error(
    grpc_handler: GrpcHandler,
    mock_request_handler: AsyncMock,
    mock_grpc_context: AsyncMock,
):
    """Test CancelTask call when handler raises ServerError."""
    request_proto = a2a_pb2.CancelTaskRequest(name='tasks/task-1')
    error = ServerError(error=types.TaskNotCancelableError())
    mock_request_handler.on_cancel_task.side_effect = error

    await grpc_handler.CancelTask(request_proto, mock_grpc_context)

    mock_grpc_context.abort.assert_awaited_once_with(
        grpc.StatusCode.UNIMPLEMENTED,
        'TaskNotCancelableError: Task cannot be canceled',
    )


@pytest.mark.asyncio
async def test_send_streaming_message(
    grpc_handler: GrpcHandler,
    mock_request_handler: AsyncMock,
    mock_grpc_context: AsyncMock,
):
    """Test successful SendStreamingMessage call."""

    async def mock_stream():
        yield types.Task(
            id='task-1',
            context_id='ctx-1',
            status=types.TaskStatus(state=types.TaskState.working),
        )

    mock_request_handler.on_message_send_stream.return_value = mock_stream()
    request_proto = a2a_pb2.SendMessageRequest()

    results = [
        result
        async for result in grpc_handler.SendStreamingMessage(
            request_proto, mock_grpc_context
        )
    ]

    assert len(results) == 1
    assert results[0].HasField('task')
    assert results[0].task.id == 'task-1'


@pytest.mark.asyncio
async def test_get_agent_card(
    grpc_handler: GrpcHandler,
    sample_agent_card: types.AgentCard,
    mock_grpc_context: AsyncMock,
):
    """Test GetAgentCard call."""
    request_proto = a2a_pb2.GetAgentCardRequest()
    response = await grpc_handler.GetAgentCard(request_proto, mock_grpc_context)

    assert response.name == sample_agent_card.name
    assert response.version == sample_agent_card.version


@pytest.mark.asyncio
async def test_get_agent_card_with_modifier(
    mock_request_handler: AsyncMock,
    sample_agent_card: types.AgentCard,
    mock_grpc_context: AsyncMock,
):
    """Test GetAgentCard call with a card_modifier."""

    def modifier(card: types.AgentCard) -> types.AgentCard:
        modified_card = card.model_copy(deep=True)
        modified_card.name = 'Modified gRPC Agent'
        return modified_card

    grpc_handler_modified = GrpcHandler(
        agent_card=sample_agent_card,
        request_handler=mock_request_handler,
        card_modifier=modifier,
    )

    request_proto = a2a_pb2.GetAgentCardRequest()
    response = await grpc_handler_modified.GetAgentCard(
        request_proto, mock_grpc_context
    )

    assert response.name == 'Modified gRPC Agent'
    assert response.version == sample_agent_card.version


@pytest.mark.asyncio
@pytest.mark.parametrize(
    'server_error, grpc_status_code, error_message_part',
    [
        (
            ServerError(error=types.JSONParseError()),
            grpc.StatusCode.INTERNAL,
            'JSONParseError',
        ),
        (
            ServerError(error=types.InvalidRequestError()),
            grpc.StatusCode.INVALID_ARGUMENT,
            'InvalidRequestError',
        ),
        (
            ServerError(error=types.MethodNotFoundError()),
            grpc.StatusCode.NOT_FOUND,
            'MethodNotFoundError',
        ),
        (
            ServerError(error=types.InvalidParamsError()),
            grpc.StatusCode.INVALID_ARGUMENT,
            'InvalidParamsError',
        ),
        (
            ServerError(error=types.InternalError()),
            grpc.StatusCode.INTERNAL,
            'InternalError',
        ),
        (
            ServerError(error=types.TaskNotFoundError()),
            grpc.StatusCode.NOT_FOUND,
            'TaskNotFoundError',
        ),
        (
            ServerError(error=types.TaskNotCancelableError()),
            grpc.StatusCode.UNIMPLEMENTED,
            'TaskNotCancelableError',
        ),
        (
            ServerError(error=types.PushNotificationNotSupportedError()),
            grpc.StatusCode.UNIMPLEMENTED,
            'PushNotificationNotSupportedError',
        ),
        (
            ServerError(error=types.UnsupportedOperationError()),
            grpc.StatusCode.UNIMPLEMENTED,
            'UnsupportedOperationError',
        ),
        (
            ServerError(error=types.ContentTypeNotSupportedError()),
            grpc.StatusCode.UNIMPLEMENTED,
            'ContentTypeNotSupportedError',
        ),
        (
            ServerError(error=types.InvalidAgentResponseError()),
            grpc.StatusCode.INTERNAL,
            'InvalidAgentResponseError',
        ),
        (
            ServerError(error=types.JSONRPCError(code=99, message='Unknown')),
            grpc.StatusCode.UNKNOWN,
            'Unknown error',
        ),
    ],
)
async def test_abort_context_error_mapping(  # noqa: PLR0913
    grpc_handler: GrpcHandler,
    mock_request_handler: AsyncMock,
    mock_grpc_context: AsyncMock,
    server_error,
    grpc_status_code,
    error_message_part,
):
    mock_request_handler.on_get_task.side_effect = server_error
    request_proto = a2a_pb2.GetTaskRequest(name='tasks/any')
    await grpc_handler.GetTask(request_proto, mock_grpc_context)

    mock_grpc_context.abort.assert_awaited_once()
    call_args, _ = mock_grpc_context.abort.call_args
    assert call_args[0] == grpc_status_code
    assert error_message_part in call_args[1]


@pytest.mark.asyncio
class TestGrpcExtensions:
    async def test_send_message_with_extensions(
        self,
        grpc_handler: GrpcHandler,
        mock_request_handler: AsyncMock,
        mock_grpc_context: AsyncMock,
    ):
        mock_grpc_context.invocation_metadata = grpc.aio.Metadata(
            (HTTP_EXTENSION_HEADER, 'foo'),
            (HTTP_EXTENSION_HEADER, 'bar'),
        )

        def side_effect(request, context: ServerCallContext):
            context.activated_extensions.add('foo')
            context.activated_extensions.add('baz')
            return types.Task(
                id='task-1',
                context_id='ctx-1',
                status=types.TaskStatus(state=types.TaskState.completed),
            )

        mock_request_handler.on_message_send.side_effect = side_effect

        await grpc_handler.SendMessage(
            a2a_pb2.SendMessageRequest(), mock_grpc_context
        )

        mock_request_handler.on_message_send.assert_awaited_once()
        call_context = mock_request_handler.on_message_send.call_args[0][1]
        assert isinstance(call_context, ServerCallContext)
        assert call_context.requested_extensions == {'foo', 'bar'}

        mock_grpc_context.set_trailing_metadata.assert_called_once()
        called_metadata = (
            mock_grpc_context.set_trailing_metadata.call_args.args[0]
        )
        assert set(called_metadata) == {
            (HTTP_EXTENSION_HEADER, 'foo'),
            (HTTP_EXTENSION_HEADER, 'baz'),
        }

    async def test_send_message_with_comma_separated_extensions(
        self,
        grpc_handler: GrpcHandler,
        mock_request_handler: AsyncMock,
        mock_grpc_context: AsyncMock,
    ):
        mock_grpc_context.invocation_metadata = grpc.aio.Metadata(
            (HTTP_EXTENSION_HEADER, 'foo ,, bar,'),
            (HTTP_EXTENSION_HEADER, 'baz  , bar'),
        )
        mock_request_handler.on_message_send.return_value = types.Message(
            message_id='1',
            role=types.Role.agent,
            parts=[types.Part(root=types.TextPart(text='test'))],
        )

        await grpc_handler.SendMessage(
            a2a_pb2.SendMessageRequest(), mock_grpc_context
        )

        mock_request_handler.on_message_send.assert_awaited_once()
        call_context = mock_request_handler.on_message_send.call_args[0][1]
        assert isinstance(call_context, ServerCallContext)
        assert call_context.requested_extensions == {'foo', 'bar', 'baz'}

    async def test_send_streaming_message_with_extensions(
        self,
        grpc_handler: GrpcHandler,
        mock_request_handler: AsyncMock,
        mock_grpc_context: AsyncMock,
    ):
        mock_grpc_context.invocation_metadata = grpc.aio.Metadata(
            (HTTP_EXTENSION_HEADER, 'foo'),
            (HTTP_EXTENSION_HEADER, 'bar'),
        )

        async def side_effect(request, context: ServerCallContext):
            context.activated_extensions.add('foo')
            context.activated_extensions.add('baz')
            yield types.Task(
                id='task-1',
                context_id='ctx-1',
                status=types.TaskStatus(state=types.TaskState.working),
            )

        mock_request_handler.on_message_send_stream.side_effect = side_effect

        results = [
            result
            async for result in grpc_handler.SendStreamingMessage(
                a2a_pb2.SendMessageRequest(), mock_grpc_context
            )
        ]
        assert results

        mock_request_handler.on_message_send_stream.assert_called_once()
        call_context = mock_request_handler.on_message_send_stream.call_args[0][
            1
        ]
        assert isinstance(call_context, ServerCallContext)
        assert call_context.requested_extensions == {'foo', 'bar'}

        mock_grpc_context.set_trailing_metadata.assert_called_once()
        called_metadata = (
            mock_grpc_context.set_trailing_metadata.call_args.args[0]
        )
        assert set(called_metadata) == {
            (HTTP_EXTENSION_HEADER, 'foo'),
            (HTTP_EXTENSION_HEADER, 'baz'),
        }



---
File: /a2a-python/tests/server/request_handlers/test_jsonrpc_handler.py
---

import unittest
import unittest.async_case

from collections.abc import AsyncGenerator
from typing import Any, NoReturn
from unittest.mock import AsyncMock, MagicMock, call, patch

import httpx
import pytest

from a2a.server.agent_execution import AgentExecutor, RequestContext
from a2a.server.agent_execution.request_context_builder import (
    RequestContextBuilder,
)
from a2a.server.context import ServerCallContext
from a2a.server.events import QueueManager
from a2a.server.events.event_queue import EventQueue
from a2a.server.request_handlers import DefaultRequestHandler, JSONRPCHandler
from a2a.server.tasks import (
    BasePushNotificationSender,
    InMemoryPushNotificationConfigStore,
    PushNotificationConfigStore,
    PushNotificationSender,
    TaskStore,
)
from a2a.types import (
    AgentCapabilities,
    AgentCard,
    Artifact,
    AuthenticatedExtendedCardNotConfiguredError,
    CancelTaskRequest,
    CancelTaskSuccessResponse,
    DeleteTaskPushNotificationConfigParams,
    DeleteTaskPushNotificationConfigRequest,
    DeleteTaskPushNotificationConfigSuccessResponse,
    GetAuthenticatedExtendedCardRequest,
    GetAuthenticatedExtendedCardResponse,
    GetAuthenticatedExtendedCardSuccessResponse,
    GetTaskPushNotificationConfigParams,
    GetTaskPushNotificationConfigRequest,
    GetTaskPushNotificationConfigResponse,
    GetTaskPushNotificationConfigSuccessResponse,
    GetTaskRequest,
    GetTaskResponse,
    GetTaskSuccessResponse,
    InternalError,
    JSONRPCErrorResponse,
    ListTaskPushNotificationConfigParams,
    ListTaskPushNotificationConfigRequest,
    ListTaskPushNotificationConfigSuccessResponse,
    Message,
    MessageSendConfiguration,
    MessageSendParams,
    Part,
    PushNotificationConfig,
    SendMessageRequest,
    SendMessageSuccessResponse,
    SendStreamingMessageRequest,
    SendStreamingMessageSuccessResponse,
    SetTaskPushNotificationConfigRequest,
    SetTaskPushNotificationConfigResponse,
    SetTaskPushNotificationConfigSuccessResponse,
    Task,
    TaskArtifactUpdateEvent,
    TaskIdParams,
    TaskNotFoundError,
    TaskPushNotificationConfig,
    TaskQueryParams,
    TaskResubscriptionRequest,
    TaskState,
    TaskStatus,
    TaskStatusUpdateEvent,
    TextPart,
    UnsupportedOperationError,
)
from a2a.utils.errors import ServerError


MINIMAL_TASK: dict[str, Any] = {
    'id': 'task_123',
    'contextId': 'session-xyz',
    'status': {'state': 'submitted'},
    'kind': 'task',
}
MESSAGE_PAYLOAD: dict[str, Any] = {
    'role': 'agent',
    'parts': [{'text': 'test message'}],
    'messageId': '111',
}


class TestJSONRPCtHandler(unittest.async_case.IsolatedAsyncioTestCase):
    @pytest.fixture(autouse=True)
    def init_fixtures(self) -> None:
        self.mock_agent_card = MagicMock(
            spec=AgentCard, url='http://agent.example.com/api'
        )

    async def test_on_get_task_success(self) -> None:
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )
        call_context = ServerCallContext(state={'foo': 'bar'})
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        task_id = 'test_task_id'
        mock_task = Task(**MINIMAL_TASK)
        mock_task_store.get.return_value = mock_task
        request = GetTaskRequest(id='1', params=TaskQueryParams(id=task_id))
        response: GetTaskResponse = await handler.on_get_task(
            request, call_context
        )
        self.assertIsInstance(response.root, GetTaskSuccessResponse)
        assert response.root.result == mock_task  # type: ignore
        mock_task_store.get.assert_called_once_with(task_id)

    async def test_on_get_task_not_found(self) -> None:
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        mock_task_store.get.return_value = None
        request = GetTaskRequest(
            id='1',
            method='tasks/get',
            params=TaskQueryParams(id='nonexistent_id'),
        )
        call_context = ServerCallContext(state={'foo': 'bar'})
        response: GetTaskResponse = await handler.on_get_task(
            request, call_context
        )
        self.assertIsInstance(response.root, JSONRPCErrorResponse)
        assert response.root.error == TaskNotFoundError()  # type: ignore

    async def test_on_cancel_task_success(self) -> None:
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        task_id = 'test_task_id'
        mock_task = Task(**MINIMAL_TASK)
        mock_task_store.get.return_value = mock_task
        mock_agent_executor.cancel.return_value = None
        call_context = ServerCallContext(state={'foo': 'bar'})

        async def streaming_coro():
            yield mock_task

        with patch(
            'a2a.server.request_handlers.default_request_handler.EventConsumer.consume_all',
            return_value=streaming_coro(),
        ):
            request = CancelTaskRequest(id='1', params=TaskIdParams(id=task_id))
            response = await handler.on_cancel_task(request, call_context)
            assert mock_agent_executor.cancel.call_count == 1
            self.assertIsInstance(response.root, CancelTaskSuccessResponse)
            assert response.root.result == mock_task  # type: ignore
            mock_agent_executor.cancel.assert_called_once()

    async def test_on_cancel_task_not_supported(self) -> None:
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        task_id = 'test_task_id'
        mock_task = Task(**MINIMAL_TASK)
        mock_task_store.get.return_value = mock_task
        mock_agent_executor.cancel.return_value = None
        call_context = ServerCallContext(state={'foo': 'bar'})

        async def streaming_coro():
            raise ServerError(UnsupportedOperationError())
            yield

        with patch(
            'a2a.server.request_handlers.default_request_handler.EventConsumer.consume_all',
            return_value=streaming_coro(),
        ):
            request = CancelTaskRequest(id='1', params=TaskIdParams(id=task_id))
            response = await handler.on_cancel_task(request, call_context)
            assert mock_agent_executor.cancel.call_count == 1
            self.assertIsInstance(response.root, JSONRPCErrorResponse)
            assert response.root.error == UnsupportedOperationError()  # type: ignore
            mock_agent_executor.cancel.assert_called_once()

    async def test_on_cancel_task_not_found(self) -> None:
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        mock_task_store.get.return_value = None
        request = CancelTaskRequest(
            id='1',
            method='tasks/cancel',
            params=TaskIdParams(id='nonexistent_id'),
        )
        response = await handler.on_cancel_task(request)
        self.assertIsInstance(response.root, JSONRPCErrorResponse)
        assert response.root.error == TaskNotFoundError()  # type: ignore
        mock_task_store.get.assert_called_once_with('nonexistent_id')
        mock_agent_executor.cancel.assert_not_called()

    @patch(
        'a2a.server.agent_execution.simple_request_context_builder.SimpleRequestContextBuilder.build'
    )
    async def test_on_message_new_message_success(
        self, _mock_builder_build: AsyncMock
    ) -> None:
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        mock_task = Task(**MINIMAL_TASK)
        mock_task_store.get.return_value = mock_task
        mock_agent_executor.execute.return_value = None

        _mock_builder_build.return_value = RequestContext(
            request=MagicMock(),
            task_id='task_123',
            context_id='session-xyz',
            task=None,
            related_tasks=None,
        )

        async def streaming_coro():
            yield mock_task

        with patch(
            'a2a.server.request_handlers.default_request_handler.EventConsumer.consume_all',
            return_value=streaming_coro(),
        ):
            request = SendMessageRequest(
                id='1',
                params=MessageSendParams(message=Message(**MESSAGE_PAYLOAD)),
            )
            response = await handler.on_message_send(request)
            assert mock_agent_executor.execute.call_count == 1
            self.assertIsInstance(response.root, SendMessageSuccessResponse)
            assert response.root.result == mock_task  # type: ignore
            mock_agent_executor.execute.assert_called_once()

    async def test_on_message_new_message_with_existing_task_success(
        self,
    ) -> None:
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        mock_task = Task(**MINIMAL_TASK)
        mock_task_store.get.return_value = mock_task
        mock_agent_executor.execute.return_value = None

        async def streaming_coro():
            yield mock_task

        with patch(
            'a2a.server.request_handlers.default_request_handler.EventConsumer.consume_all',
            return_value=streaming_coro(),
        ):
            request = SendMessageRequest(
                id='1',
                params=MessageSendParams(
                    message=Message(
                        **MESSAGE_PAYLOAD,
                        task_id=mock_task.id,
                        context_id=mock_task.context_id,
                    )
                ),
            )
            response = await handler.on_message_send(request)
            assert mock_agent_executor.execute.call_count == 1
            self.assertIsInstance(response.root, SendMessageSuccessResponse)
            assert response.root.result == mock_task  # type: ignore
            mock_agent_executor.execute.assert_called_once()

    async def test_on_message_error(self) -> None:
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        mock_task_store.get.return_value = None
        mock_agent_executor.execute.return_value = None

        async def streaming_coro():
            raise ServerError(error=UnsupportedOperationError())
            yield

        with patch(
            'a2a.server.request_handlers.default_request_handler.EventConsumer.consume_all',
            return_value=streaming_coro(),
        ):
            request = SendMessageRequest(
                id='1',
                params=MessageSendParams(
                    message=Message(
                        **MESSAGE_PAYLOAD,
                    )
                ),
            )
            response = await handler.on_message_send(request)

            self.assertIsInstance(response.root, JSONRPCErrorResponse)
            assert response.root.error == UnsupportedOperationError()  # type: ignore
            mock_agent_executor.execute.assert_called_once()

    @patch(
        'a2a.server.agent_execution.simple_request_context_builder.SimpleRequestContextBuilder.build'
    )
    async def test_on_message_stream_new_message_success(
        self, _mock_builder_build: AsyncMock
    ) -> None:
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )

        self.mock_agent_card.capabilities = AgentCapabilities(streaming=True)
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        _mock_builder_build.return_value = RequestContext(
            request=MagicMock(),
            task_id='task_123',
            context_id='session-xyz',
            task=None,
            related_tasks=None,
        )

        events: list[Any] = [
            Task(**MINIMAL_TASK),
            TaskArtifactUpdateEvent(
                task_id='task_123',
                context_id='session-xyz',
                artifact=Artifact(
                    artifact_id='11', parts=[Part(TextPart(text='text'))]
                ),
            ),
            TaskStatusUpdateEvent(
                task_id='task_123',
                context_id='session-xyz',
                status=TaskStatus(state=TaskState.completed),
                final=True,
            ),
        ]

        async def streaming_coro():
            for event in events:
                yield event

        with patch(
            'a2a.server.request_handlers.default_request_handler.EventConsumer.consume_all',
            return_value=streaming_coro(),
        ):
            mock_task_store.get.return_value = None
            mock_agent_executor.execute.return_value = None
            request = SendStreamingMessageRequest(
                id='1',
                params=MessageSendParams(message=Message(**MESSAGE_PAYLOAD)),
            )
            response = handler.on_message_send_stream(request)
            assert isinstance(response, AsyncGenerator)
            collected_events: list[Any] = []
            async for event in response:
                collected_events.append(event)
            assert len(collected_events) == len(events)
            for i, event in enumerate(collected_events):
                assert isinstance(
                    event.root, SendStreamingMessageSuccessResponse
                )
                assert event.root.result == events[i]
            mock_agent_executor.execute.assert_called_once()

    async def test_on_message_stream_new_message_existing_task_success(
        self,
    ) -> None:
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )

        self.mock_agent_card.capabilities = AgentCapabilities(streaming=True)

        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        mock_task = Task(**MINIMAL_TASK, history=[])
        events: list[Any] = [
            mock_task,
            TaskArtifactUpdateEvent(
                task_id='task_123',
                context_id='session-xyz',
                artifact=Artifact(
                    artifact_id='11', parts=[Part(TextPart(text='text'))]
                ),
            ),
            TaskStatusUpdateEvent(
                task_id='task_123',
                context_id='session-xyz',
                status=TaskStatus(state=TaskState.working),
                final=True,
            ),
        ]

        async def streaming_coro():
            for event in events:
                yield event

        with patch(
            'a2a.server.request_handlers.default_request_handler.EventConsumer.consume_all',
            return_value=streaming_coro(),
        ):
            mock_task_store.get.return_value = mock_task
            mock_agent_executor.execute.return_value = None
            request = SendStreamingMessageRequest(
                id='1',
                params=MessageSendParams(
                    message=Message(
                        **MESSAGE_PAYLOAD,
                        task_id=mock_task.id,
                        context_id=mock_task.context_id,
                    )
                ),
            )
            response = handler.on_message_send_stream(request)
            assert isinstance(response, AsyncGenerator)
            collected_events = [item async for item in response]
            assert len(collected_events) == len(events)
            mock_agent_executor.execute.assert_called_once()
            assert mock_task.history is not None and len(mock_task.history) == 1

    async def test_set_push_notification_success(self) -> None:
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        mock_push_notification_store = AsyncMock(
            spec=PushNotificationConfigStore
        )

        request_handler = DefaultRequestHandler(
            mock_agent_executor,
            mock_task_store,
            push_config_store=mock_push_notification_store,
        )
        self.mock_agent_card.capabilities = AgentCapabilities(
            streaming=True, push_notifications=True
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        mock_task = Task(**MINIMAL_TASK)
        mock_task_store.get.return_value = mock_task
        task_push_config = TaskPushNotificationConfig(
            task_id=mock_task.id,
            push_notification_config=PushNotificationConfig(
                url='http://example.com'
            ),
        )
        request = SetTaskPushNotificationConfigRequest(
            id='1', params=task_push_config
        )
        response: SetTaskPushNotificationConfigResponse = (
            await handler.set_push_notification_config(request)
        )
        self.assertIsInstance(
            response.root, SetTaskPushNotificationConfigSuccessResponse
        )
        assert response.root.result == task_push_config  # type: ignore
        mock_push_notification_store.set_info.assert_called_once_with(
            mock_task.id, task_push_config.push_notification_config
        )

    async def test_get_push_notification_success(self) -> None:
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        push_notification_store = InMemoryPushNotificationConfigStore()
        request_handler = DefaultRequestHandler(
            mock_agent_executor,
            mock_task_store,
            push_config_store=push_notification_store,
        )
        self.mock_agent_card.capabilities = AgentCapabilities(
            streaming=True, push_notifications=True
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        mock_task = Task(**MINIMAL_TASK)
        mock_task_store.get.return_value = mock_task
        task_push_config = TaskPushNotificationConfig(
            task_id=mock_task.id,
            push_notification_config=PushNotificationConfig(
                url='http://example.com'
            ),
        )
        request = SetTaskPushNotificationConfigRequest(
            id='1', params=task_push_config
        )
        await handler.set_push_notification_config(request)

        get_request: GetTaskPushNotificationConfigRequest = (
            GetTaskPushNotificationConfigRequest(
                id='1', params=TaskIdParams(id=mock_task.id)
            )
        )
        get_response: GetTaskPushNotificationConfigResponse = (
            await handler.get_push_notification_config(get_request)
        )
        self.assertIsInstance(
            get_response.root, GetTaskPushNotificationConfigSuccessResponse
        )
        assert get_response.root.result == task_push_config  # type: ignore

    @patch(
        'a2a.server.agent_execution.simple_request_context_builder.SimpleRequestContextBuilder.build'
    )
    async def test_on_message_stream_new_message_send_push_notification_success(
        self, _mock_builder_build: AsyncMock
    ) -> None:
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        mock_httpx_client = AsyncMock(spec=httpx.AsyncClient)
        push_notification_store = InMemoryPushNotificationConfigStore()
        push_notification_sender = BasePushNotificationSender(
            mock_httpx_client, push_notification_store
        )
        request_handler = DefaultRequestHandler(
            mock_agent_executor,
            mock_task_store,
            push_config_store=push_notification_store,
            push_sender=push_notification_sender,
        )
        self.mock_agent_card.capabilities = AgentCapabilities(
            streaming=True, push_notifications=True
        )
        _mock_builder_build.return_value = RequestContext(
            request=MagicMock(),
            task_id='task_123',
            context_id='session-xyz',
            task=None,
            related_tasks=None,
        )

        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        events: list[Any] = [
            Task(**MINIMAL_TASK),
            TaskArtifactUpdateEvent(
                task_id='task_123',
                context_id='session-xyz',
                artifact=Artifact(
                    artifact_id='11', parts=[Part(TextPart(text='text'))]
                ),
            ),
            TaskStatusUpdateEvent(
                task_id='task_123',
                context_id='session-xyz',
                status=TaskStatus(state=TaskState.completed),
                final=True,
            ),
        ]

        async def streaming_coro():
            for event in events:
                yield event

        with patch(
            'a2a.server.request_handlers.default_request_handler.EventConsumer.consume_all',
            return_value=streaming_coro(),
        ):
            mock_task_store.get.return_value = None
            mock_agent_executor.execute.return_value = None
            mock_httpx_client.post.return_value = httpx.Response(200)
            request = SendStreamingMessageRequest(
                id='1',
                params=MessageSendParams(message=Message(**MESSAGE_PAYLOAD)),
            )
            request.params.configuration = MessageSendConfiguration(
                accepted_output_modes=['text'],
                push_notification_config=PushNotificationConfig(
                    url='http://example.com'
                ),
            )
            response = handler.on_message_send_stream(request)
            assert isinstance(response, AsyncGenerator)

            collected_events = [item async for item in response]
            assert len(collected_events) == len(events)

            calls = [
                call(
                    'http://example.com',
                    json={
                        'contextId': 'session-xyz',
                        'id': 'task_123',
                        'kind': 'task',
                        'status': {'state': 'submitted'},
                    },
                    headers=None,
                ),
                call(
                    'http://example.com',
                    json={
                        'artifacts': [
                            {
                                'artifactId': '11',
                                'parts': [
                                    {
                                        'kind': 'text',
                                        'text': 'text',
                                    }
                                ],
                            }
                        ],
                        'contextId': 'session-xyz',
                        'id': 'task_123',
                        'kind': 'task',
                        'status': {'state': 'submitted'},
                    },
                    headers=None,
                ),
                call(
                    'http://example.com',
                    json={
                        'artifacts': [
                            {
                                'artifactId': '11',
                                'parts': [
                                    {
                                        'kind': 'text',
                                        'text': 'text',
                                    }
                                ],
                            }
                        ],
                        'contextId': 'session-xyz',
                        'id': 'task_123',
                        'kind': 'task',
                        'status': {'state': 'completed'},
                    },
                    headers=None,
                ),
            ]
            mock_httpx_client.post.assert_has_calls(calls)

    async def test_on_resubscribe_existing_task_success(
        self,
    ) -> None:
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        mock_queue_manager = AsyncMock(spec=QueueManager)
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store, mock_queue_manager
        )
        self.mock_agent_card = MagicMock(spec=AgentCard)
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        mock_task = Task(**MINIMAL_TASK, history=[])
        events: list[Any] = [
            TaskArtifactUpdateEvent(
                task_id='task_123',
                context_id='session-xyz',
                artifact=Artifact(
                    artifact_id='11', parts=[Part(TextPart(text='text'))]
                ),
            ),
            TaskStatusUpdateEvent(
                task_id='task_123',
                context_id='session-xyz',
                status=TaskStatus(state=TaskState.completed),
                final=True,
            ),
        ]

        async def streaming_coro():
            for event in events:
                yield event

        with patch(
            'a2a.server.request_handlers.default_request_handler.EventConsumer.consume_all',
            return_value=streaming_coro(),
        ):
            mock_task_store.get.return_value = mock_task
            mock_queue_manager.tap.return_value = EventQueue()
            request = TaskResubscriptionRequest(
                id='1', params=TaskIdParams(id=mock_task.id)
            )
            response = handler.on_resubscribe_to_task(request)
            assert isinstance(response, AsyncGenerator)
            collected_events: list[Any] = []
            async for event in response:
                collected_events.append(event)
            assert len(collected_events) == len(events)
            assert mock_task.history is not None and len(mock_task.history) == 0

    async def test_on_resubscribe_no_existing_task_error(self) -> None:
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        mock_task_store.get.return_value = None
        request = TaskResubscriptionRequest(
            id='1', params=TaskIdParams(id='nonexistent_id')
        )
        response = handler.on_resubscribe_to_task(request)
        assert isinstance(response, AsyncGenerator)
        collected_events: list[Any] = []
        async for event in response:
            collected_events.append(event)
        assert len(collected_events) == 1
        self.assertIsInstance(collected_events[0].root, JSONRPCErrorResponse)
        assert collected_events[0].root.error == TaskNotFoundError()

    async def test_streaming_not_supported_error(
        self,
    ) -> None:
        """Test that on_message_send_stream raises an error when streaming not supported."""
        # Arrange
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )
        # Create agent card with streaming capability disabled
        self.mock_agent_card.capabilities = AgentCapabilities(streaming=False)
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)

        # Act & Assert
        request = SendStreamingMessageRequest(
            id='1',
            params=MessageSendParams(message=Message(**MESSAGE_PAYLOAD)),
        )

        # Should raise ServerError about streaming not supported
        with self.assertRaises(ServerError) as context:
            async for _ in handler.on_message_send_stream(request):
                pass

        self.assertEqual(
            str(context.exception.error.message),  # type: ignore
            'Streaming is not supported by the agent',
        )

    async def test_push_notifications_not_supported_error(self) -> None:
        """Test that set_push_notification raises an error when push notifications not supported."""
        # Arrange
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )
        # Create agent card with push notifications capability disabled
        self.mock_agent_card.capabilities = AgentCapabilities(
            push_notifications=False, streaming=True
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)

        # Act & Assert
        task_push_config = TaskPushNotificationConfig(
            task_id='task_123',
            push_notification_config=PushNotificationConfig(
                url='http://example.com'
            ),
        )
        request = SetTaskPushNotificationConfigRequest(
            id='1', params=task_push_config
        )

        # Should raise ServerError about push notifications not supported
        with self.assertRaises(ServerError) as context:
            await handler.set_push_notification_config(request)

        self.assertEqual(
            str(context.exception.error.message),  # type: ignore
            'Push notifications are not supported by the agent',
        )

    async def test_on_get_push_notification_no_push_config_store(self) -> None:
        """Test get_push_notification with no push notifier configured."""
        # Arrange
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        # Create request handler without a push notifier
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )
        self.mock_agent_card.capabilities = AgentCapabilities(
            push_notifications=True
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)

        mock_task = Task(**MINIMAL_TASK)
        mock_task_store.get.return_value = mock_task

        # Act
        get_request = GetTaskPushNotificationConfigRequest(
            id='1', params=TaskIdParams(id=mock_task.id)
        )
        response = await handler.get_push_notification_config(get_request)

        # Assert
        self.assertIsInstance(response.root, JSONRPCErrorResponse)
        self.assertEqual(response.root.error, UnsupportedOperationError())  # type: ignore

    async def test_on_set_push_notification_no_push_config_store(self) -> None:
        """Test set_push_notification with no push notifier configured."""
        # Arrange
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        # Create request handler without a push notifier
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )
        self.mock_agent_card.capabilities = AgentCapabilities(
            push_notifications=True
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)

        mock_task = Task(**MINIMAL_TASK)
        mock_task_store.get.return_value = mock_task

        # Act
        task_push_config = TaskPushNotificationConfig(
            task_id=mock_task.id,
            push_notification_config=PushNotificationConfig(
                url='http://example.com'
            ),
        )
        request = SetTaskPushNotificationConfigRequest(
            id='1', params=task_push_config
        )
        response = await handler.set_push_notification_config(request)

        # Assert
        self.assertIsInstance(response.root, JSONRPCErrorResponse)
        self.assertEqual(response.root.error, UnsupportedOperationError())  # type: ignore

    async def test_on_message_send_internal_error(self) -> None:
        """Test on_message_send with an internal error."""
        # Arrange
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)

        # Make the request handler raise an Internal error without specifying an error type
        async def raise_server_error(*args, **kwargs) -> NoReturn:
            raise ServerError(InternalError(message='Internal Error'))

        # Patch the method to raise an error
        with patch.object(
            request_handler, 'on_message_send', side_effect=raise_server_error
        ):
            # Act
            request = SendMessageRequest(
                id='1',
                params=MessageSendParams(message=Message(**MESSAGE_PAYLOAD)),
            )
            response = await handler.on_message_send(request)

            # Assert
            self.assertIsInstance(response.root, JSONRPCErrorResponse)
            self.assertIsInstance(response.root.error, InternalError)  # type: ignore

    async def test_on_message_stream_internal_error(self) -> None:
        """Test on_message_send_stream with an internal error."""
        # Arrange
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )
        self.mock_agent_card.capabilities = AgentCapabilities(streaming=True)
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)

        # Make the request handler raise an Internal error without specifying an error type
        async def raise_server_error(*args, **kwargs):
            raise ServerError(InternalError(message='Internal Error'))
            yield  # Need this to make it an async generator

        # Patch the method to raise an error
        with patch.object(
            request_handler,
            'on_message_send_stream',
            return_value=raise_server_error(),
        ):
            # Act
            request = SendStreamingMessageRequest(
                id='1',
                params=MessageSendParams(message=Message(**MESSAGE_PAYLOAD)),
            )

            # Get the single error response
            responses = []
            async for response in handler.on_message_send_stream(request):
                responses.append(response)

            # Assert
            self.assertEqual(len(responses), 1)
            self.assertIsInstance(responses[0].root, JSONRPCErrorResponse)
            self.assertIsInstance(responses[0].root.error, InternalError)

    async def test_default_request_handler_with_custom_components(self) -> None:
        """Test DefaultRequestHandler initialization with custom components."""
        # Arrange
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        mock_queue_manager = AsyncMock(spec=QueueManager)
        mock_push_config_store = AsyncMock(spec=PushNotificationConfigStore)
        mock_push_sender = AsyncMock(spec=PushNotificationSender)
        mock_request_context_builder = AsyncMock(spec=RequestContextBuilder)

        # Act
        handler = DefaultRequestHandler(
            agent_executor=mock_agent_executor,
            task_store=mock_task_store,
            queue_manager=mock_queue_manager,
            push_config_store=mock_push_config_store,
            push_sender=mock_push_sender,
            request_context_builder=mock_request_context_builder,
        )

        # Assert
        self.assertEqual(handler.agent_executor, mock_agent_executor)
        self.assertEqual(handler.task_store, mock_task_store)
        self.assertEqual(handler._queue_manager, mock_queue_manager)
        self.assertEqual(handler._push_config_store, mock_push_config_store)
        self.assertEqual(handler._push_sender, mock_push_sender)
        self.assertEqual(
            handler._request_context_builder, mock_request_context_builder
        )

    async def test_on_message_send_error_handling(self) -> None:
        """Test error handling in on_message_send when consuming raises ServerError."""
        # Arrange
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)

        # Let task exist
        mock_task = Task(**MINIMAL_TASK)
        mock_task_store.get.return_value = mock_task

        # Set up consume_and_break_on_interrupt to raise ServerError
        async def consume_raises_error(*args, **kwargs) -> NoReturn:
            raise ServerError(error=UnsupportedOperationError())

        with patch(
            'a2a.server.tasks.result_aggregator.ResultAggregator.consume_and_break_on_interrupt',
            side_effect=consume_raises_error,
        ):
            # Act
            request = SendMessageRequest(
                id='1',
                params=MessageSendParams(
                    message=Message(
                        **MESSAGE_PAYLOAD,
                        task_id=mock_task.id,
                        context_id=mock_task.context_id,
                    )
                ),
            )

            response = await handler.on_message_send(request)

            # Assert
            self.assertIsInstance(response.root, JSONRPCErrorResponse)
            self.assertEqual(response.root.error, UnsupportedOperationError())  # type: ignore

    async def test_on_message_send_task_id_mismatch(self) -> None:
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        mock_task = Task(**MINIMAL_TASK)
        mock_task_store.get.return_value = mock_task
        mock_agent_executor.execute.return_value = None

        async def streaming_coro():
            yield mock_task

        with patch(
            'a2a.server.request_handlers.default_request_handler.EventConsumer.consume_all',
            return_value=streaming_coro(),
        ):
            request = SendMessageRequest(
                id='1',
                params=MessageSendParams(message=Message(**MESSAGE_PAYLOAD)),
            )
            response = await handler.on_message_send(request)
            assert mock_agent_executor.execute.call_count == 1
            self.assertIsInstance(response.root, JSONRPCErrorResponse)
            self.assertIsInstance(response.root.error, InternalError)  # type: ignore

    async def test_on_message_stream_task_id_mismatch(self) -> None:
        mock_agent_executor = AsyncMock(spec=AgentExecutor)
        mock_task_store = AsyncMock(spec=TaskStore)
        request_handler = DefaultRequestHandler(
            mock_agent_executor, mock_task_store
        )

        self.mock_agent_card.capabilities = AgentCapabilities(streaming=True)
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        events: list[Any] = [Task(**MINIMAL_TASK)]

        async def streaming_coro():
            for event in events:
                yield event

        with patch(
            'a2a.server.request_handlers.default_request_handler.EventConsumer.consume_all',
            return_value=streaming_coro(),
        ):
            mock_task_store.get.return_value = None
            mock_agent_executor.execute.return_value = None
            request = SendStreamingMessageRequest(
                id='1',
                params=MessageSendParams(message=Message(**MESSAGE_PAYLOAD)),
            )
            response = handler.on_message_send_stream(request)
            assert isinstance(response, AsyncGenerator)
            collected_events: list[Any] = []
            async for event in response:
                collected_events.append(event)
            assert len(collected_events) == 1
            self.assertIsInstance(
                collected_events[0].root, JSONRPCErrorResponse
            )
            self.assertIsInstance(collected_events[0].root.error, InternalError)

    async def test_on_get_push_notification(self) -> None:
        """Test get_push_notification_config handling"""
        mock_task_store = AsyncMock(spec=TaskStore)

        mock_task = Task(**MINIMAL_TASK)
        mock_task_store.get.return_value = mock_task

        # Create request handler without a push notifier
        request_handler = AsyncMock(spec=DefaultRequestHandler)
        task_push_config = TaskPushNotificationConfig(
            task_id=mock_task.id,
            push_notification_config=PushNotificationConfig(
                id='config1', url='http://example.com'
            ),
        )
        request_handler.on_get_task_push_notification_config.return_value = (
            task_push_config
        )

        self.mock_agent_card.capabilities = AgentCapabilities(
            push_notifications=True
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        list_request = GetTaskPushNotificationConfigRequest(
            id='1',
            params=GetTaskPushNotificationConfigParams(
                id=mock_task.id, push_notification_config_id='config1'
            ),
        )
        response = await handler.get_push_notification_config(list_request)
        # Assert
        self.assertIsInstance(
            response.root, GetTaskPushNotificationConfigSuccessResponse
        )
        self.assertEqual(response.root.result, task_push_config)  # type: ignore

    async def test_on_list_push_notification(self) -> None:
        """Test list_push_notification_config handling"""
        mock_task_store = AsyncMock(spec=TaskStore)

        mock_task = Task(**MINIMAL_TASK)
        mock_task_store.get.return_value = mock_task

        # Create request handler without a push notifier
        request_handler = AsyncMock(spec=DefaultRequestHandler)
        task_push_config = TaskPushNotificationConfig(
            task_id=mock_task.id,
            push_notification_config=PushNotificationConfig(
                url='http://example.com'
            ),
        )
        request_handler.on_list_task_push_notification_config.return_value = [
            task_push_config
        ]

        self.mock_agent_card.capabilities = AgentCapabilities(
            push_notifications=True
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        list_request = ListTaskPushNotificationConfigRequest(
            id='1', params=ListTaskPushNotificationConfigParams(id=mock_task.id)
        )
        response = await handler.list_push_notification_config(list_request)
        # Assert
        self.assertIsInstance(
            response.root, ListTaskPushNotificationConfigSuccessResponse
        )
        self.assertEqual(response.root.result, [task_push_config])  # type: ignore

    async def test_on_list_push_notification_error(self) -> None:
        """Test list_push_notification_config handling"""
        mock_task_store = AsyncMock(spec=TaskStore)

        mock_task = Task(**MINIMAL_TASK)
        mock_task_store.get.return_value = mock_task

        # Create request handler without a push notifier
        request_handler = AsyncMock(spec=DefaultRequestHandler)
        _ = TaskPushNotificationConfig(
            task_id=mock_task.id,
            push_notification_config=PushNotificationConfig(
                url='http://example.com'
            ),
        )
        # throw server error
        request_handler.on_list_task_push_notification_config.side_effect = (
            ServerError(InternalError())
        )

        self.mock_agent_card.capabilities = AgentCapabilities(
            push_notifications=True
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        list_request = ListTaskPushNotificationConfigRequest(
            id='1', params=ListTaskPushNotificationConfigParams(id=mock_task.id)
        )
        response = await handler.list_push_notification_config(list_request)
        # Assert
        self.assertIsInstance(response.root, JSONRPCErrorResponse)
        self.assertEqual(response.root.error, InternalError())  # type: ignore

    async def test_on_delete_push_notification(self) -> None:
        """Test delete_push_notification_config handling"""

        # Create request handler without a push notifier
        request_handler = AsyncMock(spec=DefaultRequestHandler)
        request_handler.on_delete_task_push_notification_config.return_value = (
            None
        )

        self.mock_agent_card.capabilities = AgentCapabilities(
            push_notifications=True
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        delete_request = DeleteTaskPushNotificationConfigRequest(
            id='1',
            params=DeleteTaskPushNotificationConfigParams(
                id='task1', push_notification_config_id='config1'
            ),
        )
        response = await handler.delete_push_notification_config(delete_request)
        # Assert
        self.assertIsInstance(
            response.root, DeleteTaskPushNotificationConfigSuccessResponse
        )
        self.assertEqual(response.root.result, None)  # type: ignore

    async def test_on_delete_push_notification_error(self) -> None:
        """Test delete_push_notification_config error handling"""

        # Create request handler without a push notifier
        request_handler = AsyncMock(spec=DefaultRequestHandler)
        # throw server error
        request_handler.on_delete_task_push_notification_config.side_effect = (
            ServerError(UnsupportedOperationError())
        )

        self.mock_agent_card.capabilities = AgentCapabilities(
            push_notifications=True
        )
        handler = JSONRPCHandler(self.mock_agent_card, request_handler)
        delete_request = DeleteTaskPushNotificationConfigRequest(
            id='1',
            params=DeleteTaskPushNotificationConfigParams(
                id='task1', push_notification_config_id='config1'
            ),
        )
        response = await handler.delete_push_notification_config(delete_request)
        # Assert
        self.assertIsInstance(response.root, JSONRPCErrorResponse)
        self.assertEqual(response.root.error, UnsupportedOperationError())  # type: ignore

    async def test_get_authenticated_extended_card_success(self) -> None:
        """Test successful retrieval of the authenticated extended agent card."""
        # Arrange
        mock_request_handler = AsyncMock(spec=DefaultRequestHandler)
        mock_extended_card = AgentCard(
            name='Extended Card',
            description='More details',
            url='http://agent.example.com/api',
            version='1.1',
            capabilities=AgentCapabilities(),
            default_input_modes=['text/plain'],
            default_output_modes=['application/json'],
            skills=[],
        )
        handler = JSONRPCHandler(
            self.mock_agent_card,
            mock_request_handler,
            extended_agent_card=mock_extended_card,
            extended_card_modifier=None,
        )
        request = GetAuthenticatedExtendedCardRequest(id='ext-card-req-1')
        call_context = ServerCallContext(state={'foo': 'bar'})

        # Act
        response: GetAuthenticatedExtendedCardResponse = (
            await handler.get_authenticated_extended_card(request, call_context)
        )

        # Assert
        self.assertIsInstance(
            response.root, GetAuthenticatedExtendedCardSuccessResponse
        )
        self.assertEqual(response.root.id, 'ext-card-req-1')
        self.assertEqual(response.root.result, mock_extended_card)

    async def test_get_authenticated_extended_card_not_configured(self) -> None:
        """Test error when authenticated extended agent card is not configured."""
        # Arrange
        mock_request_handler = AsyncMock(spec=DefaultRequestHandler)
        handler = JSONRPCHandler(
            self.mock_agent_card,
            mock_request_handler,
            extended_agent_card=None,
            extended_card_modifier=None,
        )
        request = GetAuthenticatedExtendedCardRequest(id='ext-card-req-2')
        call_context = ServerCallContext(state={'foo': 'bar'})

        # Act
        response: GetAuthenticatedExtendedCardResponse = (
            await handler.get_authenticated_extended_card(request, call_context)
        )

        # Assert
        self.assertIsInstance(response.root, JSONRPCErrorResponse)
        self.assertEqual(response.root.id, 'ext-card-req-2')
        self.assertIsInstance(
            response.root.error, AuthenticatedExtendedCardNotConfiguredError
        )

    async def test_get_authenticated_extended_card_with_modifier(self) -> None:
        """Test successful retrieval of a dynamically modified extended agent card."""
        # Arrange
        mock_request_handler = AsyncMock(spec=DefaultRequestHandler)
        mock_base_card = AgentCard(
            name='Base Card',
            description='Base details',
            url='http://agent.example.com/api',
            version='1.0',
            capabilities=AgentCapabilities(),
            default_input_modes=['text/plain'],
            default_output_modes=['application/json'],
            skills=[],
        )

        def modifier(card: AgentCard, context: ServerCallContext) -> AgentCard:
            modified_card = card.model_copy(deep=True)
            modified_card.name = 'Modified Card'
            modified_card.description = (
                f'Modified for context: {context.state.get("foo")}'
            )
            return modified_card

        handler = JSONRPCHandler(
            self.mock_agent_card,
            mock_request_handler,
            extended_agent_card=mock_base_card,
            extended_card_modifier=modifier,
        )
        request = GetAuthenticatedExtendedCardRequest(id='ext-card-req-mod')
        call_context = ServerCallContext(state={'foo': 'bar'})

        # Act
        response: GetAuthenticatedExtendedCardResponse = (
            await handler.get_authenticated_extended_card(request, call_context)
        )

        # Assert
        self.assertIsInstance(
            response.root, GetAuthenticatedExtendedCardSuccessResponse
        )
        self.assertEqual(response.root.id, 'ext-card-req-mod')
        modified_card = response.root.result
        self.assertEqual(modified_card.name, 'Modified Card')
        self.assertEqual(modified_card.description, 'Modified for context: bar')
        self.assertEqual(modified_card.version, '1.0')



---
File: /a2a-python/tests/server/request_handlers/test_response_helpers.py
---

import unittest

from unittest.mock import patch

from a2a.server.request_handlers.response_helpers import (
    build_error_response,
    prepare_response_object,
)
from a2a.types import (
    A2AError,
    GetTaskResponse,
    GetTaskSuccessResponse,
    InvalidAgentResponseError,
    InvalidParamsError,
    JSONRPCError,
    JSONRPCErrorResponse,
    Task,
    TaskNotFoundError,
    TaskState,
    TaskStatus,
)


class TestResponseHelpers(unittest.TestCase):
    def test_build_error_response_with_a2a_error(self):
        request_id = 'req1'
        specific_error = TaskNotFoundError()
        a2a_error = A2AError(root=specific_error)  # Correctly wrap
        response_wrapper = build_error_response(
            request_id, a2a_error, GetTaskResponse
        )
        self.assertIsInstance(response_wrapper, GetTaskResponse)
        self.assertIsInstance(response_wrapper.root, JSONRPCErrorResponse)
        self.assertEqual(response_wrapper.root.id, request_id)
        self.assertEqual(
            response_wrapper.root.error, specific_error
        )  # build_error_response unwraps A2AError

    def test_build_error_response_with_jsonrpc_error(self):
        request_id = 123
        json_rpc_error = InvalidParamsError(
            message='Custom invalid params'
        )  # This is a specific error, not A2AError wrapped
        response_wrapper = build_error_response(
            request_id, json_rpc_error, GetTaskResponse
        )
        self.assertIsInstance(response_wrapper, GetTaskResponse)
        self.assertIsInstance(response_wrapper.root, JSONRPCErrorResponse)
        self.assertEqual(response_wrapper.root.id, request_id)
        self.assertEqual(
            response_wrapper.root.error, json_rpc_error
        )  # No .root access for json_rpc_error

    def test_build_error_response_with_a2a_wrapping_jsonrpc_error(self):
        request_id = 'req_wrap'
        specific_jsonrpc_error = InvalidParamsError(message='Detail error')
        a2a_error_wrapping = A2AError(
            root=specific_jsonrpc_error
        )  # Correctly wrap
        response_wrapper = build_error_response(
            request_id, a2a_error_wrapping, GetTaskResponse
        )
        self.assertIsInstance(response_wrapper, GetTaskResponse)
        self.assertIsInstance(response_wrapper.root, JSONRPCErrorResponse)
        self.assertEqual(response_wrapper.root.id, request_id)
        self.assertEqual(response_wrapper.root.error, specific_jsonrpc_error)

    def test_build_error_response_with_request_id_string(self):
        request_id = 'string_id_test'
        # Pass an A2AError-wrapped specific error for consistency with how build_error_response handles A2AError
        error = A2AError(root=TaskNotFoundError())
        response_wrapper = build_error_response(
            request_id, error, GetTaskResponse
        )
        self.assertIsInstance(response_wrapper.root, JSONRPCErrorResponse)
        self.assertEqual(response_wrapper.root.id, request_id)

    def test_build_error_response_with_request_id_int(self):
        request_id = 456
        error = A2AError(root=TaskNotFoundError())
        response_wrapper = build_error_response(
            request_id, error, GetTaskResponse
        )
        self.assertIsInstance(response_wrapper.root, JSONRPCErrorResponse)
        self.assertEqual(response_wrapper.root.id, request_id)

    def test_build_error_response_with_request_id_none(self):
        request_id = None
        error = A2AError(root=TaskNotFoundError())
        response_wrapper = build_error_response(
            request_id, error, GetTaskResponse
        )
        self.assertIsInstance(response_wrapper.root, JSONRPCErrorResponse)
        self.assertIsNone(response_wrapper.root.id)

    def _create_sample_task(self, task_id='task123', context_id='ctx456'):
        return Task(
            id=task_id,
            context_id=context_id,
            status=TaskStatus(state=TaskState.submitted),
            history=[],
        )

    def test_prepare_response_object_successful_response(self):
        request_id = 'req_success'
        task_result = self._create_sample_task()
        response_wrapper = prepare_response_object(
            request_id=request_id,
            response=task_result,
            success_response_types=(Task,),
            success_payload_type=GetTaskSuccessResponse,
            response_type=GetTaskResponse,
        )
        self.assertIsInstance(response_wrapper, GetTaskResponse)
        self.assertIsInstance(response_wrapper.root, GetTaskSuccessResponse)
        self.assertEqual(response_wrapper.root.id, request_id)
        self.assertEqual(response_wrapper.root.result, task_result)

    @patch('a2a.server.request_handlers.response_helpers.build_error_response')
    def test_prepare_response_object_with_a2a_error_instance(
        self, mock_build_error
    ):
        request_id = 'req_a2a_err'
        specific_error = TaskNotFoundError()
        a2a_error_instance = A2AError(
            root=specific_error
        )  # Correctly wrapped A2AError

        # This is what build_error_response (when called by prepare_response_object) will return
        mock_wrapped_error_response = GetTaskResponse(
            root=JSONRPCErrorResponse(
                id=request_id, error=specific_error, jsonrpc='2.0'
            )
        )
        mock_build_error.return_value = mock_wrapped_error_response

        response_wrapper = prepare_response_object(
            request_id=request_id,
            response=a2a_error_instance,  # Pass the A2AError instance
            success_response_types=(Task,),
            success_payload_type=GetTaskSuccessResponse,
            response_type=GetTaskResponse,
        )
        # prepare_response_object should identify A2AError and call build_error_response
        mock_build_error.assert_called_once_with(
            request_id, a2a_error_instance, GetTaskResponse
        )
        self.assertEqual(response_wrapper, mock_wrapped_error_response)

    @patch('a2a.server.request_handlers.response_helpers.build_error_response')
    def test_prepare_response_object_with_jsonrpcerror_base_instance(
        self, mock_build_error
    ):
        request_id = 789
        # Use the base JSONRPCError class instance
        json_rpc_base_error = JSONRPCError(
            code=-32000, message='Generic JSONRPC error'
        )

        mock_wrapped_error_response = GetTaskResponse(
            root=JSONRPCErrorResponse(
                id=request_id, error=json_rpc_base_error, jsonrpc='2.0'
            )
        )
        mock_build_error.return_value = mock_wrapped_error_response

        response_wrapper = prepare_response_object(
            request_id=request_id,
            response=json_rpc_base_error,  # Pass the JSONRPCError instance
            success_response_types=(Task,),
            success_payload_type=GetTaskSuccessResponse,
            response_type=GetTaskResponse,
        )
        # prepare_response_object should identify JSONRPCError and call build_error_response
        mock_build_error.assert_called_once_with(
            request_id, json_rpc_base_error, GetTaskResponse
        )
        self.assertEqual(response_wrapper, mock_wrapped_error_response)

    @patch('a2a.server.request_handlers.response_helpers.build_error_response')
    def test_prepare_response_object_specific_error_model_as_unexpected(
        self, mock_build_error
    ):
        request_id = 'req_specific_unexpected'
        # Pass a specific error model (like TaskNotFoundError) directly, NOT wrapped in A2AError
        # This should be treated as an "unexpected" type by prepare_response_object's current logic
        specific_error_direct = TaskNotFoundError()

        # This is the InvalidAgentResponseError that prepare_response_object will generate
        generated_error_wrapper = A2AError(
            root=InvalidAgentResponseError(
                message='Agent returned invalid type response for this method'
            )
        )

        # This is what build_error_response will be called with (the generated error)
        # And this is what it will return (the generated error, wrapped in GetTaskResponse)
        mock_final_wrapped_response = GetTaskResponse(
            root=JSONRPCErrorResponse(
                id=request_id, error=generated_error_wrapper.root, jsonrpc='2.0'
            )
        )
        mock_build_error.return_value = mock_final_wrapped_response

        response_wrapper = prepare_response_object(
            request_id=request_id,
            response=specific_error_direct,  # Pass TaskNotFoundError() directly
            success_response_types=(Task,),
            success_payload_type=GetTaskSuccessResponse,
            response_type=GetTaskResponse,
        )

        self.assertEqual(mock_build_error.call_count, 1)
        args, _ = mock_build_error.call_args
        self.assertEqual(args[0], request_id)
        # Check that the error passed to build_error_response is the generated A2AError(InvalidAgentResponseError)
        self.assertIsInstance(args[1], A2AError)
        self.assertIsInstance(args[1].root, InvalidAgentResponseError)
        self.assertEqual(args[2], GetTaskResponse)
        self.assertEqual(response_wrapper, mock_final_wrapped_response)

    def test_prepare_response_object_with_request_id_string(self):
        request_id = 'string_id_prep'
        task_result = self._create_sample_task()
        response_wrapper = prepare_response_object(
            request_id=request_id,
            response=task_result,
            success_response_types=(Task,),
            success_payload_type=GetTaskSuccessResponse,
            response_type=GetTaskResponse,
        )
        self.assertIsInstance(response_wrapper.root, GetTaskSuccessResponse)
        self.assertEqual(response_wrapper.root.id, request_id)

    def test_prepare_response_object_with_request_id_int(self):
        request_id = 101112
        task_result = self._create_sample_task()
        response_wrapper = prepare_response_object(
            request_id=request_id,
            response=task_result,
            success_response_types=(Task,),
            success_payload_type=GetTaskSuccessResponse,
            response_type=GetTaskResponse,
        )
        self.assertIsInstance(response_wrapper.root, GetTaskSuccessResponse)
        self.assertEqual(response_wrapper.root.id, request_id)

    def test_prepare_response_object_with_request_id_none(self):
        request_id = None
        task_result = self._create_sample_task()
        response_wrapper = prepare_response_object(
            request_id=request_id,
            response=task_result,
            success_response_types=(Task,),
            success_payload_type=GetTaskSuccessResponse,
            response_type=GetTaskResponse,
        )
        self.assertIsInstance(response_wrapper.root, GetTaskSuccessResponse)
        self.assertIsNone(response_wrapper.root.id)


if __name__ == '__main__':
    unittest.main()



---
File: /a2a-python/tests/server/tasks/test_database_push_notification_config_store.py
---

import os

from collections.abc import AsyncGenerator

import pytest


# Skip entire test module if SQLAlchemy is not installed
pytest.importorskip('sqlalchemy', reason='Database tests require SQLAlchemy')
pytest.importorskip(
    'cryptography',
    reason='Database tests require Cryptography. Install extra encryption',
)

import pytest_asyncio

from _pytest.mark.structures import ParameterSet

# Now safe to import SQLAlchemy-dependent modules
from cryptography.fernet import Fernet
from sqlalchemy import select
from sqlalchemy.ext.asyncio import (
    async_sessionmaker,
    create_async_engine,
)
from sqlalchemy.inspection import inspect

from a2a.server.models import (
    Base,
    PushNotificationConfigModel,
)  # Important: To get Base.metadata
from a2a.server.tasks import DatabasePushNotificationConfigStore
from a2a.types import (
    PushNotificationConfig,
    Task,
    TaskState,
    TaskStatus,
)


# DSNs for different databases
SQLITE_TEST_DSN = (
    'sqlite+aiosqlite:///file:testdb?mode=memory&cache=shared&uri=true'
)
POSTGRES_TEST_DSN = os.environ.get(
    'POSTGRES_TEST_DSN'
)  # e.g., "postgresql+asyncpg://user:pass@host:port/dbname"
MYSQL_TEST_DSN = os.environ.get(
    'MYSQL_TEST_DSN'
)  # e.g., "mysql+aiomysql://user:pass@host:port/dbname"

# Parameterization for the db_store fixture
DB_CONFIGS: list[ParameterSet | tuple[str | None, str]] = [
    pytest.param((SQLITE_TEST_DSN, 'sqlite'), id='sqlite')
]

if POSTGRES_TEST_DSN:
    DB_CONFIGS.append(
        pytest.param((POSTGRES_TEST_DSN, 'postgresql'), id='postgresql')
    )
else:
    DB_CONFIGS.append(
        pytest.param(
            (None, 'postgresql'),
            marks=pytest.mark.skip(reason='POSTGRES_TEST_DSN not set'),
            id='postgresql_skipped',
        )
    )

if MYSQL_TEST_DSN:
    DB_CONFIGS.append(pytest.param((MYSQL_TEST_DSN, 'mysql'), id='mysql'))
else:
    DB_CONFIGS.append(
        pytest.param(
            (None, 'mysql'),
            marks=pytest.mark.skip(reason='MYSQL_TEST_DSN not set'),
            id='mysql_skipped',
        )
    )


# Minimal Task object for testing - remains the same
task_status_submitted = TaskStatus(
    state=TaskState.submitted, timestamp='2023-01-01T00:00:00Z'
)
MINIMAL_TASK_OBJ = Task(
    id='task-abc',
    context_id='session-xyz',
    status=task_status_submitted,
    kind='task',
    metadata={'test_key': 'test_value'},
    artifacts=[],
    history=[],
)


@pytest_asyncio.fixture(params=DB_CONFIGS)
async def db_store_parameterized(
    request,
) -> AsyncGenerator[DatabasePushNotificationConfigStore, None]:
    """
    Fixture that provides a DatabaseTaskStore connected to different databases
    based on parameterization (SQLite, PostgreSQL, MySQL).
    """
    db_url, dialect_name = request.param

    if db_url is None:
        pytest.skip(f'DSN for {dialect_name} not set in environment variables.')

    engine = create_async_engine(db_url)
    store = None  # Initialize store to None for the finally block

    try:
        # Create tables
        async with engine.begin() as conn:
            await conn.run_sync(Base.metadata.create_all)

        # create_table=False as we've explicitly created tables above.
        store = DatabasePushNotificationConfigStore(
            engine=engine,
            create_table=False,
            encryption_key=Fernet.generate_key(),
        )
        # Initialize the store (connects, etc.). Safe to call even if tables exist.
        await store.initialize()

        yield store

    finally:
        if engine:  # If engine was created for setup/teardown
            # Drop tables using the fixture's engine
            async with engine.begin() as conn:
                await conn.run_sync(Base.metadata.drop_all)
            await engine.dispose()  # Dispose the engine created in the fixture


@pytest.mark.asyncio
async def test_initialize_creates_table(
    db_store_parameterized: DatabasePushNotificationConfigStore,
) -> None:
    """Test that tables are created (implicitly by fixture setup)."""
    # Ensure store is initialized (already done by fixture, but good for clarity)
    await db_store_parameterized._ensure_initialized()

    # Use the store's engine for inspection
    async with db_store_parameterized.engine.connect() as conn:

        def has_table_sync(sync_conn):
            inspector = inspect(sync_conn)
            return inspector.has_table(
                PushNotificationConfigModel.__tablename__
            )

        assert await conn.run_sync(has_table_sync)


@pytest.mark.asyncio
async def test_initialize_is_idempotent(
    db_store_parameterized: DatabasePushNotificationConfigStore,
) -> None:
    """Test that tables are created (implicitly by fixture setup)."""
    # Ensure store is initialized (already done by fixture, but good for clarity)
    await db_store_parameterized.initialize()
    # Call initialize again to check idempotency
    await db_store_parameterized.initialize()


@pytest.mark.asyncio
async def test_set_and_get_info_single_config(
    db_store_parameterized: DatabasePushNotificationConfigStore,
):
    """Test setting and retrieving a single configuration."""
    task_id = 'task-1'
    config = PushNotificationConfig(id='config-1', url='http://example.com')

    await db_store_parameterized.set_info(task_id, config)
    retrieved_configs = await db_store_parameterized.get_info(task_id)

    assert len(retrieved_configs) == 1
    assert retrieved_configs[0] == config


@pytest.mark.asyncio
async def test_set_and_get_info_multiple_configs(
    db_store_parameterized: DatabasePushNotificationConfigStore,
):
    """Test setting and retrieving multiple configurations for a single task."""

    task_id = 'task-1'
    config1 = PushNotificationConfig(id='config-1', url='http://example.com/1')
    config2 = PushNotificationConfig(id='config-2', url='http://example.com/2')

    await db_store_parameterized.set_info(task_id, config1)
    await db_store_parameterized.set_info(task_id, config2)
    retrieved_configs = await db_store_parameterized.get_info(task_id)

    assert len(retrieved_configs) == 2
    assert config1 in retrieved_configs
    assert config2 in retrieved_configs


@pytest.mark.asyncio
async def test_set_info_updates_existing_config(
    db_store_parameterized: DatabasePushNotificationConfigStore,
):
    """Test that setting an existing config ID updates the record."""
    task_id = 'task-1'
    config_id = 'config-1'
    initial_config = PushNotificationConfig(
        id=config_id, url='http://initial.url'
    )
    updated_config = PushNotificationConfig(
        id=config_id, url='http://updated.url'
    )

    await db_store_parameterized.set_info(task_id, initial_config)
    await db_store_parameterized.set_info(task_id, updated_config)
    retrieved_configs = await db_store_parameterized.get_info(task_id)

    assert len(retrieved_configs) == 1
    assert retrieved_configs[0].url == 'http://updated.url'


@pytest.mark.asyncio
async def test_set_info_defaults_config_id_to_task_id(
    db_store_parameterized: DatabasePushNotificationConfigStore,
):
    """Test that config.id defaults to task_id if not provided."""
    task_id = 'task-1'
    config = PushNotificationConfig(url='http://example.com')  # id is None

    await db_store_parameterized.set_info(task_id, config)
    retrieved_configs = await db_store_parameterized.get_info(task_id)

    assert len(retrieved_configs) == 1
    assert retrieved_configs[0].id == task_id


@pytest.mark.asyncio
async def test_get_info_not_found(
    db_store_parameterized: DatabasePushNotificationConfigStore,
):
    """Test getting info for a task with no configs returns an empty list."""
    retrieved_configs = await db_store_parameterized.get_info(
        'non-existent-task'
    )
    assert retrieved_configs == []


@pytest.mark.asyncio
async def test_delete_info_specific_config(
    db_store_parameterized: DatabasePushNotificationConfigStore,
):
    """Test deleting a single, specific configuration."""
    task_id = 'task-1'
    config1 = PushNotificationConfig(id='config-1', url='http://a.com')
    config2 = PushNotificationConfig(id='config-2', url='http://b.com')

    await db_store_parameterized.set_info(task_id, config1)
    await db_store_parameterized.set_info(task_id, config2)

    await db_store_parameterized.delete_info(task_id, 'config-1')
    retrieved_configs = await db_store_parameterized.get_info(task_id)

    assert len(retrieved_configs) == 1
    assert retrieved_configs[0] == config2


@pytest.mark.asyncio
async def test_delete_info_all_for_task(
    db_store_parameterized: DatabasePushNotificationConfigStore,
):
    """Test deleting all configurations for a task when config_id is None."""

    task_id = 'task-1'
    config1 = PushNotificationConfig(id='config-1', url='http://a.com')
    config2 = PushNotificationConfig(id='config-2', url='http://b.com')

    await db_store_parameterized.set_info(task_id, config1)
    await db_store_parameterized.set_info(task_id, config2)

    await db_store_parameterized.delete_info(task_id, None)
    retrieved_configs = await db_store_parameterized.get_info(task_id)

    assert retrieved_configs == []


@pytest.mark.asyncio
async def test_delete_info_not_found(
    db_store_parameterized: DatabasePushNotificationConfigStore,
):
    """Test that deleting a non-existent config does not raise an error."""
    # Should not raise
    await db_store_parameterized.delete_info('task-1', 'non-existent-config')


@pytest.mark.asyncio
async def test_data_is_encrypted_in_db(
    db_store_parameterized: DatabasePushNotificationConfigStore,
):
    """Verify that the data stored in the database is actually encrypted."""
    task_id = 'encrypted-task'
    config = PushNotificationConfig(
        id='config-1', url='http://secret.url', token='secret-token'
    )
    plain_json = config.model_dump_json()

    await db_store_parameterized.set_info(task_id, config)

    # Directly query the database to inspect the raw data
    async_session = async_sessionmaker(
        db_store_parameterized.engine, expire_on_commit=False
    )
    async with async_session() as session:
        stmt = select(PushNotificationConfigModel).where(
            PushNotificationConfigModel.task_id == task_id
        )
        result = await session.execute(stmt)
        db_model = result.scalar_one()

    assert db_model.config_data != plain_json.encode('utf-8')

    fernet = db_store_parameterized._fernet

    decrypted_data = fernet.decrypt(db_model.config_data)  # type: ignore
    assert decrypted_data.decode('utf-8') == plain_json


@pytest.mark.asyncio
async def test_decryption_error_with_wrong_key(
    db_store_parameterized: DatabasePushNotificationConfigStore,
):
    """Test that using the wrong key to decrypt raises a ValueError."""
    # 1. Store with one key

    task_id = 'wrong-key-task'
    config = PushNotificationConfig(id='config-1', url='http://secret.url')
    await db_store_parameterized.set_info(task_id, config)

    # 2. Try to read with a different key
    # Directly query the database to inspect the raw data
    wrong_key = Fernet.generate_key()
    store2 = DatabasePushNotificationConfigStore(
        db_store_parameterized.engine, encryption_key=wrong_key
    )

    retrieved_configs = await store2.get_info(task_id)
    assert retrieved_configs == []

    # _from_orm should raise a ValueError
    async_session = async_sessionmaker(
        db_store_parameterized.engine, expire_on_commit=False
    )
    async with async_session() as session:
        db_model = await session.get(
            PushNotificationConfigModel, (task_id, 'config-1')
        )

        with pytest.raises(ValueError):
            store2._from_orm(db_model)  # type: ignore


@pytest.mark.asyncio
async def test_decryption_error_with_no_key(
    db_store_parameterized: DatabasePushNotificationConfigStore,
):
    """Test that using the wrong key to decrypt raises a ValueError."""
    # 1. Store with one key

    task_id = 'wrong-key-task'
    config = PushNotificationConfig(id='config-1', url='http://secret.url')
    await db_store_parameterized.set_info(task_id, config)

    # 2. Try to read with no key set
    # Directly query the database to inspect the raw data
    store2 = DatabasePushNotificationConfigStore(db_store_parameterized.engine)

    retrieved_configs = await store2.get_info(task_id)
    assert retrieved_configs == []

    # _from_orm should raise a ValueError
    async_session = async_sessionmaker(
        db_store_parameterized.engine, expire_on_commit=False
    )
    async with async_session() as session:
        db_model = await session.get(
            PushNotificationConfigModel, (task_id, 'config-1')
        )

        with pytest.raises(ValueError):
            store2._from_orm(db_model)  # type: ignore


@pytest.mark.asyncio
async def test_custom_table_name(
    db_store_parameterized: DatabasePushNotificationConfigStore,
):
    """Test that the store works correctly with a custom table name."""
    table_name = 'my_custom_push_configs'
    engine = db_store_parameterized.engine
    custom_store = None
    try:
        # Use a new store with a custom table name
        custom_store = DatabasePushNotificationConfigStore(
            engine=engine,
            create_table=True,
            table_name=table_name,
            encryption_key=Fernet.generate_key(),
        )

        task_id = 'custom-table-task'
        config = PushNotificationConfig(id='config-1', url='http://custom.url')

        # This will create the table on first use
        await custom_store.set_info(task_id, config)
        retrieved_configs = await custom_store.get_info(task_id)

        assert len(retrieved_configs) == 1
        assert retrieved_configs[0] == config

        # Verify the custom table exists and has data
        async with custom_store.engine.connect() as conn:

            def has_table_sync(sync_conn):
                inspector = inspect(sync_conn)
                return inspector.has_table(table_name)

            assert await conn.run_sync(has_table_sync)

            result = await conn.execute(
                select(custom_store.config_model).where(
                    custom_store.config_model.task_id == task_id
                )
            )
            assert result.scalar_one_or_none() is not None
    finally:
        if custom_store:
            # Clean up the dynamically created table from the metadata
            # to prevent errors in subsequent parameterized test runs.
            Base.metadata.remove(custom_store.config_model.__table__)  # type: ignore


@pytest.mark.asyncio
async def test_set_and_get_info_multiple_configs_no_key(
    db_store_parameterized: DatabasePushNotificationConfigStore,
):
    """Test setting and retrieving multiple configurations for a single task."""

    store = DatabasePushNotificationConfigStore(
        engine=db_store_parameterized.engine,
        create_table=False,
        encryption_key=None,  # No encryption key
    )
    await store.initialize()

    task_id = 'task-1'
    config1 = PushNotificationConfig(id='config-1', url='http://example.com/1')
    config2 = PushNotificationConfig(id='config-2', url='http://example.com/2')

    await store.set_info(task_id, config1)
    await store.set_info(task_id, config2)
    retrieved_configs = await store.get_info(task_id)

    assert len(retrieved_configs) == 2
    assert config1 in retrieved_configs
    assert config2 in retrieved_configs


@pytest.mark.asyncio
async def test_data_is_not_encrypted_in_db_if_no_key_is_set(
    db_store_parameterized: DatabasePushNotificationConfigStore,
):
    """Test data is not encrypted when no encryption key is set."""

    store = DatabasePushNotificationConfigStore(
        engine=db_store_parameterized.engine,
        create_table=False,
        encryption_key=None,  # No encryption key
    )
    await store.initialize()

    task_id = 'task-1'
    config = PushNotificationConfig(id='config-1', url='http://example.com/1')
    plain_json = config.model_dump_json()

    await store.set_info(task_id, config)

    # Directly query the database to inspect the raw data
    async_session = async_sessionmaker(
        db_store_parameterized.engine, expire_on_commit=False
    )
    async with async_session() as session:
        stmt = select(PushNotificationConfigModel).where(
            PushNotificationConfigModel.task_id == task_id
        )
        result = await session.execute(stmt)
        db_model = result.scalar_one()

    assert db_model.config_data == plain_json.encode('utf-8')


@pytest.mark.asyncio
async def test_decryption_fallback_for_unencrypted_data(
    db_store_parameterized: DatabasePushNotificationConfigStore,
):
    """Test reading unencrypted data with an encryption-enabled store."""
    # 1. Store unencrypted data using a new store instance without a key
    unencrypted_store = DatabasePushNotificationConfigStore(
        engine=db_store_parameterized.engine,
        create_table=False,  # Table already exists from fixture
        encryption_key=None,
    )
    await unencrypted_store.initialize()

    task_id = 'mixed-encryption-task'
    config = PushNotificationConfig(id='config-1', url='http://plain.url')
    await unencrypted_store.set_info(task_id, config)

    # 2. Try to read with the encryption-enabled store from the fixture
    retrieved_configs = await db_store_parameterized.get_info(task_id)

    # Should fall back to parsing as plain JSON and not fail
    assert len(retrieved_configs) == 1
    assert retrieved_configs[0] == config


@pytest.mark.asyncio
async def test_parsing_error_after_successful_decryption(
    db_store_parameterized: DatabasePushNotificationConfigStore,
):
    """Test that a parsing error after successful decryption is handled."""

    task_id = 'corrupted-data-task'
    config_id = 'config-1'

    # 1. Encrypt data that is NOT valid JSON
    fernet = Fernet(Fernet.generate_key())
    corrupted_payload = b'this is not valid json'
    encrypted_data = fernet.encrypt(corrupted_payload)

    # 2. Manually insert this corrupted data into the DB
    async_session = async_sessionmaker(
        db_store_parameterized.engine, expire_on_commit=False
    )
    async with async_session() as session:
        db_model = PushNotificationConfigModel(
            task_id=task_id,
            config_id=config_id,
            config_data=encrypted_data,
        )
        session.add(db_model)
        await session.commit()

    # 3. get_info should log an error and return an empty list
    retrieved_configs = await db_store_parameterized.get_info(task_id)
    assert retrieved_configs == []

    # 4. _from_orm should raise a ValueError
    async with async_session() as session:
        db_model_retrieved = await session.get(
            PushNotificationConfigModel, (task_id, config_id)
        )

        with pytest.raises(ValueError):
            db_store_parameterized._from_orm(db_model_retrieved)  # type: ignore



---
File: /a2a-python/tests/server/tasks/test_database_task_store.py
---

import os

from collections.abc import AsyncGenerator

import pytest
import pytest_asyncio

from _pytest.mark.structures import ParameterSet


# Skip entire test module if SQLAlchemy is not installed
pytest.importorskip('sqlalchemy', reason='Database tests require SQLAlchemy')

# Now safe to import SQLAlchemy-dependent modules
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy.inspection import inspect

from a2a.server.models import Base, TaskModel  # Important: To get Base.metadata
from a2a.server.tasks.database_task_store import DatabaseTaskStore
from a2a.types import (
    Artifact,
    Message,
    Part,
    Role,
    Task,
    TaskState,
    TaskStatus,
    TextPart,
)


# DSNs for different databases
SQLITE_TEST_DSN = (
    'sqlite+aiosqlite:///file:testdb?mode=memory&cache=shared&uri=true'
)
POSTGRES_TEST_DSN = os.environ.get(
    'POSTGRES_TEST_DSN'
)  # e.g., "postgresql+asyncpg://user:pass@host:port/dbname"
MYSQL_TEST_DSN = os.environ.get(
    'MYSQL_TEST_DSN'
)  # e.g., "mysql+aiomysql://user:pass@host:port/dbname"

# Parameterization for the db_store fixture
DB_CONFIGS: list[ParameterSet | tuple[str | None, str]] = [
    pytest.param((SQLITE_TEST_DSN, 'sqlite'), id='sqlite')
]

if POSTGRES_TEST_DSN:
    DB_CONFIGS.append(
        pytest.param((POSTGRES_TEST_DSN, 'postgresql'), id='postgresql')
    )
else:
    DB_CONFIGS.append(
        pytest.param(
            (None, 'postgresql'),
            marks=pytest.mark.skip(reason='POSTGRES_TEST_DSN not set'),
            id='postgresql_skipped',
        )
    )

if MYSQL_TEST_DSN:
    DB_CONFIGS.append(pytest.param((MYSQL_TEST_DSN, 'mysql'), id='mysql'))
else:
    DB_CONFIGS.append(
        pytest.param(
            (None, 'mysql'),
            marks=pytest.mark.skip(reason='MYSQL_TEST_DSN not set'),
            id='mysql_skipped',
        )
    )


# Minimal Task object for testing - remains the same
task_status_submitted = TaskStatus(
    state=TaskState.submitted, timestamp='2023-01-01T00:00:00Z'
)
MINIMAL_TASK_OBJ = Task(
    id='task-abc',
    context_id='session-xyz',
    status=task_status_submitted,
    kind='task',
    metadata={'test_key': 'test_value'},
    artifacts=[],
    history=[],
)


@pytest_asyncio.fixture(params=DB_CONFIGS)
async def db_store_parameterized(
    request,
) -> AsyncGenerator[DatabaseTaskStore, None]:
    """
    Fixture that provides a DatabaseTaskStore connected to different databases
    based on parameterization (SQLite, PostgreSQL, MySQL).
    """
    db_url, dialect_name = request.param

    if db_url is None:
        pytest.skip(f'DSN for {dialect_name} not set in environment variables.')

    engine = create_async_engine(db_url)
    store = None  # Initialize store to None for the finally block

    try:
        # Create tables
        async with engine.begin() as conn:
            await conn.run_sync(Base.metadata.create_all)

        # create_table=False as we've explicitly created tables above.
        store = DatabaseTaskStore(engine=engine, create_table=False)
        # Initialize the store (connects, etc.). Safe to call even if tables exist.
        await store.initialize()

        yield store

    finally:
        if engine:  # If engine was created for setup/teardown
            # Drop tables using the fixture's engine
            async with engine.begin() as conn:
                await conn.run_sync(Base.metadata.drop_all)
            await engine.dispose()  # Dispose the engine created in the fixture


@pytest.mark.asyncio
async def test_initialize_creates_table(
    db_store_parameterized: DatabaseTaskStore,
) -> None:
    """Test that tables are created (implicitly by fixture setup)."""
    # Ensure store is initialized (already done by fixture, but good for clarity)
    await db_store_parameterized._ensure_initialized()

    # Use the store's engine for inspection
    async with db_store_parameterized.engine.connect() as conn:

        def has_table_sync(sync_conn):
            inspector = inspect(sync_conn)
            return inspector.has_table(TaskModel.__tablename__)

        assert await conn.run_sync(has_table_sync)


@pytest.mark.asyncio
async def test_save_task(db_store_parameterized: DatabaseTaskStore) -> None:
    """Test saving a task to the DatabaseTaskStore."""
    task_to_save = MINIMAL_TASK_OBJ.model_copy(deep=True)
    # Ensure unique ID for parameterized tests if needed, or rely on table isolation
    task_to_save.id = (
        f'save-task-{db_store_parameterized.engine.url.drivername}'
    )
    await db_store_parameterized.save(task_to_save)

    retrieved_task = await db_store_parameterized.get(task_to_save.id)
    assert retrieved_task is not None
    assert retrieved_task.id == task_to_save.id
    assert retrieved_task.model_dump() == task_to_save.model_dump()
    await db_store_parameterized.delete(task_to_save.id)  # Cleanup


@pytest.mark.asyncio
async def test_get_task(db_store_parameterized: DatabaseTaskStore) -> None:
    """Test retrieving a task from the DatabaseTaskStore."""
    task_id = f'get-test-task-{db_store_parameterized.engine.url.drivername}'
    task_to_save = MINIMAL_TASK_OBJ.model_copy(update={'id': task_id})
    await db_store_parameterized.save(task_to_save)

    retrieved_task = await db_store_parameterized.get(task_to_save.id)
    assert retrieved_task is not None
    assert retrieved_task.id == task_to_save.id
    assert retrieved_task.context_id == task_to_save.context_id
    assert retrieved_task.status.state == TaskState.submitted
    await db_store_parameterized.delete(task_to_save.id)  # Cleanup


@pytest.mark.asyncio
async def test_get_nonexistent_task(
    db_store_parameterized: DatabaseTaskStore,
) -> None:
    """Test retrieving a nonexistent task."""
    retrieved_task = await db_store_parameterized.get('nonexistent-task-id')
    assert retrieved_task is None


@pytest.mark.asyncio
async def test_delete_task(db_store_parameterized: DatabaseTaskStore) -> None:
    """Test deleting a task from the DatabaseTaskStore."""
    task_id = f'delete-test-task-{db_store_parameterized.engine.url.drivername}'
    task_to_save_and_delete = MINIMAL_TASK_OBJ.model_copy(
        update={'id': task_id}
    )
    await db_store_parameterized.save(task_to_save_and_delete)

    assert (
        await db_store_parameterized.get(task_to_save_and_delete.id) is not None
    )
    await db_store_parameterized.delete(task_to_save_and_delete.id)
    assert await db_store_parameterized.get(task_to_save_and_delete.id) is None


@pytest.mark.asyncio
async def test_delete_nonexistent_task(
    db_store_parameterized: DatabaseTaskStore,
) -> None:
    """Test deleting a nonexistent task. Should not error."""
    await db_store_parameterized.delete('nonexistent-delete-task-id')


@pytest.mark.asyncio
async def test_save_and_get_detailed_task(
    db_store_parameterized: DatabaseTaskStore,
) -> None:
    """Test saving and retrieving a task with more fields populated."""
    task_id = f'detailed-task-{db_store_parameterized.engine.url.drivername}'
    test_task = Task(
        id=task_id,
        context_id='test-session-1',
        status=TaskStatus(
            state=TaskState.working, timestamp='2023-01-01T12:00:00Z'
        ),
        kind='task',
        metadata={'key1': 'value1', 'key2': 123},
        artifacts=[
            Artifact(
                artifact_id='artifact-1',
                parts=[Part(root=TextPart(text='hello'))],
            )
        ],
        history=[
            Message(
                message_id='msg-1',
                role=Role.user,
                parts=[Part(root=TextPart(text='user input'))],
            )
        ],
    )

    await db_store_parameterized.save(test_task)
    retrieved_task = await db_store_parameterized.get(test_task.id)

    assert retrieved_task is not None
    assert retrieved_task.id == test_task.id
    assert retrieved_task.context_id == test_task.context_id
    assert retrieved_task.status.state == TaskState.working
    assert retrieved_task.status.timestamp == '2023-01-01T12:00:00Z'
    assert retrieved_task.metadata == {'key1': 'value1', 'key2': 123}

    # Pydantic models handle their own serialization for comparison if model_dump is used
    assert (
        retrieved_task.model_dump()['artifacts']
        == test_task.model_dump()['artifacts']
    )
    assert (
        retrieved_task.model_dump()['history']
        == test_task.model_dump()['history']
    )

    await db_store_parameterized.delete(test_task.id)
    assert await db_store_parameterized.get(test_task.id) is None


@pytest.mark.asyncio
async def test_update_task(db_store_parameterized: DatabaseTaskStore) -> None:
    """Test updating an existing task."""
    task_id = f'update-test-task-{db_store_parameterized.engine.url.drivername}'
    original_task = Task(
        id=task_id,
        context_id='session-update',
        status=TaskStatus(
            state=TaskState.submitted, timestamp='2023-01-02T10:00:00Z'
        ),
        kind='task',
        metadata=None,  # Explicitly None
        artifacts=[],
        history=[],
    )
    await db_store_parameterized.save(original_task)

    retrieved_before_update = await db_store_parameterized.get(task_id)
    assert retrieved_before_update is not None
    assert retrieved_before_update.status.state == TaskState.submitted
    assert retrieved_before_update.metadata is None

    updated_task = original_task.model_copy(deep=True)
    updated_task.status.state = TaskState.completed
    updated_task.status.timestamp = '2023-01-02T11:00:00Z'
    updated_task.metadata = {'update_key': 'update_value'}

    await db_store_parameterized.save(updated_task)

    retrieved_after_update = await db_store_parameterized.get(task_id)
    assert retrieved_after_update is not None
    assert retrieved_after_update.status.state == TaskState.completed
    assert retrieved_after_update.metadata == {'update_key': 'update_value'}

    await db_store_parameterized.delete(task_id)


@pytest.mark.asyncio
async def test_metadata_field_mapping(
    db_store_parameterized: DatabaseTaskStore,
) -> None:
    """Test that metadata field is correctly mapped between Pydantic and SQLAlchemy.

    This test verifies:
    1. Metadata can be None
    2. Metadata can be a simple dict
    3. Metadata can contain nested structures
    4. Metadata is correctly saved and retrieved
    5. The mapping between task.metadata and task_metadata column works
    """
    # Test 1: Task with no metadata (None)
    task_no_metadata = Task(
        id='task-metadata-test-1',
        context_id='session-meta-1',
        status=TaskStatus(state=TaskState.submitted),
        kind='task',
        metadata=None,
    )
    await db_store_parameterized.save(task_no_metadata)
    retrieved_no_metadata = await db_store_parameterized.get(
        'task-metadata-test-1'
    )
    assert retrieved_no_metadata is not None
    assert retrieved_no_metadata.metadata is None

    # Test 2: Task with simple metadata
    simple_metadata = {'key': 'value', 'number': 42, 'boolean': True}
    task_simple_metadata = Task(
        id='task-metadata-test-2',
        context_id='session-meta-2',
        status=TaskStatus(state=TaskState.working),
        kind='task',
        metadata=simple_metadata,
    )
    await db_store_parameterized.save(task_simple_metadata)
    retrieved_simple = await db_store_parameterized.get('task-metadata-test-2')
    assert retrieved_simple is not None
    assert retrieved_simple.metadata == simple_metadata

    # Test 3: Task with complex nested metadata
    complex_metadata = {
        'level1': {
            'level2': {
                'level3': ['a', 'b', 'c'],
                'numeric': 3.14159,
            },
            'array': [1, 2, {'nested': 'value'}],
        },
        'special_chars': 'Hello\nWorld\t!',
        'unicode': '🚀 Unicode test 你好',
        'null_value': None,
    }
    task_complex_metadata = Task(
        id='task-metadata-test-3',
        context_id='session-meta-3',
        status=TaskStatus(state=TaskState.completed),
        kind='task',
        metadata=complex_metadata,
    )
    await db_store_parameterized.save(task_complex_metadata)
    retrieved_complex = await db_store_parameterized.get('task-metadata-test-3')
    assert retrieved_complex is not None
    assert retrieved_complex.metadata == complex_metadata

    # Test 4: Update metadata from None to dict
    task_update_metadata = Task(
        id='task-metadata-test-4',
        context_id='session-meta-4',
        status=TaskStatus(state=TaskState.submitted),
        kind='task',
        metadata=None,
    )
    await db_store_parameterized.save(task_update_metadata)

    # Update metadata
    task_update_metadata.metadata = {'updated': True, 'timestamp': '2024-01-01'}
    await db_store_parameterized.save(task_update_metadata)

    retrieved_updated = await db_store_parameterized.get('task-metadata-test-4')
    assert retrieved_updated is not None
    assert retrieved_updated.metadata == {
        'updated': True,
        'timestamp': '2024-01-01',
    }

    # Test 5: Update metadata from dict to None
    task_update_metadata.metadata = None
    await db_store_parameterized.save(task_update_metadata)

    retrieved_none = await db_store_parameterized.get('task-metadata-test-4')
    assert retrieved_none is not None
    assert retrieved_none.metadata is None

    # Cleanup
    await db_store_parameterized.delete('task-metadata-test-1')
    await db_store_parameterized.delete('task-metadata-test-2')
    await db_store_parameterized.delete('task-metadata-test-3')
    await db_store_parameterized.delete('task-metadata-test-4')


# Ensure aiosqlite, asyncpg, and aiomysql are installed in the test environment (added to pyproject.toml).



---
File: /a2a-python/tests/server/tasks/test_inmemory_push_notifications.py
---

import unittest

from unittest.mock import AsyncMock, MagicMock, patch

import httpx

from a2a.server.tasks.base_push_notification_sender import (
    BasePushNotificationSender,
)
from a2a.server.tasks.inmemory_push_notification_config_store import (
    InMemoryPushNotificationConfigStore,
)
from a2a.types import PushNotificationConfig, Task, TaskState, TaskStatus


# Suppress logging for cleaner test output, can be enabled for debugging
# logging.disable(logging.CRITICAL)


def create_sample_task(task_id='task123', status_state=TaskState.completed):
    return Task(
        id=task_id,
        context_id='ctx456',
        status=TaskStatus(state=status_state),
    )


def create_sample_push_config(
    url='http://example.com/callback', config_id='cfg1', token=None
):
    return PushNotificationConfig(id=config_id, url=url, token=token)


class TestInMemoryPushNotifier(unittest.IsolatedAsyncioTestCase):
    def setUp(self):
        self.mock_httpx_client = AsyncMock(spec=httpx.AsyncClient)
        self.config_store = InMemoryPushNotificationConfigStore()
        self.notifier = BasePushNotificationSender(
            httpx_client=self.mock_httpx_client, config_store=self.config_store
        )  # Corrected argument name

    def test_constructor_stores_client(self):
        self.assertEqual(self.notifier._client, self.mock_httpx_client)

    async def test_set_info_adds_new_config(self):
        task_id = 'task_new'
        config = create_sample_push_config(url='http://new.url/callback')

        await self.config_store.set_info(task_id, config)

        self.assertIn(task_id, self.config_store._push_notification_infos)
        self.assertEqual(
            self.config_store._push_notification_infos[task_id], [config]
        )

    async def test_set_info_appends_to_existing_config(self):
        task_id = 'task_update'
        initial_config = create_sample_push_config(
            url='http://initial.url/callback', config_id='cfg_initial'
        )
        await self.config_store.set_info(task_id, initial_config)

        updated_config = create_sample_push_config(
            url='http://updated.url/callback', config_id='cfg_updated'
        )
        await self.config_store.set_info(task_id, updated_config)

        self.assertIn(task_id, self.config_store._push_notification_infos)
        self.assertEqual(
            self.config_store._push_notification_infos[task_id][0],
            initial_config,
        )
        self.assertEqual(
            self.config_store._push_notification_infos[task_id][1],
            updated_config,
        )

    async def test_set_info_without_config_id(self):
        task_id = 'task1'
        initial_config = PushNotificationConfig(
            url='http://initial.url/callback'
        )
        await self.config_store.set_info(task_id, initial_config)

        assert (
            self.config_store._push_notification_infos[task_id][0].id == task_id
        )

        updated_config = PushNotificationConfig(
            url='http://initial.url/callback_new'
        )
        await self.config_store.set_info(task_id, updated_config)

        self.assertIn(task_id, self.config_store._push_notification_infos)
        assert len(self.config_store._push_notification_infos[task_id]) == 1
        self.assertEqual(
            self.config_store._push_notification_infos[task_id][0].url,
            updated_config.url,
        )

    async def test_get_info_existing_config(self):
        task_id = 'task_get_exist'
        config = create_sample_push_config(url='http://get.this/callback')
        await self.config_store.set_info(task_id, config)

        retrieved_config = await self.config_store.get_info(task_id)
        self.assertEqual(retrieved_config, [config])

    async def test_get_info_non_existent_config(self):
        task_id = 'task_get_non_exist'
        retrieved_config = await self.config_store.get_info(task_id)
        assert retrieved_config == []

    async def test_delete_info_existing_config(self):
        task_id = 'task_delete_exist'
        config = create_sample_push_config(url='http://delete.this/callback')
        await self.config_store.set_info(task_id, config)

        self.assertIn(task_id, self.config_store._push_notification_infos)
        await self.config_store.delete_info(task_id, config_id=config.id)
        self.assertNotIn(task_id, self.config_store._push_notification_infos)

    async def test_delete_info_non_existent_config(self):
        task_id = 'task_delete_non_exist'
        # Ensure it doesn't raise an error
        try:
            await self.config_store.delete_info(task_id)
        except Exception as e:
            self.fail(
                f'delete_info raised {e} unexpectedly for nonexistent task_id'
            )
        self.assertNotIn(
            task_id, self.config_store._push_notification_infos
        )  # Should still not be there

    async def test_send_notification_success(self):
        task_id = 'task_send_success'
        task_data = create_sample_task(task_id=task_id)
        config = create_sample_push_config(url='http://notify.me/here')
        await self.config_store.set_info(task_id, config)

        # Mock the post call to simulate success
        mock_response = AsyncMock(spec=httpx.Response)
        mock_response.status_code = 200
        self.mock_httpx_client.post.return_value = mock_response

        await self.notifier.send_notification(task_data)  # Pass only task_data

        self.mock_httpx_client.post.assert_awaited_once()
        called_args, called_kwargs = self.mock_httpx_client.post.call_args
        self.assertEqual(called_args[0], config.url)
        self.assertEqual(
            called_kwargs['json'],
            task_data.model_dump(mode='json', exclude_none=True),
        )
        self.assertNotIn(
            'auth', called_kwargs
        )  # auth is not passed by current implementation
        mock_response.raise_for_status.assert_called_once()

    async def test_send_notification_with_token_success(self):
        task_id = 'task_send_success'
        task_data = create_sample_task(task_id=task_id)
        config = create_sample_push_config(
            url='http://notify.me/here', token='unique_token'
        )
        await self.config_store.set_info(task_id, config)

        # Mock the post call to simulate success
        mock_response = AsyncMock(spec=httpx.Response)
        mock_response.status_code = 200
        self.mock_httpx_client.post.return_value = mock_response

        await self.notifier.send_notification(task_data)  # Pass only task_data

        self.mock_httpx_client.post.assert_awaited_once()
        called_args, called_kwargs = self.mock_httpx_client.post.call_args
        self.assertEqual(called_args[0], config.url)
        self.assertEqual(
            called_kwargs['json'],
            task_data.model_dump(mode='json', exclude_none=True),
        )
        self.assertEqual(
            called_kwargs['headers'],
            {'X-A2A-Notification-Token': 'unique_token'},
        )
        self.assertNotIn(
            'auth', called_kwargs
        )  # auth is not passed by current implementation
        mock_response.raise_for_status.assert_called_once()

    async def test_send_notification_no_config(self):
        task_id = 'task_send_no_config'
        task_data = create_sample_task(task_id=task_id)

        await self.notifier.send_notification(task_data)  # Pass only task_data

        self.mock_httpx_client.post.assert_not_called()

    @patch('a2a.server.tasks.base_push_notification_sender.logger')
    async def test_send_notification_http_status_error(
        self, mock_logger: MagicMock
    ):
        task_id = 'task_send_http_err'
        task_data = create_sample_task(task_id=task_id)
        config = create_sample_push_config(url='http://notify.me/http_error')
        await self.config_store.set_info(task_id, config)

        mock_response = MagicMock(
            spec=httpx.Response
        )  # Use MagicMock for status_code attribute
        mock_response.status_code = 404
        mock_response.text = 'Not Found'
        http_error = httpx.HTTPStatusError(
            'Not Found', request=MagicMock(), response=mock_response
        )
        self.mock_httpx_client.post.side_effect = http_error

        # The method should catch the error and log it, not re-raise
        await self.notifier.send_notification(task_data)  # Pass only task_data

        self.mock_httpx_client.post.assert_awaited_once()
        mock_logger.exception.assert_called_once()
        # Check that the error message contains the generic part and the specific exception string
        self.assertIn(
            'Error sending push-notification',
            mock_logger.exception.call_args[0][0],
        )

    @patch('a2a.server.tasks.base_push_notification_sender.logger')
    async def test_send_notification_request_error(
        self, mock_logger: MagicMock
    ):
        task_id = 'task_send_req_err'
        task_data = create_sample_task(task_id=task_id)
        config = create_sample_push_config(url='http://notify.me/req_error')
        await self.config_store.set_info(task_id, config)

        request_error = httpx.RequestError('Network issue', request=MagicMock())
        self.mock_httpx_client.post.side_effect = request_error

        await self.notifier.send_notification(task_data)  # Pass only task_data

        self.mock_httpx_client.post.assert_awaited_once()
        mock_logger.exception.assert_called_once()
        self.assertIn(
            'Error sending push-notification',
            mock_logger.exception.call_args[0][0],
        )

    @patch('a2a.server.tasks.base_push_notification_sender.logger')
    async def test_send_notification_with_auth(self, mock_logger: MagicMock):
        task_id = 'task_send_auth'
        task_data = create_sample_task(task_id=task_id)
        auth_info = ('user', 'pass')
        config = create_sample_push_config(url='http://notify.me/auth')
        config.authentication = MagicMock()  # Mocking the structure for auth
        config.authentication.schemes = ['basic']  # Assume basic for simplicity
        config.authentication.credentials = (
            auth_info  # This might need to be a specific model
        )
        # For now, let's assume it's a tuple for basic auth
        # The actual PushNotificationAuthenticationInfo is more complex
        # For this test, we'll simplify and assume InMemoryPushNotifier
        # directly uses tuple for httpx's `auth` param if basic.
        # A more accurate test would construct the real auth model.
        # Given the current implementation of InMemoryPushNotifier,
        # it only supports basic auth via tuple.

        await self.config_store.set_info(task_id, config)

        mock_response = AsyncMock(spec=httpx.Response)
        mock_response.status_code = 200
        self.mock_httpx_client.post.return_value = mock_response

        await self.notifier.send_notification(task_data)  # Pass only task_data

        self.mock_httpx_client.post.assert_awaited_once()
        called_args, called_kwargs = self.mock_httpx_client.post.call_args
        self.assertEqual(called_args[0], config.url)
        self.assertEqual(
            called_kwargs['json'],
            task_data.model_dump(mode='json', exclude_none=True),
        )
        self.assertNotIn(
            'auth', called_kwargs
        )  # auth is not passed by current implementation
        mock_response.raise_for_status.assert_called_once()


if __name__ == '__main__':
    unittest.main()



---
File: /a2a-python/tests/server/tasks/test_inmemory_task_store.py
---

from typing import Any

import pytest

from a2a.server.tasks import InMemoryTaskStore
from a2a.types import Task


MINIMAL_TASK: dict[str, Any] = {
    'id': 'task-abc',
    'context_id': 'session-xyz',
    'status': {'state': 'submitted'},
    'kind': 'task',
}


@pytest.mark.asyncio
async def test_in_memory_task_store_save_and_get() -> None:
    """Test saving and retrieving a task from the in-memory store."""
    store = InMemoryTaskStore()
    task = Task(**MINIMAL_TASK)
    await store.save(task)
    retrieved_task = await store.get(MINIMAL_TASK['id'])
    assert retrieved_task == task


@pytest.mark.asyncio
async def test_in_memory_task_store_get_nonexistent() -> None:
    """Test retrieving a nonexistent task."""
    store = InMemoryTaskStore()
    retrieved_task = await store.get('nonexistent')
    assert retrieved_task is None


@pytest.mark.asyncio
async def test_in_memory_task_store_delete() -> None:
    """Test deleting a task from the store."""
    store = InMemoryTaskStore()
    task = Task(**MINIMAL_TASK)
    await store.save(task)
    await store.delete(MINIMAL_TASK['id'])
    retrieved_task = await store.get(MINIMAL_TASK['id'])
    assert retrieved_task is None


@pytest.mark.asyncio
async def test_in_memory_task_store_delete_nonexistent() -> None:
    """Test deleting a nonexistent task."""
    store = InMemoryTaskStore()
    await store.delete('nonexistent')



---
File: /a2a-python/tests/server/tasks/test_push_notification_sender.py
---

import unittest

from unittest.mock import AsyncMock, MagicMock, patch

import httpx

from a2a.server.tasks.base_push_notification_sender import (
    BasePushNotificationSender,
)
from a2a.types import (
    PushNotificationConfig,
    Task,
    TaskState,
    TaskStatus,
)


def create_sample_task(task_id='task123', status_state=TaskState.completed):
    return Task(
        id=task_id,
        context_id='ctx456',
        status=TaskStatus(state=status_state),
    )


def create_sample_push_config(
    url='http://example.com/callback', config_id='cfg1', token=None
):
    return PushNotificationConfig(id=config_id, url=url, token=token)


class TestBasePushNotificationSender(unittest.IsolatedAsyncioTestCase):
    def setUp(self):
        self.mock_httpx_client = AsyncMock(spec=httpx.AsyncClient)
        self.mock_config_store = AsyncMock()
        self.sender = BasePushNotificationSender(
            httpx_client=self.mock_httpx_client,
            config_store=self.mock_config_store,
        )

    def test_constructor_stores_client_and_config_store(self):
        self.assertEqual(self.sender._client, self.mock_httpx_client)
        self.assertEqual(self.sender._config_store, self.mock_config_store)

    async def test_send_notification_success(self):
        task_id = 'task_send_success'
        task_data = create_sample_task(task_id=task_id)
        config = create_sample_push_config(url='http://notify.me/here')
        self.mock_config_store.get_info.return_value = [config]

        mock_response = AsyncMock(spec=httpx.Response)
        mock_response.status_code = 200
        self.mock_httpx_client.post.return_value = mock_response

        await self.sender.send_notification(task_data)

        self.mock_config_store.get_info.assert_awaited_once_with

        # assert httpx_client post method got invoked with right parameters
        self.mock_httpx_client.post.assert_awaited_once_with(
            config.url,
            json=task_data.model_dump(mode='json', exclude_none=True),
            headers=None,
        )
        mock_response.raise_for_status.assert_called_once()

    async def test_send_notification_with_token_success(self):
        task_id = 'task_send_success'
        task_data = create_sample_task(task_id=task_id)
        config = create_sample_push_config(
            url='http://notify.me/here', token='unique_token'
        )
        self.mock_config_store.get_info.return_value = [config]

        mock_response = AsyncMock(spec=httpx.Response)
        mock_response.status_code = 200
        self.mock_httpx_client.post.return_value = mock_response

        await self.sender.send_notification(task_data)

        self.mock_config_store.get_info.assert_awaited_once_with

        # assert httpx_client post method got invoked with right parameters
        self.mock_httpx_client.post.assert_awaited_once_with(
            config.url,
            json=task_data.model_dump(mode='json', exclude_none=True),
            headers={'X-A2A-Notification-Token': 'unique_token'},
        )
        mock_response.raise_for_status.assert_called_once()

    async def test_send_notification_no_config(self):
        task_id = 'task_send_no_config'
        task_data = create_sample_task(task_id=task_id)
        self.mock_config_store.get_info.return_value = []

        await self.sender.send_notification(task_data)

        self.mock_config_store.get_info.assert_awaited_once_with(task_id)
        self.mock_httpx_client.post.assert_not_called()

    @patch('a2a.server.tasks.base_push_notification_sender.logger')
    async def test_send_notification_http_status_error(
        self, mock_logger: MagicMock
    ):
        task_id = 'task_send_http_err'
        task_data = create_sample_task(task_id=task_id)
        config = create_sample_push_config(url='http://notify.me/http_error')
        self.mock_config_store.get_info.return_value = [config]

        mock_response = MagicMock(spec=httpx.Response)
        mock_response.status_code = 404
        mock_response.text = 'Not Found'
        http_error = httpx.HTTPStatusError(
            'Not Found', request=MagicMock(), response=mock_response
        )
        self.mock_httpx_client.post.side_effect = http_error

        await self.sender.send_notification(task_data)

        self.mock_config_store.get_info.assert_awaited_once_with(task_id)
        self.mock_httpx_client.post.assert_awaited_once_with(
            config.url,
            json=task_data.model_dump(mode='json', exclude_none=True),
            headers=None,
        )
        mock_logger.exception.assert_called_once()

    async def test_send_notification_multiple_configs(self):
        task_id = 'task_multiple_configs'
        task_data = create_sample_task(task_id=task_id)
        config1 = create_sample_push_config(
            url='http://notify.me/cfg1', config_id='cfg1'
        )
        config2 = create_sample_push_config(
            url='http://notify.me/cfg2', config_id='cfg2'
        )
        self.mock_config_store.get_info.return_value = [config1, config2]

        mock_response = AsyncMock(spec=httpx.Response)
        mock_response.status_code = 200
        self.mock_httpx_client.post.return_value = mock_response

        await self.sender.send_notification(task_data)

        self.mock_config_store.get_info.assert_awaited_once_with(task_id)
        self.assertEqual(self.mock_httpx_client.post.call_count, 2)

        # Check calls for config1
        self.mock_httpx_client.post.assert_any_call(
            config1.url,
            json=task_data.model_dump(mode='json', exclude_none=True),
            headers=None,
        )
        # Check calls for config2
        self.mock_httpx_client.post.assert_any_call(
            config2.url,
            json=task_data.model_dump(mode='json', exclude_none=True),
            headers=None,
        )
        mock_response.raise_for_status.call_count = 2



---
File: /a2a-python/tests/server/tasks/test_result_aggregator.py
---

import asyncio
import unittest

from collections.abc import AsyncIterator
from unittest.mock import AsyncMock, MagicMock, patch

from a2a.server.events.event_consumer import EventConsumer
from a2a.server.tasks.result_aggregator import ResultAggregator
from a2a.server.tasks.task_manager import TaskManager
from a2a.types import (
    Message,
    Part,
    Role,
    Task,
    TaskState,
    TaskStatus,
    TaskStatusUpdateEvent,
    TextPart,
)


# Helper to create a simple message
def create_sample_message(
    content='test message', msg_id='msg1', role=Role.user
):
    return Message(
        message_id=msg_id,
        role=role,
        parts=[Part(root=TextPart(text=content))],
    )


# Helper to create a simple task
def create_sample_task(
    task_id='task1', status_state=TaskState.submitted, context_id='ctx1'
):
    return Task(
        id=task_id,
        context_id=context_id,
        status=TaskStatus(state=status_state),
    )


# Helper to create a TaskStatusUpdateEvent
def create_sample_status_update(
    task_id='task1', status_state=TaskState.working, context_id='ctx1'
):
    return TaskStatusUpdateEvent(
        task_id=task_id,
        context_id=context_id,
        status=TaskStatus(state=status_state),
        final=False,  # Typically false unless it's the very last update
    )


class TestResultAggregator(unittest.IsolatedAsyncioTestCase):
    def setUp(self):
        self.mock_task_manager = AsyncMock(spec=TaskManager)
        self.mock_event_consumer = AsyncMock(spec=EventConsumer)
        self.aggregator = ResultAggregator(
            task_manager=self.mock_task_manager
            # event_consumer is not passed to constructor
        )

    def test_init_stores_task_manager(self):
        self.assertEqual(self.aggregator.task_manager, self.mock_task_manager)
        # event_consumer is also stored, can be tested if needed, but focus is on task_manager per req.

    async def test_current_result_property_with_message_set(self):
        sample_message = create_sample_message(content='hola')
        self.aggregator._message = sample_message
        self.assertEqual(await self.aggregator.current_result, sample_message)
        self.mock_task_manager.get_task.assert_not_called()

    async def test_current_result_property_with_message_none(self):
        expected_task = create_sample_task(task_id='task_from_tm')
        self.mock_task_manager.get_task.return_value = expected_task
        self.aggregator._message = None

        current_res = await self.aggregator.current_result

        self.assertEqual(current_res, expected_task)
        self.mock_task_manager.get_task.assert_called_once()

    async def test_consume_and_emit(self):
        event1 = create_sample_message(content='event one', msg_id='e1')
        event2 = create_sample_task(
            task_id='task_event', status_state=TaskState.working
        )
        event3 = create_sample_status_update(
            task_id='task_event', status_state=TaskState.completed
        )

        # Mock event_consumer.consume() to be an async generator
        async def mock_consume_generator():
            yield event1
            yield event2
            yield event3

        self.mock_event_consumer.consume_all.return_value = (
            mock_consume_generator()
        )

        # To store yielded events
        yielded_events = []
        async for event in self.aggregator.consume_and_emit(
            self.mock_event_consumer
        ):
            yielded_events.append(event)

        # Assert that all events were yielded
        self.assertEqual(len(yielded_events), 3)
        self.assertIn(event1, yielded_events)
        self.assertIn(event2, yielded_events)
        self.assertIn(event3, yielded_events)

        # Assert that task_manager.process was called for each event
        self.assertEqual(self.mock_task_manager.process.call_count, 3)
        self.mock_task_manager.process.assert_any_call(event1)
        self.mock_task_manager.process.assert_any_call(event2)
        self.mock_task_manager.process.assert_any_call(event3)

    async def test_consume_all_only_message_event(self):
        sample_message = create_sample_message(content='final message')

        async def mock_consume_generator():
            yield sample_message

        self.mock_event_consumer.consume_all.return_value = (
            mock_consume_generator()
        )

        result = await self.aggregator.consume_all(self.mock_event_consumer)

        self.assertEqual(result, sample_message)
        self.mock_task_manager.process.assert_not_called()  # Process is not called if message is returned directly
        self.mock_task_manager.get_task.assert_not_called()  # Should not be called if message is returned

    async def test_consume_all_other_event_types(self):
        task_event = create_sample_task(task_id='task_other_event')
        status_update_event = create_sample_status_update(
            task_id='task_other_event', status_state=TaskState.completed
        )
        final_task_state = create_sample_task(
            task_id='task_other_event', status_state=TaskState.completed
        )

        async def mock_consume_generator():
            yield task_event
            yield status_update_event

        self.mock_event_consumer.consume_all.return_value = (
            mock_consume_generator()
        )
        self.mock_task_manager.get_task.return_value = final_task_state

        result = await self.aggregator.consume_all(self.mock_event_consumer)

        self.assertEqual(result, final_task_state)
        self.assertEqual(self.mock_task_manager.process.call_count, 2)
        self.mock_task_manager.process.assert_any_call(task_event)
        self.mock_task_manager.process.assert_any_call(status_update_event)
        self.mock_task_manager.get_task.assert_called_once()

    async def test_consume_all_empty_stream(self):
        empty_task_state = create_sample_task(task_id='empty_stream_task')

        async def mock_consume_generator():
            if False:  # Will not yield anything
                yield

        self.mock_event_consumer.consume_all.return_value = (
            mock_consume_generator()
        )
        self.mock_task_manager.get_task.return_value = empty_task_state

        result = await self.aggregator.consume_all(self.mock_event_consumer)

        self.assertEqual(result, empty_task_state)
        self.mock_task_manager.process.assert_not_called()
        self.mock_task_manager.get_task.assert_called_once()

    async def test_consume_all_event_consumer_exception(self):
        class TestException(Exception):
            pass

        self.mock_event_consumer.consume_all = (
            AsyncMock()
        )  # Re-mock to make it an async generator that raises

        async def raiser_gen():
            # Yield a non-Message event first to ensure process is called
            yield create_sample_task('task_before_error_consume_all')
            raise TestException('Consumer error')

        self.mock_event_consumer.consume_all = MagicMock(
            return_value=raiser_gen()
        )

        with self.assertRaises(TestException):
            await self.aggregator.consume_all(self.mock_event_consumer)

        # Ensure process was called for the event before the exception
        self.mock_task_manager.process.assert_called_once_with(
            unittest.mock.ANY  # Check it was called, arg is the task
        )
        self.mock_task_manager.get_task.assert_not_called()

    async def test_consume_and_break_on_message(self):
        sample_message = create_sample_message(content='interrupt message')
        event_after = create_sample_task('task_after_msg')

        async def mock_consume_generator():
            yield sample_message
            yield event_after  # This should not be processed by task_manager in this call

        self.mock_event_consumer.consume_all.return_value = (
            mock_consume_generator()
        )

        (
            result,
            interrupted,
        ) = await self.aggregator.consume_and_break_on_interrupt(
            self.mock_event_consumer
        )

        self.assertEqual(result, sample_message)
        self.assertFalse(interrupted)
        self.mock_task_manager.process.assert_not_called()  # Process is not called for the Message if returned directly
        # _continue_consuming should not be called if it's a message interrupt
        # and no auth_required state.

    @patch('asyncio.create_task')
    async def test_consume_and_break_on_auth_required_task_event(
        self, mock_create_task: MagicMock
    ):
        auth_task = create_sample_task(
            task_id='auth_task', status_state=TaskState.auth_required
        )
        event_after_auth = create_sample_message('after auth')

        async def mock_consume_generator():
            yield auth_task
            yield event_after_auth  # This event will be handled by _continue_consuming

        self.mock_event_consumer.consume_all.return_value = (
            mock_consume_generator()
        )
        self.mock_task_manager.get_task.return_value = (
            auth_task  # current_result after auth_task processing
        )

        # Mock _continue_consuming to check if it's called by create_task
        self.aggregator._continue_consuming = AsyncMock()
        mock_create_task.side_effect = lambda coro: asyncio.ensure_future(coro)

        (
            result,
            interrupted,
        ) = await self.aggregator.consume_and_break_on_interrupt(
            self.mock_event_consumer
        )

        self.assertEqual(result, auth_task)
        self.assertTrue(interrupted)
        self.mock_task_manager.process.assert_called_once_with(auth_task)
        mock_create_task.assert_called_once()  # Check that create_task was called
        # self.aggregator._continue_consuming is an AsyncMock.
        # The actual call in product code is create_task(self._continue_consuming(event_stream_arg))
        # So, we check that our mock _continue_consuming was called with an AsyncIterator arg.
        self.aggregator._continue_consuming.assert_called_once()
        self.assertIsInstance(
            self.aggregator._continue_consuming.call_args[0][0], AsyncIterator
        )

        # Manually run the mocked _continue_consuming to check its behavior
        # This requires the generator to be re-setup or passed if stateful.
        # For simplicity, let's assume _continue_consuming uses the same generator instance.
        # In a real scenario, the generator's state would be an issue.
        # However, ResultAggregator re-assigns self.mock_event_consumer.consume()
        # to self.aggregator._event_stream in the actual code.
        # The test setup for _continue_consuming needs to be more robust if we want to test its internal loop.
        # For now, we've verified it's called.

    @patch('asyncio.create_task')
    async def test_consume_and_break_on_auth_required_status_update_event(
        self, mock_create_task: MagicMock
    ):
        auth_status_update = create_sample_status_update(
            task_id='auth_status_task', status_state=TaskState.auth_required
        )
        current_task_state_after_update = create_sample_task(
            task_id='auth_status_task', status_state=TaskState.auth_required
        )

        async def mock_consume_generator():
            yield auth_status_update

        self.mock_event_consumer.consume_all.return_value = (
            mock_consume_generator()
        )
        # When current_result is called after processing auth_status_update
        self.mock_task_manager.get_task.return_value = (
            current_task_state_after_update
        )
        self.aggregator._continue_consuming = AsyncMock()
        mock_create_task.side_effect = lambda coro: asyncio.ensure_future(coro)

        (
            result,
            interrupted,
        ) = await self.aggregator.consume_and_break_on_interrupt(
            self.mock_event_consumer
        )

        self.assertEqual(result, current_task_state_after_update)
        self.assertTrue(interrupted)
        self.mock_task_manager.process.assert_called_once_with(
            auth_status_update
        )
        mock_create_task.assert_called_once()
        self.aggregator._continue_consuming.assert_called_once()
        self.assertIsInstance(
            self.aggregator._continue_consuming.call_args[0][0], AsyncIterator
        )

    async def test_consume_and_break_completes_normally(self):
        event1 = create_sample_message('event one normal', msg_id='n1')
        event2 = create_sample_task('normal_task')
        final_task_state = create_sample_task(
            'normal_task', status_state=TaskState.completed
        )

        async def mock_consume_generator():
            yield event1
            yield event2

        self.mock_event_consumer.consume_all.return_value = (
            mock_consume_generator()
        )
        self.mock_task_manager.get_task.return_value = (
            final_task_state  # For the end of stream
        )

        (
            result,
            interrupted,
        ) = await self.aggregator.consume_and_break_on_interrupt(
            self.mock_event_consumer
        )

        # If the first event is a Message, it's returned directly.
        self.assertEqual(result, event1)
        self.assertFalse(interrupted)
        # process() is NOT called for the Message if it's the one causing the return
        self.mock_task_manager.process.assert_not_called()
        self.mock_task_manager.get_task.assert_not_called()

    async def test_consume_and_break_event_consumer_exception(self):
        class TestInterruptException(Exception):
            pass

        self.mock_event_consumer.consume_all = AsyncMock()

        async def raiser_gen_interrupt():
            # Yield a non-Message event first
            yield create_sample_task('task_before_error_interrupt')
            raise TestInterruptException(
                'Consumer error during interrupt check'
            )

        self.mock_event_consumer.consume_all = MagicMock(
            return_value=raiser_gen_interrupt()
        )

        with self.assertRaises(TestInterruptException):
            await self.aggregator.consume_and_break_on_interrupt(
                self.mock_event_consumer
            )

        self.mock_task_manager.process.assert_called_once_with(
            unittest.mock.ANY  # Check it was called, arg is the task
        )
        self.mock_task_manager.get_task.assert_not_called()

    @patch('asyncio.create_task')
    async def test_consume_and_break_non_blocking(
        self, mock_create_task: MagicMock
    ):
        """Test that with blocking=False, the method returns after the first event."""
        first_event = create_sample_task('non_blocking_task')
        event_after = create_sample_message('should be consumed later')

        async def mock_consume_generator():
            yield first_event
            yield event_after

        self.mock_event_consumer.consume_all.return_value = (
            mock_consume_generator()
        )
        # After processing `first_event`, the current result will be that task.
        self.aggregator.task_manager.get_task.return_value = first_event

        self.aggregator._continue_consuming = AsyncMock()
        mock_create_task.side_effect = lambda coro: asyncio.ensure_future(coro)

        (
            result,
            interrupted,
        ) = await self.aggregator.consume_and_break_on_interrupt(
            self.mock_event_consumer, blocking=False
        )

        self.assertEqual(result, first_event)
        self.assertTrue(interrupted)
        self.mock_task_manager.process.assert_called_once_with(first_event)
        mock_create_task.assert_called_once()
        # The background task should be created with the remaining stream
        self.aggregator._continue_consuming.assert_called_once()
        self.assertIsInstance(
            self.aggregator._continue_consuming.call_args[0][0], AsyncIterator
        )

    @patch('asyncio.create_task')  # To verify _continue_consuming is called
    async def test_continue_consuming_processes_remaining_events(
        self, mock_create_task: MagicMock
    ):
        # This test focuses on verifying that if an interrupt occurs,
        # the events *after* the interrupting one are processed by _continue_consuming.

        auth_event = create_sample_task(
            'task_auth_for_continue', status_state=TaskState.auth_required
        )
        event_after_auth1 = create_sample_message(
            'after auth 1', msg_id='cont1'
        )
        event_after_auth2 = create_sample_task('task_after_auth_2')

        # This generator will be iterated first by consume_and_break_on_interrupt,
        # then by _continue_consuming.
        # We need a way to simulate this shared iterator state or provide a new one for _continue_consuming.
        # The actual implementation uses self.aggregator._event_stream

        # Let's simulate the state after consume_and_break_on_interrupt has consumed auth_event
        # and _event_stream is now the rest of the generator.

        # Initial stream for consume_and_break_on_interrupt
        async def initial_consume_generator():
            yield auth_event
            # These should be consumed by _continue_consuming
            yield event_after_auth1
            yield event_after_auth2

        self.mock_event_consumer.consume_all.return_value = (
            initial_consume_generator()
        )
        self.mock_task_manager.get_task.return_value = (
            auth_event  # Task state at interrupt
        )
        mock_create_task.side_effect = lambda coro: asyncio.ensure_future(coro)

        # Call the main method that triggers _continue_consuming via create_task
        _, _ = await self.aggregator.consume_and_break_on_interrupt(
            self.mock_event_consumer
        )

        mock_create_task.assert_called_once()
        # Now, we need to actually execute the coroutine passed to create_task
        # to test the behavior of _continue_consuming
        continue_consuming_coro = mock_create_task.call_args[0][0]

        # Reset process mock to only count calls from _continue_consuming
        self.mock_task_manager.process.reset_mock()

        await continue_consuming_coro

        # Verify process was called for events after the interrupt
        self.assertEqual(self.mock_task_manager.process.call_count, 2)
        self.mock_task_manager.process.assert_any_call(event_after_auth1)
        self.mock_task_manager.process.assert_any_call(event_after_auth2)


if __name__ == '__main__':
    unittest.main()



---
File: /a2a-python/tests/server/tasks/test_task_manager.py
---

from typing import Any
from unittest.mock import AsyncMock

import pytest

from a2a.server.tasks import TaskManager
from a2a.types import (
    Artifact,
    InvalidParamsError,
    Message,
    Part,
    Role,
    Task,
    TaskArtifactUpdateEvent,
    TaskState,
    TaskStatus,
    TaskStatusUpdateEvent,
    TextPart,
)
from a2a.utils.errors import ServerError


MINIMAL_TASK: dict[str, Any] = {
    'id': 'task-abc',
    'context_id': 'session-xyz',
    'status': {'state': 'submitted'},
    'kind': 'task',
}


@pytest.fixture
def mock_task_store() -> AsyncMock:
    """Fixture for a mock TaskStore."""
    return AsyncMock()


@pytest.fixture
def task_manager(mock_task_store: AsyncMock) -> TaskManager:
    """Fixture for a TaskManager with a mock TaskStore."""
    return TaskManager(
        task_id=MINIMAL_TASK['id'],
        context_id=MINIMAL_TASK['context_id'],
        task_store=mock_task_store,
        initial_message=None,
    )


@pytest.mark.parametrize('invalid_task_id', ['', 123])
def test_task_manager_invalid_task_id(
    mock_task_store: AsyncMock, invalid_task_id: Any
):
    """Test that TaskManager raises ValueError for an invalid task_id."""
    with pytest.raises(ValueError, match='Task ID must be a non-empty string'):
        TaskManager(
            task_id=invalid_task_id,
            context_id='test_context',
            task_store=mock_task_store,
            initial_message=None,
        )


@pytest.mark.asyncio
async def test_get_task_existing(
    task_manager: TaskManager, mock_task_store: AsyncMock
) -> None:
    """Test getting an existing task."""
    expected_task = Task(**MINIMAL_TASK)
    mock_task_store.get.return_value = expected_task
    retrieved_task = await task_manager.get_task()
    assert retrieved_task == expected_task
    mock_task_store.get.assert_called_once_with(MINIMAL_TASK['id'])


@pytest.mark.asyncio
async def test_get_task_nonexistent(
    task_manager: TaskManager, mock_task_store: AsyncMock
) -> None:
    """Test getting a nonexistent task."""
    mock_task_store.get.return_value = None
    retrieved_task = await task_manager.get_task()
    assert retrieved_task is None
    mock_task_store.get.assert_called_once_with(MINIMAL_TASK['id'])


@pytest.mark.asyncio
async def test_save_task_event_new_task(
    task_manager: TaskManager, mock_task_store: AsyncMock
) -> None:
    """Test saving a new task."""
    task = Task(**MINIMAL_TASK)
    await task_manager.save_task_event(task)
    mock_task_store.save.assert_called_once_with(task)


@pytest.mark.asyncio
async def test_save_task_event_status_update(
    task_manager: TaskManager, mock_task_store: AsyncMock
) -> None:
    """Test saving a status update for an existing task."""
    initial_task = Task(**MINIMAL_TASK)
    mock_task_store.get.return_value = initial_task
    new_status = TaskStatus(
        state=TaskState.working,
        message=Message(
            role=Role.agent,
            parts=[Part(TextPart(text='content'))],
            message_id='message-id',
        ),
    )
    event = TaskStatusUpdateEvent(
        task_id=MINIMAL_TASK['id'],
        context_id=MINIMAL_TASK['context_id'],
        status=new_status,
        final=False,
    )
    await task_manager.save_task_event(event)
    updated_task = initial_task
    updated_task.status = new_status
    mock_task_store.save.assert_called_once_with(updated_task)


@pytest.mark.asyncio
async def test_save_task_event_artifact_update(
    task_manager: TaskManager, mock_task_store: AsyncMock
) -> None:
    """Test saving an artifact update for an existing task."""
    initial_task = Task(**MINIMAL_TASK)
    mock_task_store.get.return_value = initial_task
    new_artifact = Artifact(
        artifact_id='artifact-id',
        name='artifact1',
        parts=[Part(TextPart(text='content'))],
    )
    event = TaskArtifactUpdateEvent(
        task_id=MINIMAL_TASK['id'],
        context_id=MINIMAL_TASK['context_id'],
        artifact=new_artifact,
    )
    await task_manager.save_task_event(event)
    updated_task = initial_task
    updated_task.artifacts = [new_artifact]
    mock_task_store.save.assert_called_once_with(updated_task)


@pytest.mark.asyncio
async def test_save_task_event_metadata_update(
    task_manager: TaskManager, mock_task_store: AsyncMock
) -> None:
    """Test saving an updated metadata for an existing task."""
    initial_task = Task(**MINIMAL_TASK)
    mock_task_store.get.return_value = initial_task
    new_metadata = {'meta_key_test': 'meta_value_test'}

    event = TaskStatusUpdateEvent(
        task_id=MINIMAL_TASK['id'],
        context_id=MINIMAL_TASK['context_id'],
        metadata=new_metadata,
        status=TaskStatus(state=TaskState.working),
        final=False,
    )
    await task_manager.save_task_event(event)

    updated_task = mock_task_store.save.call_args.args[0]
    assert updated_task.metadata == new_metadata


@pytest.mark.asyncio
async def test_ensure_task_existing(
    task_manager: TaskManager, mock_task_store: AsyncMock
) -> None:
    """Test ensuring an existing task."""
    expected_task = Task(**MINIMAL_TASK)
    mock_task_store.get.return_value = expected_task
    event = TaskStatusUpdateEvent(
        task_id=MINIMAL_TASK['id'],
        context_id=MINIMAL_TASK['context_id'],
        status=TaskStatus(state=TaskState.working),
        final=False,
    )
    retrieved_task = await task_manager.ensure_task(event)
    assert retrieved_task == expected_task
    mock_task_store.get.assert_called_once_with(MINIMAL_TASK['id'])


@pytest.mark.asyncio
async def test_ensure_task_nonexistent(
    mock_task_store: AsyncMock,
) -> None:
    """Test ensuring a nonexistent task (creates a new one)."""
    mock_task_store.get.return_value = None
    task_manager_without_id = TaskManager(
        task_id=None,
        context_id=None,
        task_store=mock_task_store,
        initial_message=None,
    )
    event = TaskStatusUpdateEvent(
        task_id='new-task',
        context_id='some-context',
        status=TaskStatus(state=TaskState.submitted),
        final=False,
    )
    new_task = await task_manager_without_id.ensure_task(event)
    assert new_task.id == 'new-task'
    assert new_task.context_id == 'some-context'
    assert new_task.status.state == TaskState.submitted
    mock_task_store.save.assert_called_once_with(new_task)
    assert task_manager_without_id.task_id == 'new-task'
    assert task_manager_without_id.context_id == 'some-context'


def test_init_task_obj(task_manager: TaskManager) -> None:
    """Test initializing a new task object."""
    new_task = task_manager._init_task_obj('new-task', 'new-context')  # type: ignore
    assert new_task.id == 'new-task'
    assert new_task.context_id == 'new-context'
    assert new_task.status.state == TaskState.submitted
    assert new_task.history == []


@pytest.mark.asyncio
async def test_save_task(
    task_manager: TaskManager, mock_task_store: AsyncMock
) -> None:
    """Test saving a task."""
    task = Task(**MINIMAL_TASK)
    await task_manager._save_task(task)  # type: ignore
    mock_task_store.save.assert_called_once_with(task)


@pytest.mark.asyncio
async def test_save_task_event_mismatched_id_raises_error(
    task_manager: TaskManager,
) -> None:
    """Test that save_task_event raises ServerError on task ID mismatch."""
    # The task_manager is initialized with 'task-abc'
    mismatched_task = Task(
        id='wrong-id',
        context_id='session-xyz',
        status=TaskStatus(state=TaskState.submitted),
    )

    with pytest.raises(ServerError) as exc_info:
        await task_manager.save_task_event(mismatched_task)
    assert isinstance(exc_info.value.error, InvalidParamsError)


@pytest.mark.asyncio
async def test_save_task_event_new_task_no_task_id(
    mock_task_store: AsyncMock,
) -> None:
    """Test saving a task event without task id in TaskManager."""
    task_manager_without_id = TaskManager(
        task_id=None,
        context_id=None,
        task_store=mock_task_store,
        initial_message=None,
    )
    task_data: dict[str, Any] = {
        'id': 'new-task-id',
        'context_id': 'some-context',
        'status': {'state': 'working'},
        'kind': 'task',
    }
    task = Task(**task_data)
    await task_manager_without_id.save_task_event(task)
    mock_task_store.save.assert_called_once_with(task)
    assert task_manager_without_id.task_id == 'new-task-id'
    assert task_manager_without_id.context_id == 'some-context'
    # initial submit should be updated to working
    assert task.status.state == TaskState.working


@pytest.mark.asyncio
async def test_get_task_no_task_id(
    mock_task_store: AsyncMock,
) -> None:
    """Test getting a task when task_id is not set in TaskManager."""
    task_manager_without_id = TaskManager(
        task_id=None,
        context_id='some-context',
        task_store=mock_task_store,
        initial_message=None,
    )
    retrieved_task = await task_manager_without_id.get_task()
    assert retrieved_task is None
    mock_task_store.get.assert_not_called()


@pytest.mark.asyncio
async def test_save_task_event_no_task_existing(
    mock_task_store: AsyncMock,
) -> None:
    """Test saving an event when no task exists and task_id is not set."""
    task_manager_without_id = TaskManager(
        task_id=None,
        context_id=None,
        task_store=mock_task_store,
        initial_message=None,
    )
    mock_task_store.get.return_value = None
    event = TaskStatusUpdateEvent(
        task_id='event-task-id',
        context_id='some-context',
        status=TaskStatus(state=TaskState.completed),
        final=True,
    )
    await task_manager_without_id.save_task_event(event)
    # Check if a new task was created and saved
    call_args = mock_task_store.save.call_args
    assert call_args is not None
    saved_task = call_args[0][0]
    assert saved_task.id == 'event-task-id'
    assert saved_task.context_id == 'some-context'
    assert saved_task.status.state == TaskState.completed
    assert task_manager_without_id.task_id == 'event-task-id'
    assert task_manager_without_id.context_id == 'some-context'



---
File: /a2a-python/tests/server/tasks/test_task_updater.py
---

import asyncio
import uuid

from unittest.mock import AsyncMock, patch

import pytest

from a2a.server.events import EventQueue
from a2a.server.tasks import TaskUpdater
from a2a.types import (
    Message,
    Part,
    Role,
    TaskArtifactUpdateEvent,
    TaskState,
    TaskStatusUpdateEvent,
    TextPart,
)


@pytest.fixture
def event_queue():
    """Create a mock event queue for testing."""
    return AsyncMock(spec=EventQueue)


@pytest.fixture
def task_updater(event_queue):
    """Create a TaskUpdater instance for testing."""
    return TaskUpdater(
        event_queue=event_queue,
        task_id='test-task-id',
        context_id='test-context-id',
    )


@pytest.fixture
def sample_message():
    """Create a sample message for testing."""
    return Message(
        role=Role.agent,
        task_id='test-task-id',
        context_id='test-context-id',
        message_id='test-message-id',
        parts=[Part(root=TextPart(text='Test message'))],
    )


@pytest.fixture
def sample_parts():
    """Create sample parts for testing."""
    return [Part(root=TextPart(text='Test part'))]


def test_init(event_queue):
    """Test that TaskUpdater initializes correctly."""
    task_updater = TaskUpdater(
        event_queue=event_queue,
        task_id='test-task-id',
        context_id='test-context-id',
    )

    assert task_updater.event_queue == event_queue
    assert task_updater.task_id == 'test-task-id'
    assert task_updater.context_id == 'test-context-id'


@pytest.mark.asyncio
async def test_update_status_without_message(task_updater, event_queue):
    """Test updating status without a message."""
    await task_updater.update_status(TaskState.working)

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.task_id == 'test-task-id'
    assert event.context_id == 'test-context-id'
    assert event.final is False
    assert event.status.state == TaskState.working
    assert event.status.message is None


@pytest.mark.asyncio
async def test_update_status_with_message(
    task_updater, event_queue, sample_message
):
    """Test updating status with a message."""
    await task_updater.update_status(TaskState.working, message=sample_message)

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.task_id == 'test-task-id'
    assert event.context_id == 'test-context-id'
    assert event.final is False
    assert event.status.state == TaskState.working
    assert event.status.message == sample_message


@pytest.mark.asyncio
async def test_update_status_final(task_updater, event_queue):
    """Test updating status with final=True."""
    await task_updater.update_status(TaskState.completed, final=True)

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.final is True
    assert event.status.state == TaskState.completed


@pytest.mark.asyncio
async def test_add_artifact_with_custom_id_and_name(
    task_updater, event_queue, sample_parts
):
    """Test adding an artifact with a custom ID and name."""
    await task_updater.add_artifact(
        parts=sample_parts,
        artifact_id='custom-artifact-id',
        name='Custom Artifact',
    )

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskArtifactUpdateEvent)
    assert event.artifact.artifact_id == 'custom-artifact-id'
    assert event.artifact.name == 'Custom Artifact'
    assert event.artifact.parts == sample_parts


@pytest.mark.asyncio
async def test_add_artifact_generates_id(
    task_updater, event_queue, sample_parts
):
    """Test add_artifact generates an ID if artifact_id is None."""
    known_uuid = uuid.UUID('12345678-1234-5678-1234-567812345678')
    with patch('uuid.uuid4', return_value=known_uuid):
        await task_updater.add_artifact(parts=sample_parts, artifact_id=None)

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskArtifactUpdateEvent)
    assert event.artifact.artifact_id == str(known_uuid)
    assert event.artifact.parts == sample_parts
    assert event.append is None
    assert event.last_chunk is None


@pytest.mark.asyncio
@pytest.mark.parametrize(
    'append_val, last_chunk_val',
    [
        (False, False),
        (True, True),
        (True, False),
        (False, True),
    ],
)
async def test_add_artifact_with_append_last_chunk(
    task_updater, event_queue, sample_parts, append_val, last_chunk_val
):
    """Test add_artifact with append and last_chunk flags."""
    await task_updater.add_artifact(
        parts=sample_parts,
        artifact_id='id1',
        append=append_val,
        last_chunk=last_chunk_val,
    )

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskArtifactUpdateEvent)
    assert event.artifact.artifact_id == 'id1'
    assert event.artifact.parts == sample_parts
    assert event.append == append_val
    assert event.last_chunk == last_chunk_val


@pytest.mark.asyncio
async def test_complete_without_message(task_updater, event_queue):
    """Test marking a task as completed without a message."""
    await task_updater.complete()

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.completed
    assert event.final is True
    assert event.status.message is None


@pytest.mark.asyncio
async def test_complete_with_message(task_updater, event_queue, sample_message):
    """Test marking a task as completed with a message."""
    await task_updater.complete(message=sample_message)

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.completed
    assert event.final is True
    assert event.status.message == sample_message


@pytest.mark.asyncio
async def test_submit_without_message(task_updater, event_queue):
    """Test marking a task as submitted without a message."""
    await task_updater.submit()

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.submitted
    assert event.final is False
    assert event.status.message is None


@pytest.mark.asyncio
async def test_submit_with_message(task_updater, event_queue, sample_message):
    """Test marking a task as submitted with a message."""
    await task_updater.submit(message=sample_message)

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.submitted
    assert event.final is False
    assert event.status.message == sample_message


@pytest.mark.asyncio
async def test_start_work_without_message(task_updater, event_queue):
    """Test marking a task as working without a message."""
    await task_updater.start_work()

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.working
    assert event.final is False
    assert event.status.message is None


@pytest.mark.asyncio
async def test_start_work_with_message(
    task_updater, event_queue, sample_message
):
    """Test marking a task as working with a message."""
    await task_updater.start_work(message=sample_message)

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.working
    assert event.final is False
    assert event.status.message == sample_message


def test_new_agent_message(task_updater, sample_parts):
    """Test creating a new agent message."""
    with patch(
        'uuid.uuid4',
        return_value=uuid.UUID('12345678-1234-5678-1234-567812345678'),
    ):
        message = task_updater.new_agent_message(parts=sample_parts)

    assert message.role == Role.agent
    assert message.task_id == 'test-task-id'
    assert message.context_id == 'test-context-id'
    assert message.message_id == '12345678-1234-5678-1234-567812345678'
    assert message.parts == sample_parts
    assert message.metadata is None


def test_new_agent_message_with_metadata(task_updater, sample_parts):
    """Test creating a new agent message with metadata and final=True."""
    metadata = {'key': 'value'}

    with patch(
        'uuid.uuid4',
        return_value=uuid.UUID('12345678-1234-5678-1234-567812345678'),
    ):
        message = task_updater.new_agent_message(
            parts=sample_parts, metadata=metadata
        )

    assert message.role == Role.agent
    assert message.task_id == 'test-task-id'
    assert message.context_id == 'test-context-id'
    assert message.message_id == '12345678-1234-5678-1234-567812345678'
    assert message.parts == sample_parts
    assert message.metadata == metadata


@pytest.mark.asyncio
async def test_failed_without_message(task_updater, event_queue):
    """Test marking a task as failed without a message."""
    await task_updater.failed()

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.failed
    assert event.final is True
    assert event.status.message is None


@pytest.mark.asyncio
async def test_failed_with_message(task_updater, event_queue, sample_message):
    """Test marking a task as failed with a message."""
    await task_updater.failed(message=sample_message)

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.failed
    assert event.final is True
    assert event.status.message == sample_message


@pytest.mark.asyncio
async def test_reject_without_message(task_updater, event_queue):
    """Test marking a task as rejected without a message."""
    await task_updater.reject()

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.rejected
    assert event.final is True
    assert event.status.message is None


@pytest.mark.asyncio
async def test_reject_with_message(task_updater, event_queue, sample_message):
    """Test marking a task as rejected with a message."""
    await task_updater.reject(message=sample_message)

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.rejected
    assert event.final is True
    assert event.status.message == sample_message


@pytest.mark.asyncio
async def test_requires_input_without_message(task_updater, event_queue):
    """Test marking a task as input required without a message."""
    await task_updater.requires_input()

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.input_required
    assert event.final is False
    assert event.status.message is None


@pytest.mark.asyncio
async def test_requires_input_with_message(
    task_updater, event_queue, sample_message
):
    """Test marking a task as input required with a message."""
    await task_updater.requires_input(message=sample_message)

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.input_required
    assert event.final is False
    assert event.status.message == sample_message


@pytest.mark.asyncio
async def test_requires_input_final_true(task_updater, event_queue):
    """Test marking a task as input required with final=True."""
    await task_updater.requires_input(final=True)

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.input_required
    assert event.final is True
    assert event.status.message is None


@pytest.mark.asyncio
async def test_requires_input_with_message_and_final(
    task_updater, event_queue, sample_message
):
    """Test marking a task as input required with message and final=True."""
    await task_updater.requires_input(message=sample_message, final=True)

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.input_required
    assert event.final is True
    assert event.status.message == sample_message


@pytest.mark.asyncio
async def test_requires_auth_without_message(task_updater, event_queue):
    """Test marking a task as auth required without a message."""
    await task_updater.requires_auth()

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.auth_required
    assert event.final is False
    assert event.status.message is None


@pytest.mark.asyncio
async def test_requires_auth_with_message(
    task_updater, event_queue, sample_message
):
    """Test marking a task as auth required with a message."""
    await task_updater.requires_auth(message=sample_message)

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.auth_required
    assert event.final is False
    assert event.status.message == sample_message


@pytest.mark.asyncio
async def test_requires_auth_final_true(task_updater, event_queue):
    """Test marking a task as auth required with final=True."""
    await task_updater.requires_auth(final=True)

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.auth_required
    assert event.final is True
    assert event.status.message is None


@pytest.mark.asyncio
async def test_requires_auth_with_message_and_final(
    task_updater, event_queue, sample_message
):
    """Test marking a task as auth required with message and final=True."""
    await task_updater.requires_auth(message=sample_message, final=True)

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.auth_required
    assert event.final is True
    assert event.status.message == sample_message


@pytest.mark.asyncio
async def test_cancel_without_message(task_updater, event_queue):
    """Test marking a task as cancelled without a message."""
    await task_updater.cancel()

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.canceled
    assert event.final is True
    assert event.status.message is None


@pytest.mark.asyncio
async def test_cancel_with_message(task_updater, event_queue, sample_message):
    """Test marking a task as cancelled with a message."""
    await task_updater.cancel(message=sample_message)

    event_queue.enqueue_event.assert_called_once()
    event = event_queue.enqueue_event.call_args[0][0]

    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.status.state == TaskState.canceled
    assert event.final is True
    assert event.status.message == sample_message


@pytest.mark.asyncio
async def test_update_status_raises_error_if_terminal_state_reached(
    task_updater, event_queue
):
    await task_updater.complete()
    event_queue.reset_mock()
    with pytest.raises(RuntimeError):
        await task_updater.start_work()
    event_queue.enqueue_event.assert_not_called()


@pytest.mark.asyncio
async def test_concurrent_updates_race_condition(event_queue):
    task_updater = TaskUpdater(
        event_queue=event_queue,
        task_id='test-task-id',
        context_id='test-context-id',
    )
    tasks = [
        task_updater.complete(),
        task_updater.failed(),
    ]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    successes = [r for r in results if not isinstance(r, Exception)]
    failures = [r for r in results if isinstance(r, RuntimeError)]
    assert len(successes) == 1
    assert len(failures) == 1
    assert event_queue.enqueue_event.call_count == 1


@pytest.mark.asyncio
async def test_reject_concurrently_with_complete(event_queue):
    """Test for race conditions when reject and complete are called concurrently."""
    task_updater = TaskUpdater(
        event_queue=event_queue,
        task_id='concurrent-task',
        context_id='concurrent-context',
    )

    tasks = [
        task_updater.reject(),
        task_updater.complete(),
    ]

    results = await asyncio.gather(*tasks, return_exceptions=True)

    successes = [r for r in results if not isinstance(r, Exception)]
    failures = [r for r in results if isinstance(r, RuntimeError)]

    assert len(successes) == 1
    assert len(failures) == 1

    assert event_queue.enqueue_event.call_count == 1

    event = event_queue.enqueue_event.call_args[0][0]
    assert isinstance(event, TaskStatusUpdateEvent)
    assert event.final is True
    assert event.status.state in [TaskState.rejected, TaskState.completed]



---
File: /a2a-python/tests/server/test_integration.py
---

import asyncio

from typing import Any
from unittest import mock

import pytest

from starlette.authentication import (
    AuthCredentials,
    AuthenticationBackend,
    BaseUser,
    SimpleUser,
)
from starlette.middleware import Middleware
from starlette.middleware.authentication import AuthenticationMiddleware
from starlette.requests import HTTPConnection
from starlette.responses import JSONResponse
from starlette.routing import Route
from starlette.testclient import TestClient

from a2a.server.apps import (
    A2AFastAPIApplication,
    A2AStarletteApplication,
)
from a2a.server.context import ServerCallContext
from a2a.types import (
    AgentCapabilities,
    AgentCard,
    Artifact,
    DataPart,
    InternalError,
    InvalidRequestError,
    JSONParseError,
    Message,
    Part,
    PushNotificationConfig,
    Role,
    SendMessageResponse,
    SendMessageSuccessResponse,
    Task,
    TaskArtifactUpdateEvent,
    TaskPushNotificationConfig,
    TaskState,
    TaskStatus,
    TextPart,
    UnsupportedOperationError,
)
from a2a.utils import (
    AGENT_CARD_WELL_KNOWN_PATH,
    EXTENDED_AGENT_CARD_PATH,
    PREV_AGENT_CARD_WELL_KNOWN_PATH,
)
from a2a.utils.errors import MethodNotImplementedError


# === TEST SETUP ===

MINIMAL_AGENT_SKILL: dict[str, Any] = {
    'id': 'skill-123',
    'name': 'Recipe Finder',
    'description': 'Finds recipes',
    'tags': ['cooking'],
}

MINIMAL_AGENT_AUTH: dict[str, Any] = {'schemes': ['Bearer']}

AGENT_CAPS = AgentCapabilities(
    push_notifications=True, state_transition_history=False, streaming=True
)

MINIMAL_AGENT_CARD: dict[str, Any] = {
    'authentication': MINIMAL_AGENT_AUTH,
    'capabilities': AGENT_CAPS,  # AgentCapabilities is required but can be empty
    'defaultInputModes': ['text/plain'],
    'defaultOutputModes': ['application/json'],
    'description': 'Test Agent',
    'name': 'TestAgent',
    'skills': [MINIMAL_AGENT_SKILL],
    'url': 'http://example.com/agent',
    'version': '1.0',
}

EXTENDED_AGENT_CARD_DATA: dict[str, Any] = {
    **MINIMAL_AGENT_CARD,
    'name': 'TestAgent Extended',
    'description': 'Test Agent with more details',
    'skills': [
        MINIMAL_AGENT_SKILL,
        {
            'id': 'skill-extended',
            'name': 'Extended Skill',
            'description': 'Does more things',
            'tags': ['extended'],
        },
    ],
}
TEXT_PART_DATA: dict[str, Any] = {'kind': 'text', 'text': 'Hello'}

DATA_PART_DATA: dict[str, Any] = {'kind': 'data', 'data': {'key': 'value'}}

MINIMAL_MESSAGE_USER: dict[str, Any] = {
    'role': 'user',
    'parts': [TEXT_PART_DATA],
    'message_id': 'msg-123',
    'kind': 'message',
}

MINIMAL_TASK_STATUS: dict[str, Any] = {'state': 'submitted'}

FULL_TASK_STATUS: dict[str, Any] = {
    'state': 'working',
    'message': MINIMAL_MESSAGE_USER,
    'timestamp': '2023-10-27T10:00:00Z',
}


@pytest.fixture
def agent_card():
    return AgentCard(**MINIMAL_AGENT_CARD)


@pytest.fixture
def extended_agent_card_fixture():
    return AgentCard(**EXTENDED_AGENT_CARD_DATA)


@pytest.fixture
def handler():
    handler = mock.AsyncMock()
    handler.on_message_send = mock.AsyncMock()
    handler.on_cancel_task = mock.AsyncMock()
    handler.on_get_task = mock.AsyncMock()
    handler.set_push_notification = mock.AsyncMock()
    handler.get_push_notification = mock.AsyncMock()
    handler.on_message_send_stream = mock.Mock()
    handler.on_resubscribe_to_task = mock.Mock()
    return handler


@pytest.fixture
def app(agent_card: AgentCard, handler: mock.AsyncMock):
    return A2AStarletteApplication(agent_card, handler)


@pytest.fixture
def client(app: A2AStarletteApplication, **kwargs):
    """Create a test client with the Starlette app."""
    return TestClient(app.build(**kwargs))


# === BASIC FUNCTIONALITY TESTS ===


def test_agent_card_endpoint(client: TestClient, agent_card: AgentCard):
    """Test the agent card endpoint returns expected data."""
    response = client.get(AGENT_CARD_WELL_KNOWN_PATH)
    assert response.status_code == 200
    data = response.json()
    assert data['name'] == agent_card.name
    assert data['version'] == agent_card.version
    assert 'streaming' in data['capabilities']


def test_authenticated_extended_agent_card_endpoint_not_supported(
    agent_card: AgentCard, handler: mock.AsyncMock
):
    """Test extended card endpoint returns 404 if not supported by main card."""
    # Ensure supportsAuthenticatedExtendedCard is False or None
    agent_card.supports_authenticated_extended_card = False
    app_instance = A2AStarletteApplication(agent_card, handler)
    # The route should not even be added if supportsAuthenticatedExtendedCard is false
    # So, building the app and trying to hit it should result in 404 from Starlette itself
    client = TestClient(app_instance.build())
    response = client.get('/agent/authenticatedExtendedCard')
    assert response.status_code == 404  # Starlette's default for no route


def test_agent_card_default_endpoint_has_deprecated_route(
    agent_card: AgentCard, handler: mock.AsyncMock
):
    """Test agent card deprecated route is available for default route."""
    app_instance = A2AStarletteApplication(agent_card, handler)
    client = TestClient(app_instance.build())
    response = client.get(AGENT_CARD_WELL_KNOWN_PATH)
    assert response.status_code == 200
    data = response.json()
    assert data['name'] == agent_card.name
    response = client.get(PREV_AGENT_CARD_WELL_KNOWN_PATH)
    assert response.status_code == 200
    data = response.json()
    assert data['name'] == agent_card.name


def test_agent_card_custom_endpoint_has_no_deprecated_route(
    agent_card: AgentCard, handler: mock.AsyncMock
):
    """Test agent card deprecated route is not available for custom route."""
    app_instance = A2AStarletteApplication(agent_card, handler)
    client = TestClient(app_instance.build(agent_card_url='/my-agent'))
    response = client.get('/my-agent')
    assert response.status_code == 200
    data = response.json()
    assert data['name'] == agent_card.name
    response = client.get(PREV_AGENT_CARD_WELL_KNOWN_PATH)
    assert response.status_code == 404


def test_authenticated_extended_agent_card_endpoint_not_supported_fastapi(
    agent_card: AgentCard, handler: mock.AsyncMock
):
    """Test extended card endpoint returns 404 if not supported by main card."""
    # Ensure supportsAuthenticatedExtendedCard is False or None
    agent_card.supports_authenticated_extended_card = False
    app_instance = A2AFastAPIApplication(agent_card, handler)
    # The route should not even be added if supportsAuthenticatedExtendedCard is false
    # So, building the app and trying to hit it should result in 404 from FastAPI itself
    client = TestClient(app_instance.build())
    response = client.get('/agent/authenticatedExtendedCard')
    assert response.status_code == 404  # FastAPI's default for no route


def test_authenticated_extended_agent_card_endpoint_supported_with_specific_extended_card_starlette(
    agent_card: AgentCard,
    extended_agent_card_fixture: AgentCard,
    handler: mock.AsyncMock,
):
    """Test extended card endpoint returns the specific extended card when provided."""
    agent_card.supports_authenticated_extended_card = (
        True  # Main card must support it
    )

    app_instance = A2AStarletteApplication(
        agent_card, handler, extended_agent_card=extended_agent_card_fixture
    )
    client = TestClient(app_instance.build())

    response = client.get('/agent/authenticatedExtendedCard')
    assert response.status_code == 200
    data = response.json()
    # Verify it's the extended card's data
    assert data['name'] == extended_agent_card_fixture.name
    assert data['version'] == extended_agent_card_fixture.version
    assert len(data['skills']) == len(extended_agent_card_fixture.skills)
    assert any(skill['id'] == 'skill-extended' for skill in data['skills']), (
        'Extended skill not found in served card'
    )


def test_authenticated_extended_agent_card_endpoint_supported_with_specific_extended_card_fastapi(
    agent_card: AgentCard,
    extended_agent_card_fixture: AgentCard,
    handler: mock.AsyncMock,
):
    """Test extended card endpoint returns the specific extended card when provided."""
    agent_card.supports_authenticated_extended_card = (
        True  # Main card must support it
    )
    app_instance = A2AFastAPIApplication(
        agent_card, handler, extended_agent_card=extended_agent_card_fixture
    )
    client = TestClient(app_instance.build())

    response = client.get('/agent/authenticatedExtendedCard')
    assert response.status_code == 200
    data = response.json()
    # Verify it's the extended card's data
    assert data['name'] == extended_agent_card_fixture.name
    assert data['version'] == extended_agent_card_fixture.version
    assert len(data['skills']) == len(extended_agent_card_fixture.skills)
    assert any(skill['id'] == 'skill-extended' for skill in data['skills']), (
        'Extended skill not found in served card'
    )


def test_agent_card_custom_url(
    app: A2AStarletteApplication, agent_card: AgentCard
):
    """Test the agent card endpoint with a custom URL."""
    client = TestClient(app.build(agent_card_url='/my-agent'))
    response = client.get('/my-agent')
    assert response.status_code == 200
    data = response.json()
    assert data['name'] == agent_card.name


def test_starlette_rpc_endpoint_custom_url(
    app: A2AStarletteApplication, handler: mock.AsyncMock
):
    """Test the RPC endpoint with a custom URL."""
    # Provide a valid Task object as the return value
    task_status = TaskStatus(**MINIMAL_TASK_STATUS)
    task = Task(id='task1', context_id='ctx1', status=task_status)
    handler.on_get_task.return_value = task
    client = TestClient(app.build(rpc_url='/api/rpc'))
    response = client.post(
        '/api/rpc',
        json={
            'jsonrpc': '2.0',
            'id': '123',
            'method': 'tasks/get',
            'params': {'id': 'task1'},
        },
    )
    assert response.status_code == 200
    data = response.json()
    assert data['result']['id'] == 'task1'


def test_fastapi_rpc_endpoint_custom_url(
    app: A2AFastAPIApplication, handler: mock.AsyncMock
):
    """Test the RPC endpoint with a custom URL."""
    # Provide a valid Task object as the return value
    task_status = TaskStatus(**MINIMAL_TASK_STATUS)
    task = Task(id='task1', context_id='ctx1', status=task_status)
    handler.on_get_task.return_value = task
    client = TestClient(app.build(rpc_url='/api/rpc'))
    response = client.post(
        '/api/rpc',
        json={
            'jsonrpc': '2.0',
            'id': '123',
            'method': 'tasks/get',
            'params': {'id': 'task1'},
        },
    )
    assert response.status_code == 200
    data = response.json()
    assert data['result']['id'] == 'task1'


def test_starlette_build_with_extra_routes(
    app: A2AStarletteApplication, agent_card: AgentCard
):
    """Test building the app with additional routes."""

    def custom_handler(request):
        return JSONResponse({'message': 'Hello'})

    extra_route = Route('/hello', custom_handler, methods=['GET'])
    test_app = app.build(routes=[extra_route])
    client = TestClient(test_app)

    # Test the added route
    response = client.get('/hello')
    assert response.status_code == 200
    assert response.json() == {'message': 'Hello'}

    # Ensure default routes still work
    response = client.get(AGENT_CARD_WELL_KNOWN_PATH)
    assert response.status_code == 200
    data = response.json()
    assert data['name'] == agent_card.name


def test_fastapi_build_with_extra_routes(
    app: A2AFastAPIApplication, agent_card: AgentCard
):
    """Test building the app with additional routes."""

    def custom_handler(request):
        return JSONResponse({'message': 'Hello'})

    extra_route = Route('/hello', custom_handler, methods=['GET'])
    test_app = app.build(routes=[extra_route])
    client = TestClient(test_app)

    # Test the added route
    response = client.get('/hello')
    assert response.status_code == 200
    assert response.json() == {'message': 'Hello'}

    # Ensure default routes still work
    response = client.get(AGENT_CARD_WELL_KNOWN_PATH)
    assert response.status_code == 200
    data = response.json()
    assert data['name'] == agent_card.name

    # check if deprecated agent card path route is available with default well-known path
    response = client.get(PREV_AGENT_CARD_WELL_KNOWN_PATH)
    assert response.status_code == 200
    data = response.json()
    assert data['name'] == agent_card.name


def test_fastapi_build_custom_agent_card_path(
    app: A2AFastAPIApplication, agent_card: AgentCard
):
    """Test building the app with a custom agent card path."""

    test_app = app.build(agent_card_url='/agent-card')
    client = TestClient(test_app)

    # Ensure custom card path works
    response = client.get('/agent-card')
    assert response.status_code == 200
    data = response.json()
    assert data['name'] == agent_card.name

    # Ensure default agent card location is not available
    response = client.get(AGENT_CARD_WELL_KNOWN_PATH)
    assert response.status_code == 404

    # check if deprecated agent card path route is not available
    response = client.get(PREV_AGENT_CARD_WELL_KNOWN_PATH)
    assert response.status_code == 404


# === REQUEST METHODS TESTS ===


def test_send_message(client: TestClient, handler: mock.AsyncMock):
    """Test sending a message."""
    # Prepare mock response
    task_status = TaskStatus(**MINIMAL_TASK_STATUS)
    mock_task = Task(
        id='task1',
        context_id='session-xyz',
        status=task_status,
    )
    handler.on_message_send.return_value = mock_task

    # Send request
    response = client.post(
        '/',
        json={
            'jsonrpc': '2.0',
            'id': '123',
            'method': 'message/send',
            'params': {
                'message': {
                    'role': 'agent',
                    'parts': [{'kind': 'text', 'text': 'Hello'}],
                    'message_id': '111',
                    'kind': 'message',
                    'task_id': 'task1',
                    'context_id': 'session-xyz',
                }
            },
        },
    )

    # Verify response
    assert response.status_code == 200
    data = response.json()
    assert 'result' in data
    assert data['result']['id'] == 'task1'
    assert data['result']['status']['state'] == 'submitted'

    # Verify handler was called
    handler.on_message_send.assert_awaited_once()


def test_cancel_task(client: TestClient, handler: mock.AsyncMock):
    """Test cancelling a task."""
    # Setup mock response
    task_status = TaskStatus(**MINIMAL_TASK_STATUS)
    task_status.state = TaskState.canceled  # 'cancelled' #
    task = Task(id='task1', context_id='ctx1', status=task_status)
    handler.on_cancel_task.return_value = task

    # Send request
    response = client.post(
        '/',
        json={
            'jsonrpc': '2.0',
            'id': '123',
            'method': 'tasks/cancel',
            'params': {'id': 'task1'},
        },
    )

    # Verify response
    assert response.status_code == 200
    data = response.json()
    assert data['result']['id'] == 'task1'
    assert data['result']['status']['state'] == 'canceled'

    # Verify handler was called
    handler.on_cancel_task.assert_awaited_once()


def test_get_task(client: TestClient, handler: mock.AsyncMock):
    """Test getting a task."""
    # Setup mock response
    task_status = TaskStatus(**MINIMAL_TASK_STATUS)
    task = Task(id='task1', context_id='ctx1', status=task_status)
    handler.on_get_task.return_value = task  # JSONRPCResponse(root=task)

    # Send request
    response = client.post(
        '/',
        json={
            'jsonrpc': '2.0',
            'id': '123',
            'method': 'tasks/get',
            'params': {'id': 'task1'},
        },
    )

    # Verify response
    assert response.status_code == 200
    data = response.json()
    assert data['result']['id'] == 'task1'

    # Verify handler was called
    handler.on_get_task.assert_awaited_once()


def test_set_push_notification_config(
    client: TestClient, handler: mock.AsyncMock
):
    """Test setting push notification configuration."""
    # Setup mock response
    task_push_config = TaskPushNotificationConfig(
        task_id='t2',
        push_notification_config=PushNotificationConfig(
            url='https://example.com', token='secret-token'
        ),
    )
    handler.on_set_task_push_notification_config.return_value = task_push_config

    # Send request
    response = client.post(
        '/',
        json={
            'jsonrpc': '2.0',
            'id': '123',
            'method': 'tasks/pushNotificationConfig/set',
            'params': {
                'task_id': 't2',
                'pushNotificationConfig': {
                    'url': 'https://example.com',
                    'token': 'secret-token',
                },
            },
        },
    )

    # Verify response
    assert response.status_code == 200
    data = response.json()
    assert data['result']['pushNotificationConfig']['token'] == 'secret-token'

    # Verify handler was called
    handler.on_set_task_push_notification_config.assert_awaited_once()


def test_get_push_notification_config(
    client: TestClient, handler: mock.AsyncMock
):
    """Test getting push notification configuration."""
    # Setup mock response
    task_push_config = TaskPushNotificationConfig(
        task_id='task1',
        push_notification_config=PushNotificationConfig(
            url='https://example.com', token='secret-token'
        ),
    )

    handler.on_get_task_push_notification_config.return_value = task_push_config

    # Send request
    response = client.post(
        '/',
        json={
            'jsonrpc': '2.0',
            'id': '123',
            'method': 'tasks/pushNotificationConfig/get',
            'params': {'id': 'task1'},
        },
    )

    # Verify response
    assert response.status_code == 200
    data = response.json()
    assert data['result']['pushNotificationConfig']['token'] == 'secret-token'

    # Verify handler was called
    handler.on_get_task_push_notification_config.assert_awaited_once()


def test_server_auth(app: A2AStarletteApplication, handler: mock.AsyncMock):
    class TestAuthMiddleware(AuthenticationBackend):
        async def authenticate(
            self, conn: HTTPConnection
        ) -> tuple[AuthCredentials, BaseUser] | None:
            # For the purposes of this test, all requests are authenticated!
            return (AuthCredentials(['authenticated']), SimpleUser('test_user'))

    client = TestClient(
        app.build(
            middleware=[
                Middleware(
                    AuthenticationMiddleware, backend=TestAuthMiddleware()
                )
            ]
        )
    )

    # Set the output message to be the authenticated user name
    handler.on_message_send.side_effect = lambda params, context: Message(
        context_id='session-xyz',
        message_id='112',
        role=Role.agent,
        parts=[
            Part(TextPart(text=context.user.user_name)),
        ],
    )

    # Send request
    response = client.post(
        '/',
        json={
            'jsonrpc': '2.0',
            'id': '123',
            'method': 'message/send',
            'params': {
                'message': {
                    'role': 'agent',
                    'parts': [{'kind': 'text', 'text': 'Hello'}],
                    'message_id': '111',
                    'kind': 'message',
                    'task_id': 'task1',
                    'context_id': 'session-xyz',
                }
            },
        },
    )

    # Verify response
    assert response.status_code == 200
    result = SendMessageResponse.model_validate(response.json())
    assert isinstance(result.root, SendMessageSuccessResponse)
    assert isinstance(result.root.result, Message)
    message = result.root.result
    assert isinstance(message.parts[0].root, TextPart)
    assert message.parts[0].root.text == 'test_user'

    # Verify handler was called
    handler.on_message_send.assert_awaited_once()


# === STREAMING TESTS ===


@pytest.mark.asyncio
async def test_message_send_stream(
    app: A2AStarletteApplication, handler: mock.AsyncMock
) -> None:
    """Test streaming message sending."""

    # Setup mock streaming response
    async def stream_generator():
        for i in range(3):
            text_part = TextPart(**TEXT_PART_DATA)
            data_part = DataPart(**DATA_PART_DATA)
            artifact = Artifact(
                artifact_id=f'artifact-{i}',
                name='result_data',
                parts=[Part(root=text_part), Part(root=data_part)],
            )
            last = [False, False, True]
            task_artifact_update_event_data: dict[str, Any] = {
                'artifact': artifact,
                'task_id': 'task_id',
                'context_id': 'session-xyz',
                'append': False,
                'lastChunk': last[i],
                'kind': 'artifact-update',
            }

            yield TaskArtifactUpdateEvent.model_validate(
                task_artifact_update_event_data
            )

    handler.on_message_send_stream.return_value = stream_generator()

    client = None
    try:
        # Create client
        client = TestClient(app.build(), raise_server_exceptions=False)
        # Send request
        with client.stream(
            'POST',
            '/',
            json={
                'jsonrpc': '2.0',
                'id': '123',
                'method': 'message/stream',
                'params': {
                    'message': {
                        'role': 'agent',
                        'parts': [{'kind': 'text', 'text': 'Hello'}],
                        'message_id': '111',
                        'kind': 'message',
                        'task_id': 'task_id',
                        'context_id': 'session-xyz',
                    }
                },
            },
        ) as response:
            # Verify response is a stream
            assert response.status_code == 200
            assert response.headers['content-type'].startswith(
                'text/event-stream'
            )

            # Read some content to verify streaming works
            content = b''
            event_count = 0

            for chunk in response.iter_bytes():
                content += chunk
                if b'data' in chunk:  # Naive check for SSE data lines
                    event_count += 1

            # Check content has event data (e.g., part of the first event)
            assert (
                b'"artifactId":"artifact-0"' in content
            )  # Check for the actual JSON payload
            assert (
                b'"artifactId":"artifact-1"' in content
            )  # Check for the actual JSON payload
            assert (
                b'"artifactId":"artifact-2"' in content
            )  # Check for the actual JSON payload
            assert event_count > 0
    finally:
        # Ensure the client is closed
        if client:
            client.close()
        # Allow event loop to process any pending callbacks
        await asyncio.sleep(0.1)


@pytest.mark.asyncio
async def test_task_resubscription(
    app: A2AStarletteApplication, handler: mock.AsyncMock
) -> None:
    """Test task resubscription streaming."""

    # Setup mock streaming response
    async def stream_generator():
        for i in range(3):
            text_part = TextPart(**TEXT_PART_DATA)
            data_part = DataPart(**DATA_PART_DATA)
            artifact = Artifact(
                artifact_id=f'artifact-{i}',
                name='result_data',
                parts=[Part(root=text_part), Part(root=data_part)],
            )
            last = [False, False, True]
            task_artifact_update_event_data: dict[str, Any] = {
                'artifact': artifact,
                'task_id': 'task_id',
                'context_id': 'session-xyz',
                'append': False,
                'lastChunk': last[i],
                'kind': 'artifact-update',
            }
            yield TaskArtifactUpdateEvent.model_validate(
                task_artifact_update_event_data
            )

    handler.on_resubscribe_to_task.return_value = stream_generator()

    # Create client
    client = TestClient(app.build(), raise_server_exceptions=False)

    try:
        # Send request using client.stream() context manager
        # Send request
        with client.stream(
            'POST',
            '/',
            json={
                'jsonrpc': '2.0',
                'id': '123',  # This ID is used in the success_event above
                'method': 'tasks/resubscribe',
                'params': {'id': 'task1'},
            },
        ) as response:
            # Verify response is a stream
            assert response.status_code == 200
            assert (
                response.headers['content-type']
                == 'text/event-stream; charset=utf-8'
            )

            # Read some content to verify streaming works
            content = b''
            event_count = 0
            for chunk in response.iter_bytes():
                content += chunk
                # A more robust check would be to parse each SSE event
                if b'data:' in chunk:  # Naive check for SSE data lines
                    event_count += 1
                if (
                    event_count >= 1 and len(content) > 20
                ):  # Ensure we've processed at least one event
                    break

            # Check content has event data (e.g., part of the first event)
            assert (
                b'"artifactId":"artifact-0"' in content
            )  # Check for the actual JSON payload
            assert (
                b'"artifactId":"artifact-1"' in content
            )  # Check for the actual JSON payload
            assert (
                b'"artifactId":"artifact-2"' in content
            )  # Check for the actual JSON payload
            assert event_count > 0
    finally:
        # Ensure the client is closed
        if client:
            client.close()
        # Allow event loop to process any pending callbacks
        await asyncio.sleep(0.1)


# === ERROR HANDLING TESTS ===


def test_invalid_json(client: TestClient):
    """Test handling invalid JSON."""
    response = client.post('/', content=b'This is not JSON')  # Use bytes
    assert response.status_code == 200  # JSON-RPC errors still return 200
    data = response.json()
    assert 'error' in data
    assert data['error']['code'] == JSONParseError().code


def test_invalid_request_structure(client: TestClient):
    """Test handling an invalid request structure."""
    response = client.post(
        '/',
        json={
            # Missing required fields
            'id': '123',
            'method': 'foo/bar',
        },
    )
    assert response.status_code == 200
    data = response.json()
    assert 'error' in data
    assert data['error']['code'] == InvalidRequestError().code


# === DYNAMIC CARD MODIFIER TESTS ===


def test_dynamic_agent_card_modifier(
    agent_card: AgentCard, handler: mock.AsyncMock
):
    """Test that the card_modifier dynamically alters the public agent card."""

    def modifier(card: AgentCard) -> AgentCard:
        modified_card = card.model_copy(deep=True)
        modified_card.name = 'Dynamically Modified Agent'
        return modified_card

    app_instance = A2AStarletteApplication(
        agent_card, handler, card_modifier=modifier
    )
    client = TestClient(app_instance.build())

    response = client.get(AGENT_CARD_WELL_KNOWN_PATH)
    assert response.status_code == 200
    data = response.json()
    assert data['name'] == 'Dynamically Modified Agent'
    assert (
        data['version'] == agent_card.version
    )  # Ensure other fields are intact


def test_dynamic_extended_agent_card_modifier(
    agent_card: AgentCard,
    extended_agent_card_fixture: AgentCard,
    handler: mock.AsyncMock,
):
    """Test that the extended_card_modifier dynamically alters the extended agent card."""
    agent_card.supports_authenticated_extended_card = True

    def modifier(card: AgentCard, context: ServerCallContext) -> AgentCard:
        modified_card = card.model_copy(deep=True)
        modified_card.description = 'Dynamically Modified Extended Description'
        return modified_card

    # Test with a base extended card
    app_instance = A2AStarletteApplication(
        agent_card,
        handler,
        extended_agent_card=extended_agent_card_fixture,
        extended_card_modifier=modifier,
    )
    client = TestClient(app_instance.build())

    response = client.get(EXTENDED_AGENT_CARD_PATH)
    assert response.status_code == 200
    data = response.json()
    assert data['name'] == extended_agent_card_fixture.name
    assert data['description'] == 'Dynamically Modified Extended Description'

    # Test without a base extended card (modifier should receive public card)
    app_instance_no_base = A2AStarletteApplication(
        agent_card,
        handler,
        extended_agent_card=None,
        extended_card_modifier=modifier,
    )
    client_no_base = TestClient(app_instance_no_base.build())
    response_no_base = client_no_base.get(EXTENDED_AGENT_CARD_PATH)
    assert response_no_base.status_code == 200
    data_no_base = response_no_base.json()
    assert data_no_base['name'] == agent_card.name
    assert (
        data_no_base['description']
        == 'Dynamically Modified Extended Description'
    )


def test_fastapi_dynamic_agent_card_modifier(
    agent_card: AgentCard, handler: mock.AsyncMock
):
    """Test that the card_modifier dynamically alters the public agent card for FastAPI."""

    def modifier(card: AgentCard) -> AgentCard:
        modified_card = card.model_copy(deep=True)
        modified_card.name = 'Dynamically Modified Agent'
        return modified_card

    app_instance = A2AFastAPIApplication(
        agent_card, handler, card_modifier=modifier
    )
    client = TestClient(app_instance.build())

    response = client.get(AGENT_CARD_WELL_KNOWN_PATH)
    assert response.status_code == 200
    data = response.json()
    assert data['name'] == 'Dynamically Modified Agent'


def test_method_not_implemented(client: TestClient, handler: mock.AsyncMock):
    """Test handling MethodNotImplementedError."""
    handler.on_get_task.side_effect = MethodNotImplementedError()

    response = client.post(
        '/',
        json={
            'jsonrpc': '2.0',
            'id': '123',
            'method': 'tasks/get',
            'params': {'id': 'task1'},
        },
    )
    assert response.status_code == 200
    data = response.json()
    assert 'error' in data
    assert data['error']['code'] == UnsupportedOperationError().code


def test_unknown_method(client: TestClient):
    """Test handling unknown method."""
    response = client.post(
        '/',
        json={
            'jsonrpc': '2.0',
            'id': '123',
            'method': 'unknown/method',
            'params': {},
        },
    )
    assert response.status_code == 200
    data = response.json()
    assert 'error' in data
    # This should produce an UnsupportedOperationError error code
    assert data['error']['code'] == InvalidRequestError().code


def test_validation_error(client: TestClient):
    """Test handling validation error."""
    # Missing required fields in the message
    response = client.post(
        '/',
        json={
            'jsonrpc': '2.0',
            'id': '123',
            'method': 'messages/send',
            'params': {
                'message': {
                    # Missing required fields
                    'text': 'Hello'
                }
            },
        },
    )
    assert response.status_code == 200
    data = response.json()
    assert 'error' in data
    assert data['error']['code'] == InvalidRequestError().code


def test_unhandled_exception(client: TestClient, handler: mock.AsyncMock):
    """Test handling unhandled exception."""
    handler.on_get_task.side_effect = Exception('Unexpected error')

    response = client.post(
        '/',
        json={
            'jsonrpc': '2.0',
            'id': '123',
            'method': 'tasks/get',
            'params': {'id': 'task1'},
        },
    )
    assert response.status_code == 200
    data = response.json()
    assert 'error' in data
    assert data['error']['code'] == InternalError().code
    assert 'Unexpected error' in data['error']['message']


def test_get_method_to_rpc_endpoint(client: TestClient):
    """Test sending GET request to RPC endpoint."""
    response = client.get('/')
    # Should return 405 Method Not Allowed
    assert response.status_code == 405


def test_non_dict_json(client: TestClient):
    """Test handling JSON that's not a dict."""
    response = client.post('/', json=['not', 'a', 'dict'])
    assert response.status_code == 200
    data = response.json()
    assert 'error' in data
    assert data['error']['code'] == InvalidRequestError().code



---
File: /a2a-python/tests/server/test_models.py
---

"""Tests for a2a.server.models module."""

from unittest.mock import MagicMock

from sqlalchemy.orm import DeclarativeBase

from a2a.server.models import (
    PydanticListType,
    PydanticType,
    create_push_notification_config_model,
    create_task_model,
)
from a2a.types import Artifact, TaskState, TaskStatus, TextPart


class TestPydanticType:
    """Tests for PydanticType SQLAlchemy type decorator."""

    def test_process_bind_param_with_pydantic_model(self):
        pydantic_type = PydanticType(TaskStatus)
        status = TaskStatus(state=TaskState.working)
        dialect = MagicMock()

        result = pydantic_type.process_bind_param(status, dialect)
        assert result['state'] == 'working'
        assert result['message'] is None
        # TaskStatus may have other optional fields

    def test_process_bind_param_with_none(self):
        pydantic_type = PydanticType(TaskStatus)
        dialect = MagicMock()

        result = pydantic_type.process_bind_param(None, dialect)
        assert result is None

    def test_process_result_value(self):
        pydantic_type = PydanticType(TaskStatus)
        dialect = MagicMock()

        result = pydantic_type.process_result_value(
            {'state': 'completed', 'message': None}, dialect
        )
        assert isinstance(result, TaskStatus)
        assert result.state == 'completed'


class TestPydanticListType:
    """Tests for PydanticListType SQLAlchemy type decorator."""

    def test_process_bind_param_with_list(self):
        pydantic_list_type = PydanticListType(Artifact)
        artifacts = [
            Artifact(
                artifact_id='1', parts=[TextPart(type='text', text='Hello')]
            ),
            Artifact(
                artifact_id='2', parts=[TextPart(type='text', text='World')]
            ),
        ]
        dialect = MagicMock()

        result = pydantic_list_type.process_bind_param(artifacts, dialect)
        assert len(result) == 2
        assert result[0]['artifactId'] == '1'  # JSON mode uses camelCase
        assert result[1]['artifactId'] == '2'

    def test_process_result_value_with_list(self):
        pydantic_list_type = PydanticListType(Artifact)
        dialect = MagicMock()
        data = [
            {'artifact_id': '1', 'parts': [{'type': 'text', 'text': 'Hello'}]},
            {'artifact_id': '2', 'parts': [{'type': 'text', 'text': 'World'}]},
        ]

        result = pydantic_list_type.process_result_value(data, dialect)
        assert len(result) == 2
        assert all(isinstance(art, Artifact) for art in result)
        assert result[0].artifact_id == '1'
        assert result[1].artifact_id == '2'


def test_create_task_model():
    """Test dynamic task model creation."""

    # Create a fresh base to avoid table conflicts
    class TestBase(DeclarativeBase):
        pass

    # Create with default table name
    default_task_model = create_task_model('test_tasks_1', TestBase)
    assert default_task_model.__tablename__ == 'test_tasks_1'
    assert default_task_model.__name__ == 'TaskModel_test_tasks_1'

    # Create with custom table name
    custom_task_model = create_task_model('test_tasks_2', TestBase)
    assert custom_task_model.__tablename__ == 'test_tasks_2'
    assert custom_task_model.__name__ == 'TaskModel_test_tasks_2'


def test_create_push_notification_config_model():
    """Test dynamic push notification config model creation."""

    # Create a fresh base to avoid table conflicts
    class TestBase(DeclarativeBase):
        pass

    # Create with default table name
    default_model = create_push_notification_config_model(
        'test_push_configs_1', TestBase
    )
    assert default_model.__tablename__ == 'test_push_configs_1'

    # Create with custom table name
    custom_model = create_push_notification_config_model(
        'test_push_configs_2', TestBase
    )
    assert custom_model.__tablename__ == 'test_push_configs_2'
    assert 'test_push_configs_2' in custom_model.__name__



---
File: /a2a-python/tests/utils/test_artifact.py
---

import unittest
import uuid

from unittest.mock import patch

from a2a.types import DataPart, Part, TextPart
from a2a.utils.artifact import (
    new_artifact,
    new_data_artifact,
    new_text_artifact,
)


class TestArtifact(unittest.TestCase):
    @patch('uuid.uuid4')
    def test_new_artifact_generates_id(self, mock_uuid4):
        mock_uuid = uuid.UUID('abcdef12-1234-5678-1234-567812345678')
        mock_uuid4.return_value = mock_uuid
        artifact = new_artifact(parts=[], name='test_artifact')
        self.assertEqual(artifact.artifact_id, str(mock_uuid))

    def test_new_artifact_assigns_parts_name_description(self):
        parts = [Part(root=TextPart(text='Sample text'))]
        name = 'My Artifact'
        description = 'This is a test artifact.'
        artifact = new_artifact(parts=parts, name=name, description=description)
        self.assertEqual(artifact.parts, parts)
        self.assertEqual(artifact.name, name)
        self.assertEqual(artifact.description, description)

    def test_new_artifact_empty_description_if_not_provided(self):
        parts = [Part(root=TextPart(text='Another sample'))]
        name = 'Artifact_No_Desc'
        artifact = new_artifact(parts=parts, name=name)
        self.assertEqual(artifact.description, '')

    def test_new_text_artifact_creates_single_text_part(self):
        text = 'This is a text artifact.'
        name = 'Text_Artifact'
        artifact = new_text_artifact(text=text, name=name)
        self.assertEqual(len(artifact.parts), 1)
        self.assertIsInstance(artifact.parts[0].root, TextPart)

    def test_new_text_artifact_part_contains_provided_text(self):
        text = 'Hello, world!'
        name = 'Greeting_Artifact'
        artifact = new_text_artifact(text=text, name=name)
        self.assertEqual(artifact.parts[0].root.text, text)

    def test_new_text_artifact_assigns_name_description(self):
        text = 'Some content.'
        name = 'Named_Text_Artifact'
        description = 'Description for text artifact.'
        artifact = new_text_artifact(
            text=text, name=name, description=description
        )
        self.assertEqual(artifact.name, name)
        self.assertEqual(artifact.description, description)

    def test_new_data_artifact_creates_single_data_part(self):
        sample_data = {'key': 'value', 'number': 123}
        name = 'Data_Artifact'
        artifact = new_data_artifact(data=sample_data, name=name)
        self.assertEqual(len(artifact.parts), 1)
        self.assertIsInstance(artifact.parts[0].root, DataPart)

    def test_new_data_artifact_part_contains_provided_data(self):
        sample_data = {'content': 'test_data', 'is_valid': True}
        name = 'Structured_Data_Artifact'
        artifact = new_data_artifact(data=sample_data, name=name)
        self.assertIsInstance(artifact.parts[0].root, DataPart)
        # Ensure the 'data' attribute of DataPart is accessed for comparison
        self.assertEqual(artifact.parts[0].root.data, sample_data)

    def test_new_data_artifact_assigns_name_description(self):
        sample_data = {'info': 'some details'}
        name = 'Named_Data_Artifact'
        description = 'Description for data artifact.'
        artifact = new_data_artifact(
            data=sample_data, name=name, description=description
        )
        self.assertEqual(artifact.name, name)
        self.assertEqual(artifact.description, description)


if __name__ == '__main__':
    unittest.main()



---
File: /a2a-python/tests/utils/test_constants.py
---

"""Tests for a2a.utils.constants module."""

from a2a.utils import constants


def test_agent_card_constants():
    """Test that agent card constants have expected values."""
    assert (
        constants.AGENT_CARD_WELL_KNOWN_PATH == '/.well-known/agent-card.json'
    )
    assert (
        constants.PREV_AGENT_CARD_WELL_KNOWN_PATH == '/.well-known/agent.json'
    )
    assert (
        constants.EXTENDED_AGENT_CARD_PATH == '/agent/authenticatedExtendedCard'
    )


def test_default_rpc_url():
    """Test default RPC URL constant."""
    assert constants.DEFAULT_RPC_URL == '/'



---
File: /a2a-python/tests/utils/test_error_handlers.py
---

"""Tests for a2a.utils.error_handlers module."""

from unittest.mock import patch

import pytest

from a2a.types import (
    InternalError,
    InvalidRequestError,
    MethodNotFoundError,
    TaskNotFoundError,
)
from a2a.utils.error_handlers import (
    A2AErrorToHttpStatus,
    rest_error_handler,
    rest_stream_error_handler,
)
from a2a.utils.errors import ServerError


class MockJSONResponse:
    def __init__(self, content, status_code):
        self.content = content
        self.status_code = status_code


@pytest.mark.asyncio
async def test_rest_error_handler_server_error():
    """Test rest_error_handler with ServerError."""
    error = InvalidRequestError(message='Bad request')

    @rest_error_handler
    async def failing_func():
        raise ServerError(error=error)

    with patch('a2a.utils.error_handlers.JSONResponse', MockJSONResponse):
        result = await failing_func()

    assert isinstance(result, MockJSONResponse)
    assert result.status_code == 400
    assert result.content == {'message': 'Bad request'}


@pytest.mark.asyncio
async def test_rest_error_handler_unknown_exception():
    """Test rest_error_handler with unknown exception."""

    @rest_error_handler
    async def failing_func():
        raise ValueError('Unexpected error')

    with patch('a2a.utils.error_handlers.JSONResponse', MockJSONResponse):
        result = await failing_func()

    assert isinstance(result, MockJSONResponse)
    assert result.status_code == 500
    assert result.content == {'message': 'unknown exception'}


@pytest.mark.asyncio
async def test_rest_stream_error_handler_server_error():
    """Test rest_stream_error_handler with ServerError."""
    error = InternalError(message='Internal server error')

    @rest_stream_error_handler
    async def failing_stream():
        raise ServerError(error=error)

    with pytest.raises(ServerError) as exc_info:
        await failing_stream()

    assert exc_info.value.error == error


@pytest.mark.asyncio
async def test_rest_stream_error_handler_reraises_exception():
    """Test rest_stream_error_handler reraises other exceptions."""

    @rest_stream_error_handler
    async def failing_stream():
        raise RuntimeError('Stream failed')

    with pytest.raises(RuntimeError, match='Stream failed'):
        await failing_stream()


def test_a2a_error_to_http_status_mapping():
    """Test A2AErrorToHttpStatus mapping."""
    assert A2AErrorToHttpStatus[InvalidRequestError] == 400
    assert A2AErrorToHttpStatus[MethodNotFoundError] == 404
    assert A2AErrorToHttpStatus[TaskNotFoundError] == 404
    assert A2AErrorToHttpStatus[InternalError] == 500



---
File: /a2a-python/tests/utils/test_helpers.py
---

import uuid

from typing import Any
from unittest.mock import patch

import pytest

from a2a.types import (
    Artifact,
    Message,
    MessageSendParams,
    Part,
    Role,
    Task,
    TaskArtifactUpdateEvent,
    TaskState,
    TextPart,
)
from a2a.utils.errors import ServerError
from a2a.utils.helpers import (
    append_artifact_to_task,
    are_modalities_compatible,
    build_text_artifact,
    create_task_obj,
    validate,
)


# --- Helper Data ---
TEXT_PART_DATA: dict[str, Any] = {'type': 'text', 'text': 'Hello'}

MINIMAL_MESSAGE_USER: dict[str, Any] = {
    'role': 'user',
    'parts': [TEXT_PART_DATA],
    'message_id': 'msg-123',
    'type': 'message',
}

MINIMAL_TASK_STATUS: dict[str, Any] = {'state': 'submitted'}

MINIMAL_TASK: dict[str, Any] = {
    'id': 'task-abc',
    'context_id': 'session-xyz',
    'status': MINIMAL_TASK_STATUS,
    'type': 'task',
}


# Test create_task_obj
def test_create_task_obj():
    message = Message(**MINIMAL_MESSAGE_USER)
    send_params = MessageSendParams(message=message)

    task = create_task_obj(send_params)
    assert task.id is not None
    assert task.context_id == message.context_id
    assert task.status.state == TaskState.submitted
    assert len(task.history) == 1
    assert task.history[0] == message


def test_create_task_obj_generates_context_id():
    """Test that create_task_obj generates context_id if not present and uses it for the task."""
    # Message without context_id
    message_no_context_id = Message(
        role=Role.user,
        parts=[Part(root=TextPart(text='test'))],
        message_id='msg-no-ctx',
        task_id='task-from-msg',  # Provide a task_id to differentiate from generated task.id
    )
    send_params = MessageSendParams(message=message_no_context_id)

    # Ensure message.context_id is None initially
    assert send_params.message.context_id is None

    known_task_uuid = uuid.UUID('11111111-1111-1111-1111-111111111111')
    known_context_uuid = uuid.UUID('22222222-2222-2222-2222-222222222222')

    # Patch uuid.uuid4 to return specific UUIDs in sequence
    # The first call will be for message.context_id (if None), the second for task.id.
    with patch(
        'a2a.utils.helpers.uuid4',
        side_effect=[known_context_uuid, known_task_uuid],
    ) as mock_uuid4:
        task = create_task_obj(send_params)

    # Assert that uuid4 was called twice (once for context_id, once for task.id)
    assert mock_uuid4.call_count == 2

    # Assert that message.context_id was set to the first generated UUID
    assert send_params.message.context_id == str(known_context_uuid)

    # Assert that task.context_id is the same generated UUID
    assert task.context_id == str(known_context_uuid)

    # Assert that task.id is the second generated UUID
    assert task.id == str(known_task_uuid)

    # Ensure the original message in history also has the updated context_id
    assert len(task.history) == 1
    assert task.history[0].context_id == str(known_context_uuid)


# Test append_artifact_to_task
def test_append_artifact_to_task():
    # Prepare base task
    task = Task(**MINIMAL_TASK)
    assert task.id == 'task-abc'
    assert task.context_id == 'session-xyz'
    assert task.status.state == TaskState.submitted
    assert task.history is None
    assert task.artifacts is None
    assert task.metadata is None

    # Prepare appending artifact and event
    artifact_1 = Artifact(
        artifact_id='artifact-123', parts=[Part(root=TextPart(text='Hello'))]
    )
    append_event_1 = TaskArtifactUpdateEvent(
        artifact=artifact_1, append=False, task_id='123', context_id='123'
    )

    # Test adding a new artifact (not appending)
    append_artifact_to_task(task, append_event_1)
    assert len(task.artifacts) == 1
    assert task.artifacts[0].artifact_id == 'artifact-123'
    assert task.artifacts[0].name is None
    assert len(task.artifacts[0].parts) == 1
    assert task.artifacts[0].parts[0].root.text == 'Hello'

    # Test replacing the artifact
    artifact_2 = Artifact(
        artifact_id='artifact-123',
        name='updated name',
        parts=[Part(root=TextPart(text='Updated'))],
    )
    append_event_2 = TaskArtifactUpdateEvent(
        artifact=artifact_2, append=False, task_id='123', context_id='123'
    )
    append_artifact_to_task(task, append_event_2)
    assert len(task.artifacts) == 1  # Should still have one artifact
    assert task.artifacts[0].artifact_id == 'artifact-123'
    assert task.artifacts[0].name == 'updated name'
    assert len(task.artifacts[0].parts) == 1
    assert task.artifacts[0].parts[0].root.text == 'Updated'

    # Test appending parts to an existing artifact
    artifact_with_parts = Artifact(
        artifact_id='artifact-123', parts=[Part(root=TextPart(text='Part 2'))]
    )
    append_event_3 = TaskArtifactUpdateEvent(
        artifact=artifact_with_parts,
        append=True,
        task_id='123',
        context_id='123',
    )
    append_artifact_to_task(task, append_event_3)
    assert len(task.artifacts[0].parts) == 2
    assert task.artifacts[0].parts[0].root.text == 'Updated'
    assert task.artifacts[0].parts[1].root.text == 'Part 2'

    # Test adding another new artifact
    another_artifact_with_parts = Artifact(
        artifact_id='new_artifact',
        parts=[Part(root=TextPart(text='new artifact Part 1'))],
    )
    append_event_4 = TaskArtifactUpdateEvent(
        artifact=another_artifact_with_parts,
        append=False,
        task_id='123',
        context_id='123',
    )
    append_artifact_to_task(task, append_event_4)
    assert len(task.artifacts) == 2
    assert task.artifacts[0].artifact_id == 'artifact-123'
    assert task.artifacts[1].artifact_id == 'new_artifact'
    assert len(task.artifacts[0].parts) == 2
    assert len(task.artifacts[1].parts) == 1

    # Test appending part to a task that does not have a matching artifact
    non_existing_artifact_with_parts = Artifact(
        artifact_id='artifact-456', parts=[Part(root=TextPart(text='Part 1'))]
    )
    append_event_5 = TaskArtifactUpdateEvent(
        artifact=non_existing_artifact_with_parts,
        append=True,
        task_id='123',
        context_id='123',
    )
    append_artifact_to_task(task, append_event_5)
    assert len(task.artifacts) == 2
    assert len(task.artifacts[0].parts) == 2
    assert len(task.artifacts[1].parts) == 1


# Test build_text_artifact
def test_build_text_artifact():
    artifact_id = 'text_artifact'
    text = 'This is a sample text'
    artifact = build_text_artifact(text, artifact_id)

    assert artifact.artifact_id == artifact_id
    assert len(artifact.parts) == 1
    assert artifact.parts[0].root.text == text


# Test validate decorator
def test_validate_decorator():
    class TestClass:
        condition = True

        @validate(lambda self: self.condition, 'Condition not met')
        def test_method(self) -> str:
            return 'Success'

    obj = TestClass()

    # Test passing condition
    assert obj.test_method() == 'Success'

    # Test failing condition
    obj.condition = False
    with pytest.raises(ServerError) as exc_info:
        obj.test_method()
    assert 'Condition not met' in str(exc_info.value)


# Tests for are_modalities_compatible
def test_are_modalities_compatible_client_none():
    assert (
        are_modalities_compatible(
            client_output_modes=None, server_output_modes=['text/plain']
        )
        is True
    )


def test_are_modalities_compatible_client_empty():
    assert (
        are_modalities_compatible(
            client_output_modes=[], server_output_modes=['text/plain']
        )
        is True
    )


def test_are_modalities_compatible_server_none():
    assert (
        are_modalities_compatible(
            server_output_modes=None, client_output_modes=['text/plain']
        )
        is True
    )


def test_are_modalities_compatible_server_empty():
    assert (
        are_modalities_compatible(
            server_output_modes=[], client_output_modes=['text/plain']
        )
        is True
    )


def test_are_modalities_compatible_common_mode():
    assert (
        are_modalities_compatible(
            server_output_modes=['text/plain', 'application/json'],
            client_output_modes=['application/json', 'image/png'],
        )
        is True
    )


def test_are_modalities_compatible_no_common_modes():
    assert (
        are_modalities_compatible(
            server_output_modes=['text/plain'],
            client_output_modes=['application/json'],
        )
        is False
    )


def test_are_modalities_compatible_exact_match():
    assert (
        are_modalities_compatible(
            server_output_modes=['text/plain'],
            client_output_modes=['text/plain'],
        )
        is True
    )


def test_are_modalities_compatible_server_more_but_common():
    assert (
        are_modalities_compatible(
            server_output_modes=['text/plain', 'image/jpeg'],
            client_output_modes=['text/plain'],
        )
        is True
    )


def test_are_modalities_compatible_client_more_but_common():
    assert (
        are_modalities_compatible(
            server_output_modes=['text/plain'],
            client_output_modes=['text/plain', 'image/jpeg'],
        )
        is True
    )


def test_are_modalities_compatible_both_none():
    assert (
        are_modalities_compatible(
            server_output_modes=None, client_output_modes=None
        )
        is True
    )


def test_are_modalities_compatible_both_empty():
    assert (
        are_modalities_compatible(
            server_output_modes=[], client_output_modes=[]
        )
        is True
    )



---
File: /a2a-python/tests/utils/test_message.py
---

import uuid

from unittest.mock import patch

from a2a.types import (
    DataPart,
    FilePart,
    FileWithBytes,
    FileWithUri,
    Message,
    Part,
    Role,
    TextPart,
)
from a2a.utils.message import (
    get_data_parts,
    get_file_parts,
    get_message_text,
    get_text_parts,
    new_agent_parts_message,
    new_agent_text_message,
)


class TestNewAgentTextMessage:
    def test_new_agent_text_message_basic(self):
        # Setup
        text = "Hello, I'm an agent"

        # Exercise - with a fixed uuid for testing
        with patch(
            'uuid.uuid4',
            return_value=uuid.UUID('12345678-1234-5678-1234-567812345678'),
        ):
            message = new_agent_text_message(text)

        # Verify
        assert message.role == Role.agent
        assert len(message.parts) == 1
        assert message.parts[0].root.text == text
        assert message.message_id == '12345678-1234-5678-1234-567812345678'
        assert message.task_id is None
        assert message.context_id is None

    def test_new_agent_text_message_with_context_id(self):
        # Setup
        text = 'Message with context'
        context_id = 'test-context-id'

        # Exercise
        with patch(
            'uuid.uuid4',
            return_value=uuid.UUID('12345678-1234-5678-1234-567812345678'),
        ):
            message = new_agent_text_message(text, context_id=context_id)

        # Verify
        assert message.role == Role.agent
        assert message.parts[0].root.text == text
        assert message.message_id == '12345678-1234-5678-1234-567812345678'
        assert message.context_id == context_id
        assert message.task_id is None

    def test_new_agent_text_message_with_task_id(self):
        # Setup
        text = 'Message with task id'
        task_id = 'test-task-id'

        # Exercise
        with patch(
            'uuid.uuid4',
            return_value=uuid.UUID('12345678-1234-5678-1234-567812345678'),
        ):
            message = new_agent_text_message(text, task_id=task_id)

        # Verify
        assert message.role == Role.agent
        assert message.parts[0].root.text == text
        assert message.message_id == '12345678-1234-5678-1234-567812345678'
        assert message.task_id == task_id
        assert message.context_id is None

    def test_new_agent_text_message_with_both_ids(self):
        # Setup
        text = 'Message with both ids'
        context_id = 'test-context-id'
        task_id = 'test-task-id'

        # Exercise
        with patch(
            'uuid.uuid4',
            return_value=uuid.UUID('12345678-1234-5678-1234-567812345678'),
        ):
            message = new_agent_text_message(
                text, context_id=context_id, task_id=task_id
            )

        # Verify
        assert message.role == Role.agent
        assert message.parts[0].root.text == text
        assert message.message_id == '12345678-1234-5678-1234-567812345678'
        assert message.context_id == context_id
        assert message.task_id == task_id

    def test_new_agent_text_message_empty_text(self):
        # Setup
        text = ''

        # Exercise
        with patch(
            'uuid.uuid4',
            return_value=uuid.UUID('12345678-1234-5678-1234-567812345678'),
        ):
            message = new_agent_text_message(text)

        # Verify
        assert message.role == Role.agent
        assert message.parts[0].root.text == ''
        assert message.message_id == '12345678-1234-5678-1234-567812345678'


class TestNewAgentPartsMessage:
    def test_new_agent_parts_message(self):
        """Test creating an agent message with multiple, mixed parts."""
        # Setup
        parts = [
            Part(root=TextPart(text='Here is some text.')),
            Part(root=DataPart(data={'product_id': 123, 'quantity': 2})),
        ]
        context_id = 'ctx-multi-part'
        task_id = 'task-multi-part'

        # Exercise
        with patch(
            'uuid.uuid4',
            return_value=uuid.UUID('abcdefab-cdef-abcd-efab-cdefabcdefab'),
        ):
            message = new_agent_parts_message(
                parts, context_id=context_id, task_id=task_id
            )

        # Verify
        assert message.role == Role.agent
        assert message.parts == parts
        assert message.context_id == context_id
        assert message.task_id == task_id
        assert message.message_id == 'abcdefab-cdef-abcd-efab-cdefabcdefab'


class TestGetTextParts:
    def test_get_text_parts_single_text_part(self):
        # Setup
        parts = [Part(root=TextPart(text='Hello world'))]

        # Exercise
        result = get_text_parts(parts)

        # Verify
        assert result == ['Hello world']

    def test_get_text_parts_multiple_text_parts(self):
        # Setup
        parts = [
            Part(root=TextPart(text='First part')),
            Part(root=TextPart(text='Second part')),
            Part(root=TextPart(text='Third part')),
        ]

        # Exercise
        result = get_text_parts(parts)

        # Verify
        assert result == ['First part', 'Second part', 'Third part']

    def test_get_text_parts_empty_list(self):
        # Setup
        parts = []

        # Exercise
        result = get_text_parts(parts)

        # Verify
        assert result == []


class TestGetDataParts:
    def test_get_data_parts_single_data_part(self):
        # Setup
        parts = [Part(root=DataPart(data={'key': 'value'}))]

        # Exercise
        result = get_data_parts(parts)

        # Verify
        assert result == [{'key': 'value'}]

    def test_get_data_parts_multiple_data_parts(self):
        # Setup
        parts = [
            Part(root=DataPart(data={'key1': 'value1'})),
            Part(root=DataPart(data={'key2': 'value2'})),
        ]

        # Exercise
        result = get_data_parts(parts)

        # Verify
        assert result == [{'key1': 'value1'}, {'key2': 'value2'}]

    def test_get_data_parts_mixed_parts(self):
        # Setup
        parts = [
            Part(root=TextPart(text='some text')),
            Part(root=DataPart(data={'key1': 'value1'})),
            Part(root=DataPart(data={'key2': 'value2'})),
        ]

        # Exercise
        result = get_data_parts(parts)

        # Verify
        assert result == [{'key1': 'value1'}, {'key2': 'value2'}]

    def test_get_data_parts_no_data_parts(self):
        # Setup
        parts = [
            Part(root=TextPart(text='some text')),
        ]

        # Exercise
        result = get_data_parts(parts)

        # Verify
        assert result == []

    def test_get_data_parts_empty_list(self):
        # Setup
        parts = []

        # Exercise
        result = get_data_parts(parts)

        # Verify
        assert result == []


class TestGetFileParts:
    def test_get_file_parts_single_file_part(self):
        # Setup
        file_with_uri = FileWithUri(
            uri='file://path/to/file', mimeType='text/plain'
        )
        parts = [Part(root=FilePart(file=file_with_uri))]

        # Exercise
        result = get_file_parts(parts)

        # Verify
        assert result == [file_with_uri]

    def test_get_file_parts_multiple_file_parts(self):
        # Setup
        file_with_uri1 = FileWithUri(
            uri='file://path/to/file1', mime_type='text/plain'
        )
        file_with_bytes = FileWithBytes(
            bytes='ZmlsZSBjb250ZW50',
            mime_type='application/octet-stream',  # 'file content'
        )
        parts = [
            Part(root=FilePart(file=file_with_uri1)),
            Part(root=FilePart(file=file_with_bytes)),
        ]

        # Exercise
        result = get_file_parts(parts)

        # Verify
        assert result == [file_with_uri1, file_with_bytes]

    def test_get_file_parts_mixed_parts(self):
        # Setup
        file_with_uri = FileWithUri(
            uri='file://path/to/file', mime_type='text/plain'
        )
        parts = [
            Part(root=TextPart(text='some text')),
            Part(root=FilePart(file=file_with_uri)),
        ]

        # Exercise
        result = get_file_parts(parts)

        # Verify
        assert result == [file_with_uri]

    def test_get_file_parts_no_file_parts(self):
        # Setup
        parts = [
            Part(root=TextPart(text='some text')),
            Part(root=DataPart(data={'key': 'value'})),
        ]

        # Exercise
        result = get_file_parts(parts)

        # Verify
        assert result == []

    def test_get_file_parts_empty_list(self):
        # Setup
        parts = []

        # Exercise
        result = get_file_parts(parts)

        # Verify
        assert result == []


class TestGetMessageText:
    def test_get_message_text_single_part(self):
        # Setup
        message = Message(
            role=Role.agent,
            parts=[Part(root=TextPart(text='Hello world'))],
            message_id='test-message-id',
        )

        # Exercise
        result = get_message_text(message)

        # Verify
        assert result == 'Hello world'

    def test_get_message_text_multiple_parts(self):
        # Setup
        message = Message(
            role=Role.agent,
            parts=[
                Part(root=TextPart(text='First line')),
                Part(root=TextPart(text='Second line')),
                Part(root=TextPart(text='Third line')),
            ],
            message_id='test-message-id',
        )

        # Exercise
        result = get_message_text(message)

        # Verify - default delimiter is newline
        assert result == 'First line\nSecond line\nThird line'

    def test_get_message_text_custom_delimiter(self):
        # Setup
        message = Message(
            role=Role.agent,
            parts=[
                Part(root=TextPart(text='First part')),
                Part(root=TextPart(text='Second part')),
                Part(root=TextPart(text='Third part')),
            ],
            message_id='test-message-id',
        )

        # Exercise
        result = get_message_text(message, delimiter=' | ')

        # Verify
        assert result == 'First part | Second part | Third part'

    def test_get_message_text_empty_parts(self):
        # Setup
        message = Message(
            role=Role.agent,
            parts=[],
            message_id='test-message-id',
        )

        # Exercise
        result = get_message_text(message)

        # Verify
        assert result == ''



---
File: /a2a-python/tests/utils/test_proto_utils.py
---

from unittest import mock

import pytest

from a2a import types
from a2a.grpc import a2a_pb2
from a2a.utils import proto_utils
from a2a.utils.errors import ServerError


# --- Test Data ---


@pytest.fixture
def sample_message() -> types.Message:
    return types.Message(
        message_id='msg-1',
        context_id='ctx-1',
        task_id='task-1',
        role=types.Role.user,
        parts=[
            types.Part(root=types.TextPart(text='Hello')),
            types.Part(
                root=types.FilePart(
                    file=types.FileWithUri(uri='file:///test.txt')
                )
            ),
            types.Part(root=types.DataPart(data={'key': 'value'})),
        ],
        metadata={'source': 'test'},
    )


@pytest.fixture
def sample_task(sample_message: types.Message) -> types.Task:
    return types.Task(
        id='task-1',
        context_id='ctx-1',
        status=types.TaskStatus(
            state=types.TaskState.working, message=sample_message
        ),
        history=[sample_message],
        artifacts=[
            types.Artifact(
                artifact_id='art-1',
                parts=[
                    types.Part(root=types.TextPart(text='Artifact content'))
                ],
            )
        ],
    )


@pytest.fixture
def sample_agent_card() -> types.AgentCard:
    return types.AgentCard(
        name='Test Agent',
        description='A test agent',
        url='http://localhost',
        version='1.0.0',
        capabilities=types.AgentCapabilities(
            streaming=True, push_notifications=True
        ),
        default_input_modes=['text/plain'],
        default_output_modes=['text/plain'],
        skills=[
            types.AgentSkill(
                id='skill1',
                name='Test Skill',
                description='A test skill',
                tags=['test'],
            )
        ],
        provider=types.AgentProvider(
            organization='Test Org', url='http://test.org'
        ),
        security=[{'oauth_scheme': ['read', 'write']}],
        security_schemes={
            'oauth_scheme': types.SecurityScheme(
                root=types.OAuth2SecurityScheme(
                    flows=types.OAuthFlows(
                        client_credentials=types.ClientCredentialsOAuthFlow(
                            token_url='http://token.url',
                            scopes={
                                'read': 'Read access',
                                'write': 'Write access',
                            },
                        )
                    )
                )
            ),
            'apiKey': types.SecurityScheme(
                root=types.APIKeySecurityScheme(
                    name='X-API-KEY', in_=types.In.header
                )
            ),
            'httpAuth': types.SecurityScheme(
                root=types.HTTPAuthSecurityScheme(scheme='bearer')
            ),
            'oidc': types.SecurityScheme(
                root=types.OpenIdConnectSecurityScheme(
                    open_id_connect_url='http://oidc.url'
                )
            ),
        },
    )


# --- Test Cases ---


class TestToProto:
    def test_part_unsupported_type(self):
        """Test that ToProto.part raises ValueError for an unsupported Part type."""

        class FakePartType:
            kind = 'fake'

        # Create a mock Part object that has a .root attribute pointing to the fake type
        mock_part = mock.MagicMock(spec=types.Part)
        mock_part.root = FakePartType()

        with pytest.raises(ValueError, match='Unsupported part type'):
            proto_utils.ToProto.part(mock_part)


class TestFromProto:
    def test_part_unsupported_type(self):
        """Test that FromProto.part raises ValueError for an unsupported part type in proto."""
        unsupported_proto_part = (
            a2a_pb2.Part()
        )  # An empty part with no oneof field set
        with pytest.raises(ValueError, match='Unsupported part type'):
            proto_utils.FromProto.part(unsupported_proto_part)

    def test_task_query_params_invalid_name(self):
        request = a2a_pb2.GetTaskRequest(name='invalid-name-format')
        with pytest.raises(ServerError) as exc_info:
            proto_utils.FromProto.task_query_params(request)
        assert isinstance(exc_info.value.error, types.InvalidParamsError)


class TestProtoUtils:
    def test_roundtrip_message(self, sample_message: types.Message):
        """Test conversion of Message to proto and back."""
        proto_msg = proto_utils.ToProto.message(sample_message)
        assert isinstance(proto_msg, a2a_pb2.Message)

        # Test file part handling
        assert proto_msg.content[1].file.file_with_uri == 'file:///test.txt'

        roundtrip_msg = proto_utils.FromProto.message(proto_msg)
        assert roundtrip_msg == sample_message

    def test_enum_conversions(self):
        """Test conversions for all enum types."""
        assert (
            proto_utils.ToProto.role(types.Role.agent)
            == a2a_pb2.Role.ROLE_AGENT
        )
        assert (
            proto_utils.FromProto.role(a2a_pb2.Role.ROLE_USER)
            == types.Role.user
        )

        for state in types.TaskState:
            if state not in (
                types.TaskState.unknown,
                types.TaskState.rejected,
                types.TaskState.auth_required,
            ):
                proto_state = proto_utils.ToProto.task_state(state)
                assert proto_utils.FromProto.task_state(proto_state) == state

        # Test unknown state case
        assert (
            proto_utils.FromProto.task_state(
                a2a_pb2.TaskState.TASK_STATE_UNSPECIFIED
            )
            == types.TaskState.unknown
        )
        assert (
            proto_utils.ToProto.task_state(types.TaskState.unknown)
            == a2a_pb2.TaskState.TASK_STATE_UNSPECIFIED
        )

    def test_oauth_flows_conversion(self):
        """Test conversion of different OAuth2 flows."""
        # Test password flow
        password_flow = types.OAuthFlows(
            password=types.PasswordOAuthFlow(
                token_url='http://token.url', scopes={'read': 'Read'}
            )
        )
        proto_password_flow = proto_utils.ToProto.oauth2_flows(password_flow)
        assert proto_password_flow.HasField('password')

        # Test implicit flow
        implicit_flow = types.OAuthFlows(
            implicit=types.ImplicitOAuthFlow(
                authorization_url='http://auth.url', scopes={'read': 'Read'}
            )
        )
        proto_implicit_flow = proto_utils.ToProto.oauth2_flows(implicit_flow)
        assert proto_implicit_flow.HasField('implicit')

        # Test authorization code flow
        auth_code_flow = types.OAuthFlows(
            authorization_code=types.AuthorizationCodeOAuthFlow(
                authorization_url='http://auth.url',
                token_url='http://token.url',
                scopes={'read': 'read'},
            )
        )
        proto_auth_code_flow = proto_utils.ToProto.oauth2_flows(auth_code_flow)
        assert proto_auth_code_flow.HasField('authorization_code')

        # Test invalid flow
        with pytest.raises(ValueError):
            proto_utils.ToProto.oauth2_flows(types.OAuthFlows())

        # Test FromProto
        roundtrip_password = proto_utils.FromProto.oauth2_flows(
            proto_password_flow
        )
        assert roundtrip_password.password is not None

        roundtrip_implicit = proto_utils.FromProto.oauth2_flows(
            proto_implicit_flow
        )
        assert roundtrip_implicit.implicit is not None

    def test_task_id_params_from_proto_invalid_name(self):
        request = a2a_pb2.CancelTaskRequest(name='invalid-name-format')
        with pytest.raises(ServerError) as exc_info:
            proto_utils.FromProto.task_id_params(request)
        assert isinstance(exc_info.value.error, types.InvalidParamsError)

    def test_task_push_config_from_proto_invalid_parent(self):
        request = a2a_pb2.TaskPushNotificationConfig(name='invalid-name-format')
        with pytest.raises(ServerError) as exc_info:
            proto_utils.FromProto.task_push_notification_config(request)
        assert isinstance(exc_info.value.error, types.InvalidParamsError)

    def test_none_handling(self):
        """Test that None inputs are handled gracefully."""
        assert proto_utils.ToProto.message(None) is None
        assert proto_utils.ToProto.metadata(None) is None
        assert proto_utils.ToProto.provider(None) is None
        assert proto_utils.ToProto.security(None) is None
        assert proto_utils.ToProto.security_schemes(None) is None



---
File: /a2a-python/tests/utils/test_task.py
---

import unittest
import uuid

from unittest.mock import patch

import pytest

from a2a.types import Artifact, Message, Part, Role, TextPart
from a2a.utils.task import completed_task, new_task


class TestTask(unittest.TestCase):
    def test_new_task_status(self):
        message = Message(
            role=Role.user,
            parts=[Part(root=TextPart(text='test message'))],
            message_id=str(uuid.uuid4()),
        )
        task = new_task(message)
        self.assertEqual(task.status.state.value, 'submitted')

    @patch('uuid.uuid4')
    def test_new_task_generates_ids(self, mock_uuid4):
        mock_uuid = uuid.UUID('12345678-1234-5678-1234-567812345678')
        mock_uuid4.return_value = mock_uuid
        message = Message(
            role=Role.user,
            parts=[Part(root=TextPart(text='test message'))],
            message_id=str(uuid.uuid4()),
        )
        task = new_task(message)
        self.assertEqual(task.id, str(mock_uuid))
        self.assertEqual(task.context_id, str(mock_uuid))

    def test_new_task_uses_provided_ids(self):
        task_id = str(uuid.uuid4())
        context_id = str(uuid.uuid4())
        message = Message(
            role=Role.user,
            parts=[Part(root=TextPart(text='test message'))],
            message_id=str(uuid.uuid4()),
            task_id=task_id,
            context_id=context_id,
        )
        task = new_task(message)
        self.assertEqual(task.id, task_id)
        self.assertEqual(task.context_id, context_id)

    def test_new_task_initial_message_in_history(self):
        message = Message(
            role=Role.user,
            parts=[Part(root=TextPart(text='test message'))],
            message_id=str(uuid.uuid4()),
        )
        task = new_task(message)
        self.assertEqual(len(task.history), 1)
        self.assertEqual(task.history[0], message)

    def test_completed_task_status(self):
        task_id = str(uuid.uuid4())
        context_id = str(uuid.uuid4())
        artifacts = [
            Artifact(
                artifact_id='artifact_1',
                parts=[Part(root=TextPart(text='some content'))],
            )
        ]
        task = completed_task(
            task_id=task_id,
            context_id=context_id,
            artifacts=artifacts,
            history=[],
        )
        self.assertEqual(task.status.state.value, 'completed')

    def test_completed_task_assigns_ids_and_artifacts(self):
        task_id = str(uuid.uuid4())
        context_id = str(uuid.uuid4())
        artifacts = [
            Artifact(
                artifact_id='artifact_1',
                parts=[Part(root=TextPart(text='some content'))],
            )
        ]
        task = completed_task(
            task_id=task_id,
            context_id=context_id,
            artifacts=artifacts,
            history=[],
        )
        self.assertEqual(task.id, task_id)
        self.assertEqual(task.context_id, context_id)
        self.assertEqual(task.artifacts, artifacts)

    def test_completed_task_empty_history_if_not_provided(self):
        task_id = str(uuid.uuid4())
        context_id = str(uuid.uuid4())
        artifacts = [
            Artifact(
                artifact_id='artifact_1',
                parts=[Part(root=TextPart(text='some content'))],
            )
        ]
        task = completed_task(
            task_id=task_id, context_id=context_id, artifacts=artifacts
        )
        self.assertEqual(task.history, [])

    def test_completed_task_uses_provided_history(self):
        task_id = str(uuid.uuid4())
        context_id = str(uuid.uuid4())
        artifacts = [
            Artifact(
                artifact_id='artifact_1',
                parts=[Part(root=TextPart(text='some content'))],
            )
        ]
        history = [
            Message(
                role=Role.user,
                parts=[Part(root=TextPart(text='Hello'))],
                message_id=str(uuid.uuid4()),
            ),
            Message(
                role=Role.agent,
                parts=[Part(root=TextPart(text='Hi there'))],
                message_id=str(uuid.uuid4()),
            ),
        ]
        task = completed_task(
            task_id=task_id,
            context_id=context_id,
            artifacts=artifacts,
            history=history,
        )
        self.assertEqual(task.history, history)

    def test_new_task_invalid_message_empty_parts(self):
        with self.assertRaises(ValueError):
            new_task(
                Message(
                    role=Role.user,
                    parts=[],
                    message_id=str(uuid.uuid4()),
                )
            )

    def test_new_task_invalid_message_empty_content(self):
        with self.assertRaises(ValueError):
            new_task(
                Message(
                    role=Role.user,
                    parts=[Part(root=TextPart(text=''))],
                    messageId=str(uuid.uuid4()),
                )
            )

    def test_new_task_invalid_message_none_role(self):
        with self.assertRaises(TypeError):
            msg = Message.model_construct(
                role=None,
                parts=[Part(root=TextPart(text='test message'))],
                message_id=str(uuid.uuid4()),
            )
            new_task(msg)

    def test_completed_task_empty_artifacts(self):
        with pytest.raises(
            ValueError,
            match='artifacts must be a non-empty list of Artifact objects',
        ):
            completed_task(
                task_id='task-123',
                context_id='ctx-456',
                artifacts=[],
                history=[],
            )

    def test_completed_task_invalid_artifact_type(self):
        with pytest.raises(
            ValueError,
            match='artifacts must be a non-empty list of Artifact objects',
        ):
            completed_task(
                task_id='task-123',
                context_id='ctx-456',
                artifacts=['not an artifact'],
                history=[],
            )

    def test_new_task_with_invalid_context_id(self):
        """Test that new_task raises a ValueError for various invalid context_id formats."""
        invalid_ids = ['not-a-uuid', '']
        for invalid_id in invalid_ids:
            with self.subTest(invalid_id=invalid_id):
                with pytest.raises(
                    ValueError,
                    match=f"Invalid context_id: '{invalid_id}' is not a valid UUID.",
                ):
                    new_task(
                        Message(
                            role=Role.user,
                            parts=[Part(root=TextPart(text='test message'))],
                            message_id=str(uuid.uuid4()),
                            context_id=invalid_id,
                        )
                    )


if __name__ == '__main__':
    unittest.main()



---
File: /a2a-python/tests/utils/test_telemetry.py
---

import asyncio

from typing import NoReturn
from unittest import mock

import pytest

from a2a.utils.telemetry import trace_class, trace_function


@pytest.fixture
def mock_span():
    return mock.MagicMock()


@pytest.fixture
def mock_tracer(mock_span):
    tracer = mock.MagicMock()
    tracer.start_as_current_span.return_value.__enter__.return_value = mock_span
    tracer.start_as_current_span.return_value.__exit__.return_value = False
    return tracer


@pytest.fixture(autouse=True)
def patch_trace_get_tracer(mock_tracer):
    with mock.patch('opentelemetry.trace.get_tracer', return_value=mock_tracer):
        yield


def test_trace_function_sync_success(mock_span):
    @trace_function
    def foo(x, y):
        return x + y

    result = foo(2, 3)
    assert result == 5
    mock_span.set_status.assert_called()
    mock_span.set_status.assert_any_call(mock.ANY)
    mock_span.record_exception.assert_not_called()


def test_trace_function_sync_exception(mock_span):
    @trace_function
    def bar() -> NoReturn:
        raise ValueError('fail')

    with pytest.raises(ValueError):
        bar()
    mock_span.record_exception.assert_called()
    mock_span.set_status.assert_any_call(mock.ANY, description='fail')


def test_trace_function_sync_attribute_extractor_called(mock_span):
    called = {}

    def attr_extractor(span, args, kwargs, result, exception) -> None:
        called['called'] = True
        assert span is mock_span
        assert exception is None
        assert result == 42

    @trace_function(attribute_extractor=attr_extractor)
    def foo() -> int:
        return 42

    foo()
    assert called['called']


def test_trace_function_sync_attribute_extractor_error_logged(mock_span):
    with mock.patch('a2a.utils.telemetry.logger') as logger:

        def attr_extractor(span, args, kwargs, result, exception) -> NoReturn:
            raise RuntimeError('attr fail')

        @trace_function(attribute_extractor=attr_extractor)
        def foo() -> int:
            return 1

        foo()
        logger.exception.assert_any_call(mock.ANY)


@pytest.mark.asyncio
async def test_trace_function_async_success(mock_span):
    @trace_function
    async def foo(x):
        await asyncio.sleep(0)
        return x * 2

    result = await foo(4)
    assert result == 8
    mock_span.set_status.assert_called()
    mock_span.record_exception.assert_not_called()


@pytest.mark.asyncio
async def test_trace_function_async_exception(mock_span):
    @trace_function
    async def bar() -> NoReturn:
        await asyncio.sleep(0)
        raise RuntimeError('async fail')

    with pytest.raises(RuntimeError):
        await bar()
    mock_span.record_exception.assert_called()
    mock_span.set_status.assert_any_call(mock.ANY, description='async fail')


@pytest.mark.asyncio
async def test_trace_function_async_attribute_extractor_called(mock_span):
    called = {}

    def attr_extractor(span, args, kwargs, result, exception) -> None:
        called['called'] = True
        assert exception is None
        assert result == 99

    @trace_function(attribute_extractor=attr_extractor)
    async def foo() -> int:
        return 99

    await foo()
    assert called['called']


def test_trace_function_with_args_and_attributes(mock_span):
    @trace_function(span_name='custom.span', attributes={'foo': 'bar'})
    def foo() -> int:
        return 1

    foo()
    mock_span.set_attribute.assert_any_call('foo', 'bar')


def test_trace_class_exclude_list(mock_span):
    @trace_class(exclude_list=['skip_me'])
    class MyClass:
        def a(self) -> str:
            return 'a'

        def skip_me(self) -> str:
            return 'skip'

        def __str__(self):
            return 'str'

    obj = MyClass()
    assert obj.a() == 'a'
    assert obj.skip_me() == 'skip'
    # Only 'a' is traced, not 'skip_me' or dunder
    assert hasattr(obj.a, '__wrapped__')
    assert not hasattr(obj.skip_me, '__wrapped__')


def test_trace_class_include_list(mock_span):
    @trace_class(include_list=['only_this'])
    class MyClass:
        def only_this(self) -> str:
            return 'yes'

        def not_this(self) -> str:
            return 'no'

    obj = MyClass()
    assert obj.only_this() == 'yes'
    assert obj.not_this() == 'no'
    assert hasattr(obj.only_this, '__wrapped__')
    assert not hasattr(obj.not_this, '__wrapped__')


def test_trace_class_dunder_not_traced(mock_span):
    @trace_class()
    class MyClass:
        def __init__(self):
            self.x = 1

        def foo(self) -> str:
            return 'foo'

    obj = MyClass()
    assert obj.foo() == 'foo'
    assert hasattr(obj.foo, '__wrapped__')
    assert hasattr(obj, 'x')



---
File: /a2a-python/tests/test_types.py
---

from typing import Any

import pytest

from pydantic import ValidationError

from a2a.types import (
    A2AError,
    A2ARequest,
    APIKeySecurityScheme,
    AgentCapabilities,
    AgentCard,
    AgentProvider,
    AgentSkill,
    Artifact,
    CancelTaskRequest,
    CancelTaskResponse,
    CancelTaskSuccessResponse,
    ContentTypeNotSupportedError,
    DataPart,
    FileBase,
    FilePart,
    FileWithBytes,
    FileWithUri,
    GetAuthenticatedExtendedCardRequest,
    GetAuthenticatedExtendedCardResponse,
    GetAuthenticatedExtendedCardSuccessResponse,
    GetTaskPushNotificationConfigParams,
    GetTaskPushNotificationConfigRequest,
    GetTaskPushNotificationConfigResponse,
    GetTaskPushNotificationConfigSuccessResponse,
    GetTaskRequest,
    GetTaskResponse,
    GetTaskSuccessResponse,
    In,
    InternalError,
    InvalidParamsError,
    InvalidRequestError,
    JSONParseError,
    JSONRPCError,
    JSONRPCErrorResponse,
    JSONRPCMessage,
    JSONRPCRequest,
    JSONRPCResponse,
    Message,
    MessageSendParams,
    MethodNotFoundError,
    OAuth2SecurityScheme,
    Part,
    PartBase,
    PushNotificationAuthenticationInfo,
    PushNotificationConfig,
    PushNotificationNotSupportedError,
    Role,
    SecurityScheme,
    SendMessageRequest,
    SendMessageResponse,
    SendMessageSuccessResponse,
    SendStreamingMessageRequest,
    SendStreamingMessageResponse,
    SendStreamingMessageSuccessResponse,
    SetTaskPushNotificationConfigRequest,
    SetTaskPushNotificationConfigResponse,
    SetTaskPushNotificationConfigSuccessResponse,
    Task,
    TaskArtifactUpdateEvent,
    TaskIdParams,
    TaskNotCancelableError,
    TaskNotFoundError,
    TaskPushNotificationConfig,
    TaskQueryParams,
    TaskResubscriptionRequest,
    TaskState,
    TaskStatus,
    TaskStatusUpdateEvent,
    TextPart,
    UnsupportedOperationError,
)


# --- Helper Data ---

MINIMAL_AGENT_SECURITY_SCHEME: dict[str, Any] = {
    'type': 'apiKey',
    'in': 'header',
    'name': 'X-API-KEY',
}

MINIMAL_AGENT_SKILL: dict[str, Any] = {
    'id': 'skill-123',
    'name': 'Recipe Finder',
    'description': 'Finds recipes',
    'tags': ['cooking'],
}
FULL_AGENT_SKILL: dict[str, Any] = {
    'id': 'skill-123',
    'name': 'Recipe Finder',
    'description': 'Finds recipes',
    'tags': ['cooking', 'food'],
    'examples': ['Find me a pasta recipe'],
    'inputModes': ['text/plain'],
    'outputModes': ['application/json'],
}

MINIMAL_AGENT_CARD: dict[str, Any] = {
    'capabilities': {},  # AgentCapabilities is required but can be empty
    'defaultInputModes': ['text/plain'],
    'defaultOutputModes': ['application/json'],
    'description': 'Test Agent',
    'name': 'TestAgent',
    'skills': [MINIMAL_AGENT_SKILL],
    'url': 'http://example.com/agent',
    'version': '1.0',
}

TEXT_PART_DATA: dict[str, Any] = {'kind': 'text', 'text': 'Hello'}
FILE_URI_PART_DATA: dict[str, Any] = {
    'kind': 'file',
    'file': {'uri': 'file:///path/to/file.txt', 'mimeType': 'text/plain'},
}
FILE_BYTES_PART_DATA: dict[str, Any] = {
    'kind': 'file',
    'file': {'bytes': 'aGVsbG8=', 'name': 'hello.txt'},  # base64 for "hello"
}
DATA_PART_DATA: dict[str, Any] = {'kind': 'data', 'data': {'key': 'value'}}

MINIMAL_MESSAGE_USER: dict[str, Any] = {
    'role': 'user',
    'parts': [TEXT_PART_DATA],
    'message_id': 'msg-123',
    'kind': 'message',
}

AGENT_MESSAGE_WITH_FILE: dict[str, Any] = {
    'role': 'agent',
    'parts': [TEXT_PART_DATA, FILE_URI_PART_DATA],
    'metadata': {'timestamp': 'now'},
    'message_id': 'msg-456',
}

MINIMAL_TASK_STATUS: dict[str, Any] = {'state': 'submitted'}
FULL_TASK_STATUS: dict[str, Any] = {
    'state': 'working',
    'message': MINIMAL_MESSAGE_USER,
    'timestamp': '2023-10-27T10:00:00Z',
}

MINIMAL_TASK: dict[str, Any] = {
    'id': 'task-abc',
    'context_id': 'session-xyz',
    'status': MINIMAL_TASK_STATUS,
    'kind': 'task',
}
FULL_TASK: dict[str, Any] = {
    'id': 'task-abc',
    'context_id': 'session-xyz',
    'status': FULL_TASK_STATUS,
    'history': [MINIMAL_MESSAGE_USER, AGENT_MESSAGE_WITH_FILE],
    'artifacts': [
        {
            'artifactId': 'artifact-123',
            'parts': [DATA_PART_DATA],
            'name': 'result_data',
        }
    ],
    'metadata': {'priority': 'high'},
    'kind': 'task',
}

MINIMAL_TASK_ID_PARAMS: dict[str, Any] = {'id': 'task-123'}
FULL_TASK_ID_PARAMS: dict[str, Any] = {
    'id': 'task-456',
    'metadata': {'source': 'test'},
}

JSONRPC_ERROR_DATA: dict[str, Any] = {
    'code': -32600,
    'message': 'Invalid Request',
}
JSONRPC_SUCCESS_RESULT: dict[str, Any] = {'status': 'ok', 'data': [1, 2, 3]}

# --- Test Functions ---


def test_security_scheme_valid():
    scheme = SecurityScheme.model_validate(MINIMAL_AGENT_SECURITY_SCHEME)
    assert isinstance(scheme.root, APIKeySecurityScheme)
    assert scheme.root.type == 'apiKey'
    assert scheme.root.in_ == In.header
    assert scheme.root.name == 'X-API-KEY'


def test_security_scheme_invalid():
    with pytest.raises(ValidationError):
        APIKeySecurityScheme(
            name='my_api_key',
        )  # Missing "in"  # type: ignore

    with pytest.raises(ValidationError):
        OAuth2SecurityScheme(
            description='OAuth2 scheme missing flows',
        )  # Missing "flows"  # type: ignore


def test_agent_capabilities():
    caps = AgentCapabilities(
        streaming=None, state_transition_history=None, push_notifications=None
    )  # All optional
    assert caps.push_notifications is None
    assert caps.state_transition_history is None
    assert caps.streaming is None

    caps_full = AgentCapabilities(
        push_notifications=True, state_transition_history=False, streaming=True
    )
    assert caps_full.push_notifications is True
    assert caps_full.state_transition_history is False
    assert caps_full.streaming is True


def test_agent_provider():
    provider = AgentProvider(organization='Test Org', url='http://test.org')
    assert provider.organization == 'Test Org'
    assert provider.url == 'http://test.org'

    with pytest.raises(ValidationError):
        AgentProvider(organization='Test Org')  # Missing url  # type: ignore


def test_agent_skill_valid():
    skill = AgentSkill(**MINIMAL_AGENT_SKILL)
    assert skill.id == 'skill-123'
    assert skill.name == 'Recipe Finder'
    assert skill.description == 'Finds recipes'
    assert skill.tags == ['cooking']
    assert skill.examples is None

    skill_full = AgentSkill(**FULL_AGENT_SKILL)
    assert skill_full.examples == ['Find me a pasta recipe']
    assert skill_full.input_modes == ['text/plain']


def test_agent_skill_invalid():
    with pytest.raises(ValidationError):
        AgentSkill(
            id='abc', name='n', description='d'
        )  # Missing tags  # type: ignore

    AgentSkill(
        **MINIMAL_AGENT_SKILL,
        invalid_extra='foo',  # type: ignore
    )  # Extra field


def test_agent_card_valid():
    card = AgentCard(**MINIMAL_AGENT_CARD)
    assert card.name == 'TestAgent'
    assert card.version == '1.0'
    assert len(card.skills) == 1
    assert card.skills[0].id == 'skill-123'
    assert card.provider is None  # Optional


def test_agent_card_invalid():
    bad_card_data = MINIMAL_AGENT_CARD.copy()
    del bad_card_data['name']
    with pytest.raises(ValidationError):
        AgentCard(**bad_card_data)  # Missing name


# --- Test Parts ---


def test_text_part():
    part = TextPart(**TEXT_PART_DATA)
    assert part.kind == 'text'
    assert part.text == 'Hello'
    assert part.metadata is None

    with pytest.raises(ValidationError):
        TextPart(type='text')  # Missing text # type: ignore
    with pytest.raises(ValidationError):
        TextPart(
            kind='file',  # type: ignore
            text='hello',
        )  # Wrong type literal


def test_file_part_variants():
    # URI variant
    file_uri = FileWithUri(
        uri='file:///path/to/file.txt', mime_type='text/plain'
    )
    part_uri = FilePart(kind='file', file=file_uri)
    assert isinstance(part_uri.file, FileWithUri)
    assert part_uri.file.uri == 'file:///path/to/file.txt'
    assert part_uri.file.mime_type == 'text/plain'
    assert not hasattr(part_uri.file, 'bytes')

    # Bytes variant
    file_bytes = FileWithBytes(bytes='aGVsbG8=', name='hello.txt')
    part_bytes = FilePart(kind='file', file=file_bytes)
    assert isinstance(part_bytes.file, FileWithBytes)
    assert part_bytes.file.bytes == 'aGVsbG8='
    assert part_bytes.file.name == 'hello.txt'
    assert not hasattr(part_bytes.file, 'uri')

    # Test deserialization directly
    part_uri_deserialized = FilePart.model_validate(FILE_URI_PART_DATA)
    assert isinstance(part_uri_deserialized.file, FileWithUri)
    assert part_uri_deserialized.file.uri == 'file:///path/to/file.txt'

    part_bytes_deserialized = FilePart.model_validate(FILE_BYTES_PART_DATA)
    assert isinstance(part_bytes_deserialized.file, FileWithBytes)
    assert part_bytes_deserialized.file.bytes == 'aGVsbG8='

    # Invalid - wrong type literal
    with pytest.raises(ValidationError):
        FilePart(kind='text', file=file_uri)  # type: ignore

    FilePart(**FILE_URI_PART_DATA, extra='extra')  # type: ignore


def test_data_part():
    part = DataPart(**DATA_PART_DATA)
    assert part.kind == 'data'
    assert part.data == {'key': 'value'}

    with pytest.raises(ValidationError):
        DataPart(type='data')  # Missing data  # type: ignore


def test_part_root_model():
    # Test deserialization of the Union RootModel
    part_text = Part.model_validate(TEXT_PART_DATA)
    assert isinstance(part_text.root, TextPart)
    assert part_text.root.text == 'Hello'

    part_file = Part.model_validate(FILE_URI_PART_DATA)
    assert isinstance(part_file.root, FilePart)
    assert isinstance(part_file.root.file, FileWithUri)

    part_data = Part.model_validate(DATA_PART_DATA)
    assert isinstance(part_data.root, DataPart)
    assert part_data.root.data == {'key': 'value'}

    # Test serialization
    assert part_text.model_dump(exclude_none=True) == TEXT_PART_DATA
    assert part_file.model_dump(exclude_none=True) == FILE_URI_PART_DATA
    assert part_data.model_dump(exclude_none=True) == DATA_PART_DATA


# --- Test Message and Task ---


def test_message():
    msg = Message(**MINIMAL_MESSAGE_USER)
    assert msg.role == Role.user
    assert len(msg.parts) == 1
    assert isinstance(
        msg.parts[0].root, TextPart
    )  # Access root for RootModel Part
    assert msg.metadata is None

    msg_agent = Message(**AGENT_MESSAGE_WITH_FILE)
    assert msg_agent.role == Role.agent
    assert len(msg_agent.parts) == 2
    assert isinstance(msg_agent.parts[1].root, FilePart)
    assert msg_agent.metadata == {'timestamp': 'now'}

    with pytest.raises(ValidationError):
        Message(
            role='invalid_role',  # type: ignore
            parts=[TEXT_PART_DATA],  # type: ignore
        )  # Invalid enum
    with pytest.raises(ValidationError):
        Message(role=Role.user)  # Missing parts  # type: ignore


def test_task_status():
    status = TaskStatus(**MINIMAL_TASK_STATUS)
    assert status.state == TaskState.submitted
    assert status.message is None
    assert status.timestamp is None

    status_full = TaskStatus(**FULL_TASK_STATUS)
    assert status_full.state == TaskState.working
    assert isinstance(status_full.message, Message)
    assert status_full.timestamp == '2023-10-27T10:00:00Z'

    with pytest.raises(ValidationError):
        TaskStatus(state='invalid_state')  # Invalid enum  # type: ignore


def test_task():
    task = Task(**MINIMAL_TASK)
    assert task.id == 'task-abc'
    assert task.context_id == 'session-xyz'
    assert task.status.state == TaskState.submitted
    assert task.history is None
    assert task.artifacts is None
    assert task.metadata is None

    task_full = Task(**FULL_TASK)
    assert task_full.id == 'task-abc'
    assert task_full.status.state == TaskState.working
    assert task_full.history is not None and len(task_full.history) == 2
    assert isinstance(task_full.history[0], Message)
    assert task_full.artifacts is not None and len(task_full.artifacts) == 1
    assert isinstance(task_full.artifacts[0], Artifact)
    assert task_full.artifacts[0].name == 'result_data'
    assert task_full.metadata == {'priority': 'high'}

    with pytest.raises(ValidationError):
        Task(id='abc', sessionId='xyz')  # Missing status # type: ignore


# --- Test JSON-RPC Structures ---


def test_jsonrpc_error():
    err = JSONRPCError(code=-32600, message='Invalid Request')
    assert err.code == -32600
    assert err.message == 'Invalid Request'
    assert err.data is None

    err_data = JSONRPCError(
        code=-32001, message='Task not found', data={'taskId': '123'}
    )
    assert err_data.code == -32001
    assert err_data.data == {'taskId': '123'}


def test_jsonrpc_request():
    req = JSONRPCRequest(jsonrpc='2.0', method='test_method', id=1)
    assert req.jsonrpc == '2.0'
    assert req.method == 'test_method'
    assert req.id == 1
    assert req.params is None

    req_params = JSONRPCRequest(
        jsonrpc='2.0', method='add', params={'a': 1, 'b': 2}, id='req-1'
    )
    assert req_params.params == {'a': 1, 'b': 2}
    assert req_params.id == 'req-1'

    with pytest.raises(ValidationError):
        JSONRPCRequest(
            jsonrpc='1.0',  # type: ignore
            method='m',
            id=1,
        )  # Wrong version
    with pytest.raises(ValidationError):
        JSONRPCRequest(jsonrpc='2.0', id=1)  # Missing method  # type: ignore


def test_jsonrpc_error_response():
    err_obj = JSONRPCError(**JSONRPC_ERROR_DATA)
    resp = JSONRPCErrorResponse(jsonrpc='2.0', error=err_obj, id='err-1')
    assert resp.jsonrpc == '2.0'
    assert resp.id == 'err-1'
    assert resp.error.code == -32600
    assert resp.error.message == 'Invalid Request'

    with pytest.raises(ValidationError):
        JSONRPCErrorResponse(
            jsonrpc='2.0', id='err-1'
        )  # Missing error # type: ignore


def test_jsonrpc_response_root_model() -> None:
    # Success case
    success_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'result': MINIMAL_TASK,
        'id': 1,
    }
    resp_success = JSONRPCResponse.model_validate(success_data)
    assert isinstance(resp_success.root, SendMessageSuccessResponse)
    assert resp_success.root.result == Task(**MINIMAL_TASK)

    # Error case
    error_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'error': JSONRPC_ERROR_DATA,
        'id': 'err-1',
    }
    resp_error = JSONRPCResponse.model_validate(error_data)
    assert isinstance(resp_error.root, JSONRPCErrorResponse)
    assert resp_error.root.error.code == -32600
    # Note: .model_dump() might serialize the nested error model
    assert resp_error.model_dump(exclude_none=True) == error_data

    # Invalid case (neither success nor error structure)
    with pytest.raises(ValidationError):
        JSONRPCResponse.model_validate({'jsonrpc': '2.0', 'id': 1})


# --- Test Request/Response Wrappers ---


def test_send_message_request() -> None:
    params = MessageSendParams(message=Message(**MINIMAL_MESSAGE_USER))
    req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'message/send',
        'params': params.model_dump(),
        'id': 5,
    }
    req = SendMessageRequest.model_validate(req_data)
    assert req.method == 'message/send'
    assert isinstance(req.params, MessageSendParams)
    assert req.params.message.role == Role.user

    with pytest.raises(ValidationError):  # Wrong method literal
        SendMessageRequest.model_validate(
            {**req_data, 'method': 'wrong/method'}
        )


def test_send_subscribe_request() -> None:
    params = MessageSendParams(message=Message(**MINIMAL_MESSAGE_USER))
    req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'message/stream',
        'params': params.model_dump(),
        'id': 5,
    }
    req = SendStreamingMessageRequest.model_validate(req_data)
    assert req.method == 'message/stream'
    assert isinstance(req.params, MessageSendParams)
    assert req.params.message.role == Role.user

    with pytest.raises(ValidationError):  # Wrong method literal
        SendStreamingMessageRequest.model_validate(
            {**req_data, 'method': 'wrong/method'}
        )


def test_get_task_request() -> None:
    params = TaskQueryParams(id='task-1', history_length=2)
    req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'tasks/get',
        'params': params.model_dump(),
        'id': 5,
    }
    req = GetTaskRequest.model_validate(req_data)
    assert req.method == 'tasks/get'
    assert isinstance(req.params, TaskQueryParams)
    assert req.params.id == 'task-1'
    assert req.params.history_length == 2

    with pytest.raises(ValidationError):  # Wrong method literal
        GetTaskRequest.model_validate({**req_data, 'method': 'wrong/method'})


def test_cancel_task_request() -> None:
    params = TaskIdParams(id='task-1')
    req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'tasks/cancel',
        'params': params.model_dump(),
        'id': 5,
    }
    req = CancelTaskRequest.model_validate(req_data)
    assert req.method == 'tasks/cancel'
    assert isinstance(req.params, TaskIdParams)
    assert req.params.id == 'task-1'

    with pytest.raises(ValidationError):  # Wrong method literal
        CancelTaskRequest.model_validate({**req_data, 'method': 'wrong/method'})


def test_get_task_response() -> None:
    resp_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'result': MINIMAL_TASK,
        'id': 'resp-1',
    }
    resp = GetTaskResponse.model_validate(resp_data)
    assert resp.root.id == 'resp-1'
    assert isinstance(resp.root, GetTaskSuccessResponse)
    assert isinstance(resp.root.result, Task)
    assert resp.root.result.id == 'task-abc'

    with pytest.raises(ValidationError):  # Result is not a Task
        GetTaskResponse.model_validate(
            {'jsonrpc': '2.0', 'result': {'wrong': 'data'}, 'id': 1}
        )

    resp_data_err: dict[str, Any] = {
        'jsonrpc': '2.0',
        'error': JSONRPCError(**TaskNotFoundError().model_dump()),
        'id': 'resp-1',
    }
    resp_err = GetTaskResponse.model_validate(resp_data_err)
    assert resp_err.root.id == 'resp-1'
    assert isinstance(resp_err.root, JSONRPCErrorResponse)
    assert resp_err.root.error is not None
    assert isinstance(resp_err.root.error, JSONRPCError)


def test_send_message_response() -> None:
    resp_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'result': MINIMAL_TASK,
        'id': 'resp-1',
    }
    resp = SendMessageResponse.model_validate(resp_data)
    assert resp.root.id == 'resp-1'
    assert isinstance(resp.root, SendMessageSuccessResponse)
    assert isinstance(resp.root.result, Task)
    assert resp.root.result.id == 'task-abc'

    with pytest.raises(ValidationError):  # Result is not a Task
        SendMessageResponse.model_validate(
            {'jsonrpc': '2.0', 'result': {'wrong': 'data'}, 'id': 1}
        )

    resp_data_err: dict[str, Any] = {
        'jsonrpc': '2.0',
        'error': JSONRPCError(**TaskNotFoundError().model_dump()),
        'id': 'resp-1',
    }
    resp_err = SendMessageResponse.model_validate(resp_data_err)
    assert resp_err.root.id == 'resp-1'
    assert isinstance(resp_err.root, JSONRPCErrorResponse)
    assert resp_err.root.error is not None
    assert isinstance(resp_err.root.error, JSONRPCError)


def test_cancel_task_response() -> None:
    resp_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'result': MINIMAL_TASK,
        'id': 1,
    }
    resp = CancelTaskResponse.model_validate(resp_data)
    assert resp.root.id == 1
    assert isinstance(resp.root, CancelTaskSuccessResponse)
    assert isinstance(resp.root.result, Task)
    assert resp.root.result.id == 'task-abc'

    resp_data_err: dict[str, Any] = {
        'jsonrpc': '2.0',
        'error': JSONRPCError(**TaskNotFoundError().model_dump()),
        'id': 'resp-1',
    }
    resp_err = CancelTaskResponse.model_validate(resp_data_err)
    assert resp_err.root.id == 'resp-1'
    assert isinstance(resp_err.root, JSONRPCErrorResponse)
    assert resp_err.root.error is not None
    assert isinstance(resp_err.root.error, JSONRPCError)


def test_send_message_streaming_status_update_response() -> None:
    task_status_update_event_data: dict[str, Any] = {
        'status': MINIMAL_TASK_STATUS,
        'taskId': '1',
        'context_id': '2',
        'final': False,
        'kind': 'status-update',
    }

    event_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'id': 1,
        'result': task_status_update_event_data,
    }
    response = SendStreamingMessageResponse.model_validate(event_data)
    assert response.root.id == 1
    assert isinstance(response.root, SendStreamingMessageSuccessResponse)
    assert isinstance(response.root.result, TaskStatusUpdateEvent)
    assert response.root.result.status.state == TaskState.submitted
    assert response.root.result.task_id == '1'
    assert not response.root.result.final

    with pytest.raises(
        ValidationError
    ):  # Result is not a TaskStatusUpdateEvent
        SendStreamingMessageResponse.model_validate(
            {'jsonrpc': '2.0', 'result': {'wrong': 'data'}, 'id': 1}
        )

    event_data = {
        'jsonrpc': '2.0',
        'id': 1,
        'result': {**task_status_update_event_data, 'final': True},
    }
    response = SendStreamingMessageResponse.model_validate(event_data)
    assert response.root.id == 1
    assert isinstance(response.root, SendStreamingMessageSuccessResponse)
    assert isinstance(response.root.result, TaskStatusUpdateEvent)
    assert response.root.result.final

    resp_data_err: dict[str, Any] = {
        'jsonrpc': '2.0',
        'error': JSONRPCError(**TaskNotFoundError().model_dump()),
        'id': 'resp-1',
    }
    resp_err = SendStreamingMessageResponse.model_validate(resp_data_err)
    assert resp_err.root.id == 'resp-1'
    assert isinstance(resp_err.root, JSONRPCErrorResponse)
    assert resp_err.root.error is not None
    assert isinstance(resp_err.root.error, JSONRPCError)


def test_send_message_streaming_artifact_update_response() -> None:
    text_part = TextPart(**TEXT_PART_DATA)
    data_part = DataPart(**DATA_PART_DATA)
    artifact = Artifact(
        artifact_id='artifact-123',
        name='result_data',
        parts=[Part(root=text_part), Part(root=data_part)],
    )
    task_artifact_update_event_data: dict[str, Any] = {
        'artifact': artifact,
        'taskId': 'task_id',
        'context_id': '2',
        'append': False,
        'lastChunk': True,
        'kind': 'artifact-update',
    }
    event_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'id': 1,
        'result': task_artifact_update_event_data,
    }
    response = SendStreamingMessageResponse.model_validate(event_data)
    assert response.root.id == 1
    assert isinstance(response.root, SendStreamingMessageSuccessResponse)
    assert isinstance(response.root.result, TaskArtifactUpdateEvent)
    assert response.root.result.artifact.artifact_id == 'artifact-123'
    assert response.root.result.artifact.name == 'result_data'
    assert response.root.result.task_id == 'task_id'
    assert not response.root.result.append
    assert response.root.result.last_chunk
    assert len(response.root.result.artifact.parts) == 2
    assert isinstance(response.root.result.artifact.parts[0].root, TextPart)
    assert isinstance(response.root.result.artifact.parts[1].root, DataPart)


def test_set_task_push_notification_response() -> None:
    task_push_config = TaskPushNotificationConfig(
        task_id='t2',
        push_notification_config=PushNotificationConfig(
            url='https://example.com', token='token'
        ),
    )
    resp_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'result': task_push_config.model_dump(),
        'id': 1,
    }
    resp = SetTaskPushNotificationConfigResponse.model_validate(resp_data)
    assert resp.root.id == 1
    assert isinstance(resp.root, SetTaskPushNotificationConfigSuccessResponse)
    assert isinstance(resp.root.result, TaskPushNotificationConfig)
    assert resp.root.result.task_id == 't2'
    assert (
        resp.root.result.push_notification_config.url == 'https://example.com'
    )
    assert resp.root.result.push_notification_config.token == 'token'
    assert resp.root.result.push_notification_config.authentication is None

    auth_info_dict: dict[str, Any] = {
        'schemes': ['Bearer', 'Basic'],
        'credentials': 'user:pass',
    }
    task_push_config.push_notification_config.authentication = (
        PushNotificationAuthenticationInfo(**auth_info_dict)
    )
    resp_data = {
        'jsonrpc': '2.0',
        'result': task_push_config.model_dump(),
        'id': 1,
    }
    resp = SetTaskPushNotificationConfigResponse.model_validate(resp_data)
    assert isinstance(resp.root, SetTaskPushNotificationConfigSuccessResponse)
    assert resp.root.result.push_notification_config.authentication is not None
    assert resp.root.result.push_notification_config.authentication.schemes == [
        'Bearer',
        'Basic',
    ]
    assert (
        resp.root.result.push_notification_config.authentication.credentials
        == 'user:pass'
    )

    resp_data_err: dict[str, Any] = {
        'jsonrpc': '2.0',
        'error': JSONRPCError(**TaskNotFoundError().model_dump()),
        'id': 'resp-1',
    }
    resp_err = SetTaskPushNotificationConfigResponse.model_validate(
        resp_data_err
    )
    assert resp_err.root.id == 'resp-1'
    assert isinstance(resp_err.root, JSONRPCErrorResponse)
    assert resp_err.root.error is not None
    assert isinstance(resp_err.root.error, JSONRPCError)


def test_get_task_push_notification_response() -> None:
    task_push_config = TaskPushNotificationConfig(
        task_id='t2',
        push_notification_config=PushNotificationConfig(
            url='https://example.com', token='token'
        ),
    )
    resp_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'result': task_push_config.model_dump(),
        'id': 1,
    }
    resp = GetTaskPushNotificationConfigResponse.model_validate(resp_data)
    assert resp.root.id == 1
    assert isinstance(resp.root, GetTaskPushNotificationConfigSuccessResponse)
    assert isinstance(resp.root.result, TaskPushNotificationConfig)
    assert resp.root.result.task_id == 't2'
    assert (
        resp.root.result.push_notification_config.url == 'https://example.com'
    )
    assert resp.root.result.push_notification_config.token == 'token'
    assert resp.root.result.push_notification_config.authentication is None

    auth_info_dict: dict[str, Any] = {
        'schemes': ['Bearer', 'Basic'],
        'credentials': 'user:pass',
    }
    task_push_config.push_notification_config.authentication = (
        PushNotificationAuthenticationInfo(**auth_info_dict)
    )
    resp_data = {
        'jsonrpc': '2.0',
        'result': task_push_config.model_dump(),
        'id': 1,
    }
    resp = GetTaskPushNotificationConfigResponse.model_validate(resp_data)
    assert isinstance(resp.root, GetTaskPushNotificationConfigSuccessResponse)
    assert resp.root.result.push_notification_config.authentication is not None
    assert resp.root.result.push_notification_config.authentication.schemes == [
        'Bearer',
        'Basic',
    ]
    assert (
        resp.root.result.push_notification_config.authentication.credentials
        == 'user:pass'
    )

    resp_data_err: dict[str, Any] = {
        'jsonrpc': '2.0',
        'error': JSONRPCError(**TaskNotFoundError().model_dump()),
        'id': 'resp-1',
    }
    resp_err = GetTaskPushNotificationConfigResponse.model_validate(
        resp_data_err
    )
    assert resp_err.root.id == 'resp-1'
    assert isinstance(resp_err.root, JSONRPCErrorResponse)
    assert resp_err.root.error is not None
    assert isinstance(resp_err.root.error, JSONRPCError)


# --- Test A2ARequest Root Model ---


def test_a2a_request_root_model() -> None:
    # SendMessageRequest case
    send_params = MessageSendParams(message=Message(**MINIMAL_MESSAGE_USER))
    send_req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'message/send',
        'params': send_params.model_dump(),
        'id': 1,
    }
    a2a_req_send = A2ARequest.model_validate(send_req_data)
    assert isinstance(a2a_req_send.root, SendMessageRequest)
    assert a2a_req_send.root.method == 'message/send'

    # SendStreamingMessageRequest case
    send_subs_req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'message/stream',
        'params': send_params.model_dump(),
        'id': 1,
    }
    a2a_req_send_subs = A2ARequest.model_validate(send_subs_req_data)
    assert isinstance(a2a_req_send_subs.root, SendStreamingMessageRequest)
    assert a2a_req_send_subs.root.method == 'message/stream'

    # GetTaskRequest case
    get_params = TaskQueryParams(id='t2')
    get_req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'tasks/get',
        'params': get_params.model_dump(),
        'id': 2,
    }
    a2a_req_get = A2ARequest.model_validate(get_req_data)
    assert isinstance(a2a_req_get.root, GetTaskRequest)
    assert a2a_req_get.root.method == 'tasks/get'

    # CancelTaskRequest case
    id_params = TaskIdParams(id='t2')
    cancel_req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'tasks/cancel',
        'params': id_params.model_dump(),
        'id': 2,
    }
    a2a_req_cancel = A2ARequest.model_validate(cancel_req_data)
    assert isinstance(a2a_req_cancel.root, CancelTaskRequest)
    assert a2a_req_cancel.root.method == 'tasks/cancel'

    # SetTaskPushNotificationConfigRequest
    task_push_config = TaskPushNotificationConfig(
        task_id='t2',
        push_notification_config=PushNotificationConfig(
            url='https://example.com', token='token'
        ),
    )
    set_push_notif_req_data: dict[str, Any] = {
        'id': 1,
        'jsonrpc': '2.0',
        'method': 'tasks/pushNotificationConfig/set',
        'params': task_push_config.model_dump(),
    }
    a2a_req_set_push_req = A2ARequest.model_validate(set_push_notif_req_data)
    assert isinstance(
        a2a_req_set_push_req.root, SetTaskPushNotificationConfigRequest
    )
    assert isinstance(
        a2a_req_set_push_req.root.params, TaskPushNotificationConfig
    )
    assert (
        a2a_req_set_push_req.root.method == 'tasks/pushNotificationConfig/set'
    )

    # GetTaskPushNotificationConfigRequest
    id_params = TaskIdParams(id='t2')
    get_push_notif_req_data: dict[str, Any] = {
        'id': 1,
        'jsonrpc': '2.0',
        'method': 'tasks/pushNotificationConfig/get',
        'params': id_params.model_dump(),
    }
    a2a_req_get_push_req = A2ARequest.model_validate(get_push_notif_req_data)
    assert isinstance(
        a2a_req_get_push_req.root, GetTaskPushNotificationConfigRequest
    )
    assert isinstance(a2a_req_get_push_req.root.params, TaskIdParams)
    assert (
        a2a_req_get_push_req.root.method == 'tasks/pushNotificationConfig/get'
    )

    # TaskResubscriptionRequest
    task_resubscribe_req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'tasks/resubscribe',
        'params': id_params.model_dump(),
        'id': 2,
    }
    a2a_req_task_resubscribe_req = A2ARequest.model_validate(
        task_resubscribe_req_data
    )
    assert isinstance(
        a2a_req_task_resubscribe_req.root, TaskResubscriptionRequest
    )
    assert isinstance(a2a_req_task_resubscribe_req.root.params, TaskIdParams)
    assert a2a_req_task_resubscribe_req.root.method == 'tasks/resubscribe'

    # GetAuthenticatedExtendedCardRequest
    get_auth_card_req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'agent/getAuthenticatedExtendedCard',
        'id': 2,
    }
    a2a_req_get_auth_card = A2ARequest.model_validate(get_auth_card_req_data)
    assert isinstance(
        a2a_req_get_auth_card.root, GetAuthenticatedExtendedCardRequest
    )
    assert (
        a2a_req_get_auth_card.root.method
        == 'agent/getAuthenticatedExtendedCard'
    )

    # Invalid method case
    invalid_req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'invalid/method',
        'params': {},
        'id': 3,
    }
    with pytest.raises(ValidationError):
        A2ARequest.model_validate(invalid_req_data)


def test_a2a_request_root_model_id_validation() -> None:
    # SendMessageRequest case
    send_params = MessageSendParams(message=Message(**MINIMAL_MESSAGE_USER))
    send_req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'message/send',
        'params': send_params.model_dump(),
    }
    with pytest.raises(ValidationError):
        A2ARequest.model_validate(send_req_data)  # missing id

    # SendStreamingMessageRequest case
    send_subs_req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'message/stream',
        'params': send_params.model_dump(),
    }
    with pytest.raises(ValidationError):
        A2ARequest.model_validate(send_subs_req_data)  # missing id

    # GetTaskRequest case
    get_params = TaskQueryParams(id='t2')
    get_req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'tasks/get',
        'params': get_params.model_dump(),
    }
    with pytest.raises(ValidationError):
        A2ARequest.model_validate(get_req_data)  # missing id

    # CancelTaskRequest case
    id_params = TaskIdParams(id='t2')
    cancel_req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'tasks/cancel',
        'params': id_params.model_dump(),
    }
    with pytest.raises(ValidationError):
        A2ARequest.model_validate(cancel_req_data)  # missing id

    # SetTaskPushNotificationConfigRequest
    task_push_config = TaskPushNotificationConfig(
        task_id='t2',
        push_notification_config=PushNotificationConfig(
            url='https://example.com', token='token'
        ),
    )
    set_push_notif_req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'tasks/pushNotificationConfig/set',
        'params': task_push_config.model_dump(),
        'task_id': 2,
    }
    with pytest.raises(ValidationError):
        A2ARequest.model_validate(set_push_notif_req_data)  # missing id

    # GetTaskPushNotificationConfigRequest
    id_params = TaskIdParams(id='t2')
    get_push_notif_req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'tasks/pushNotificationConfig/get',
        'params': id_params.model_dump(),
        'task_id': 2,
    }
    with pytest.raises(ValidationError):
        A2ARequest.model_validate(get_push_notif_req_data)

    # TaskResubscriptionRequest
    task_resubscribe_req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'tasks/resubscribe',
        'params': id_params.model_dump(),
    }
    with pytest.raises(ValidationError):
        A2ARequest.model_validate(task_resubscribe_req_data)

    # GetAuthenticatedExtendedCardRequest
    get_auth_card_req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'agent/getAuthenticatedExtendedCard',
    }
    with pytest.raises(ValidationError):
        A2ARequest.model_validate(get_auth_card_req_data)  # missing id


def test_content_type_not_supported_error():
    # Test ContentTypeNotSupportedError
    err = ContentTypeNotSupportedError(
        code=-32005, message='Incompatible content types'
    )
    assert err.code == -32005
    assert err.message == 'Incompatible content types'
    assert err.data is None

    with pytest.raises(ValidationError):  # Wrong code
        ContentTypeNotSupportedError(
            code=-32000,  # type: ignore
            message='Incompatible content types',
        )

    ContentTypeNotSupportedError(
        code=-32005,
        message='Incompatible content types',
        extra='extra',  # type: ignore
    )


def test_task_not_found_error():
    # Test TaskNotFoundError
    err2 = TaskNotFoundError(
        code=-32001, message='Task not found', data={'taskId': 'abc'}
    )
    assert err2.code == -32001
    assert err2.message == 'Task not found'
    assert err2.data == {'taskId': 'abc'}

    with pytest.raises(ValidationError):  # Wrong code
        TaskNotFoundError(code=-32000, message='Task not found')  # type: ignore

    TaskNotFoundError(code=-32001, message='Task not found', extra='extra')  # type: ignore


def test_push_notification_not_supported_error():
    # Test PushNotificationNotSupportedError
    err3 = PushNotificationNotSupportedError(data={'taskId': 'abc'})
    assert err3.code == -32003
    assert err3.message == 'Push Notification is not supported'
    assert err3.data == {'taskId': 'abc'}

    with pytest.raises(ValidationError):  # Wrong code
        PushNotificationNotSupportedError(
            code=-32000,  # type: ignore
            message='Push Notification is not available',
        )
    with pytest.raises(ValidationError):  # Extra field
        PushNotificationNotSupportedError(
            code=-32001,
            message='Push Notification is not available',
            extra='extra',  # type: ignore
        )


def test_internal_error():
    # Test InternalError
    err_internal = InternalError()
    assert err_internal.code == -32603
    assert err_internal.message == 'Internal error'
    assert err_internal.data is None

    err_internal_data = InternalError(
        code=-32603, message='Internal error', data={'details': 'stack trace'}
    )
    assert err_internal_data.data == {'details': 'stack trace'}

    with pytest.raises(ValidationError):  # Wrong code
        InternalError(code=-32000, message='Internal error')  # type: ignore

    InternalError(code=-32603, message='Internal error', extra='extra')  # type: ignore


def test_invalid_params_error():
    # Test InvalidParamsError
    err_params = InvalidParamsError()
    assert err_params.code == -32602
    assert err_params.message == 'Invalid parameters'
    assert err_params.data is None

    err_params_data = InvalidParamsError(
        code=-32602, message='Invalid parameters', data=['param1', 'param2']
    )
    assert err_params_data.data == ['param1', 'param2']

    with pytest.raises(ValidationError):  # Wrong code
        InvalidParamsError(code=-32000, message='Invalid parameters')  # type: ignore

    InvalidParamsError(
        code=-32602,
        message='Invalid parameters',
        extra='extra',  # type: ignore
    )


def test_invalid_request_error():
    # Test InvalidRequestError
    err_request = InvalidRequestError()
    assert err_request.code == -32600
    assert err_request.message == 'Request payload validation error'
    assert err_request.data is None

    err_request_data = InvalidRequestError(data={'field': 'missing'})
    assert err_request_data.data == {'field': 'missing'}

    with pytest.raises(ValidationError):  # Wrong code
        InvalidRequestError(
            code=-32000,  # type: ignore
            message='Request payload validation error',
        )

    InvalidRequestError(
        code=-32600,
        message='Request payload validation error',
        extra='extra',  # type: ignore
    )  # type: ignore


def test_json_parse_error():
    # Test JSONParseError
    err_parse = JSONParseError(code=-32700, message='Invalid JSON payload')
    assert err_parse.code == -32700
    assert err_parse.message == 'Invalid JSON payload'
    assert err_parse.data is None

    err_parse_data = JSONParseError(data={'foo': 'bar'})  # Explicit None data
    assert err_parse_data.data == {'foo': 'bar'}

    with pytest.raises(ValidationError):  # Wrong code
        JSONParseError(code=-32000, message='Invalid JSON payload')  # type: ignore

    JSONParseError(code=-32700, message='Invalid JSON payload', extra='extra')  # type: ignore


def test_method_not_found_error():
    # Test MethodNotFoundError
    err_parse = MethodNotFoundError()
    assert err_parse.code == -32601
    assert err_parse.message == 'Method not found'
    assert err_parse.data is None

    err_parse_data = JSONParseError(data={'foo': 'bar'})
    assert err_parse_data.data == {'foo': 'bar'}

    with pytest.raises(ValidationError):  # Wrong code
        JSONParseError(code=-32000, message='Invalid JSON payload')  # type: ignore

    JSONParseError(code=-32700, message='Invalid JSON payload', extra='extra')  # type: ignore


def test_task_not_cancelable_error():
    # Test TaskNotCancelableError
    err_parse = TaskNotCancelableError()
    assert err_parse.code == -32002
    assert err_parse.message == 'Task cannot be canceled'
    assert err_parse.data is None

    err_parse_data = JSONParseError(
        data={'foo': 'bar'}, message='not cancelled'
    )
    assert err_parse_data.data == {'foo': 'bar'}
    assert err_parse_data.message == 'not cancelled'

    with pytest.raises(ValidationError):  # Wrong code
        JSONParseError(code=-32000, message='Task cannot be canceled')  # type: ignore

    JSONParseError(
        code=-32700,
        message='Task cannot be canceled',
        extra='extra',  # type: ignore
    )


def test_unsupported_operation_error():
    # Test UnsupportedOperationError
    err_parse = UnsupportedOperationError()
    assert err_parse.code == -32004
    assert err_parse.message == 'This operation is not supported'
    assert err_parse.data is None

    err_parse_data = JSONParseError(
        data={'foo': 'bar'}, message='not supported'
    )
    assert err_parse_data.data == {'foo': 'bar'}
    assert err_parse_data.message == 'not supported'

    with pytest.raises(ValidationError):  # Wrong code
        JSONParseError(code=-32000, message='Unsupported')  # type: ignore

    JSONParseError(code=-32700, message='Unsupported', extra='extra')  # type: ignore


# --- Test TaskIdParams ---


def test_task_id_params_valid():
    """Tests successful validation of TaskIdParams."""
    # Minimal valid data
    params_min = TaskIdParams(**MINIMAL_TASK_ID_PARAMS)
    assert params_min.id == 'task-123'
    assert params_min.metadata is None

    # Full valid data
    params_full = TaskIdParams(**FULL_TASK_ID_PARAMS)
    assert params_full.id == 'task-456'
    assert params_full.metadata == {'source': 'test'}


def test_task_id_params_invalid():
    """Tests validation errors for TaskIdParams."""
    # Missing required 'id' field
    with pytest.raises(ValidationError) as excinfo_missing:
        TaskIdParams()  # type: ignore
    assert 'id' in str(
        excinfo_missing.value
    )  # Check that 'id' is mentioned in the error

    invalid_data = MINIMAL_TASK_ID_PARAMS.copy()
    invalid_data['extra_field'] = 'allowed'
    TaskIdParams(**invalid_data)  # type: ignore

    # Incorrect type for metadata (should be dict)
    invalid_metadata_type = {'id': 'task-789', 'metadata': 'not_a_dict'}
    with pytest.raises(ValidationError) as excinfo_type:
        TaskIdParams(**invalid_metadata_type)  # type: ignore
    assert 'metadata' in str(
        excinfo_type.value
    )  # Check that 'metadata' is mentioned


def test_task_push_notification_config() -> None:
    """Tests successful validation of TaskPushNotificationConfig."""
    auth_info_dict: dict[str, Any] = {
        'schemes': ['Bearer', 'Basic'],
        'credentials': 'user:pass',
    }
    auth_info = PushNotificationAuthenticationInfo(**auth_info_dict)

    push_notification_config = PushNotificationConfig(
        url='https://example.com', token='token', authentication=auth_info
    )
    assert push_notification_config.url == 'https://example.com'
    assert push_notification_config.token == 'token'
    assert push_notification_config.authentication == auth_info

    task_push_notification_config = TaskPushNotificationConfig(
        task_id='task-123', push_notification_config=push_notification_config
    )
    assert task_push_notification_config.task_id == 'task-123'
    assert (
        task_push_notification_config.push_notification_config
        == push_notification_config
    )
    assert task_push_notification_config.model_dump(exclude_none=True) == {
        'taskId': 'task-123',
        'pushNotificationConfig': {
            'url': 'https://example.com',
            'token': 'token',
            'authentication': {
                'schemes': ['Bearer', 'Basic'],
                'credentials': 'user:pass',
            },
        },
    }


def test_jsonrpc_message_valid():
    """Tests successful validation of JSONRPCMessage."""
    # With string ID
    msg_str_id = JSONRPCMessage(jsonrpc='2.0', id='req-1')
    assert msg_str_id.jsonrpc == '2.0'
    assert msg_str_id.id == 'req-1'

    # With integer ID (will be coerced to float by Pydantic for JSON number compatibility)
    msg_int_id = JSONRPCMessage(jsonrpc='2.0', id=1)
    assert msg_int_id.jsonrpc == '2.0'
    assert (
        msg_int_id.id == 1
    )  # Pydantic v2 keeps int if possible, but float is in type hint

    rpc_message = JSONRPCMessage(id=1)
    assert rpc_message.jsonrpc == '2.0'
    assert rpc_message.id == 1


def test_jsonrpc_message_invalid():
    """Tests validation errors for JSONRPCMessage."""
    # Incorrect jsonrpc version
    with pytest.raises(ValidationError):
        JSONRPCMessage(jsonrpc='1.0', id=1)  # type: ignore

    JSONRPCMessage(jsonrpc='2.0', id=1, extra_field='extra')  # type: ignore

    # Invalid ID type (e.g., list) - Pydantic should catch this based on type hints
    with pytest.raises(ValidationError):
        JSONRPCMessage(jsonrpc='2.0', id=[1, 2])  # type: ignore


def test_file_base_valid():
    """Tests successful validation of FileBase."""
    # No optional fields
    base1 = FileBase()
    assert base1.mime_type is None
    assert base1.name is None

    # With mime_type only
    base2 = FileBase(mime_type='image/png')
    assert base2.mime_type == 'image/png'
    assert base2.name is None

    # With name only
    base3 = FileBase(name='document.pdf')
    assert base3.mime_type is None
    assert base3.name == 'document.pdf'

    # With both fields
    base4 = FileBase(mime_type='application/json', name='data.json')
    assert base4.mime_type == 'application/json'
    assert base4.name == 'data.json'


def test_file_base_invalid():
    """Tests validation errors for FileBase."""
    FileBase(extra_field='allowed')  # type: ignore

    # Incorrect type for mime_type
    with pytest.raises(ValidationError) as excinfo_type_mime:
        FileBase(mime_type=123)  # type: ignore
    assert 'mime_type' in str(excinfo_type_mime.value)

    # Incorrect type for name
    with pytest.raises(ValidationError) as excinfo_type_name:
        FileBase(name=['list', 'is', 'wrong'])  # type: ignore
    assert 'name' in str(excinfo_type_name.value)


def test_part_base_valid() -> None:
    """Tests successful validation of PartBase."""
    # No optional fields (metadata is None)
    base1 = PartBase()
    assert base1.metadata is None

    # With metadata
    meta_data: dict[str, Any] = {'source': 'test', 'timestamp': 12345}
    base2 = PartBase(metadata=meta_data)
    assert base2.metadata == meta_data


def test_part_base_invalid():
    """Tests validation errors for PartBase."""
    PartBase(extra_field='allowed')  # type: ignore

    # Incorrect type for metadata (should be dict)
    with pytest.raises(ValidationError) as excinfo_type:
        PartBase(metadata='not_a_dict')  # type: ignore
    assert 'metadata' in str(excinfo_type.value)


def test_a2a_error_validation_and_serialization() -> None:
    """Tests validation and serialization of the A2AError RootModel."""

    # 1. Test JSONParseError
    json_parse_instance = JSONParseError()
    json_parse_data = json_parse_instance.model_dump(exclude_none=True)
    a2a_err_parse = A2AError.model_validate(json_parse_data)
    assert isinstance(a2a_err_parse.root, JSONParseError)

    # 2. Test InvalidRequestError
    invalid_req_instance = InvalidRequestError()
    invalid_req_data = invalid_req_instance.model_dump(exclude_none=True)
    a2a_err_invalid_req = A2AError.model_validate(invalid_req_data)
    assert isinstance(a2a_err_invalid_req.root, InvalidRequestError)

    # 3. Test MethodNotFoundError
    method_not_found_instance = MethodNotFoundError()
    method_not_found_data = method_not_found_instance.model_dump(
        exclude_none=True
    )
    a2a_err_method = A2AError.model_validate(method_not_found_data)
    assert isinstance(a2a_err_method.root, MethodNotFoundError)

    # 4. Test InvalidParamsError
    invalid_params_instance = InvalidParamsError()
    invalid_params_data = invalid_params_instance.model_dump(exclude_none=True)
    a2a_err_params = A2AError.model_validate(invalid_params_data)
    assert isinstance(a2a_err_params.root, InvalidParamsError)

    # 5. Test InternalError
    internal_err_instance = InternalError()
    internal_err_data = internal_err_instance.model_dump(exclude_none=True)
    a2a_err_internal = A2AError.model_validate(internal_err_data)
    assert isinstance(a2a_err_internal.root, InternalError)

    # 6. Test TaskNotFoundError
    task_not_found_instance = TaskNotFoundError(data={'taskId': 't1'})
    task_not_found_data = task_not_found_instance.model_dump(exclude_none=True)
    a2a_err_task_nf = A2AError.model_validate(task_not_found_data)
    assert isinstance(a2a_err_task_nf.root, TaskNotFoundError)

    # 7. Test TaskNotCancelableError
    task_not_cancelable_instance = TaskNotCancelableError()
    task_not_cancelable_data = task_not_cancelable_instance.model_dump(
        exclude_none=True
    )
    a2a_err_task_nc = A2AError.model_validate(task_not_cancelable_data)
    assert isinstance(a2a_err_task_nc.root, TaskNotCancelableError)

    # 8. Test PushNotificationNotSupportedError
    push_not_supported_instance = PushNotificationNotSupportedError()
    push_not_supported_data = push_not_supported_instance.model_dump(
        exclude_none=True
    )
    a2a_err_push_ns = A2AError.model_validate(push_not_supported_data)
    assert isinstance(a2a_err_push_ns.root, PushNotificationNotSupportedError)

    # 9. Test UnsupportedOperationError
    unsupported_op_instance = UnsupportedOperationError()
    unsupported_op_data = unsupported_op_instance.model_dump(exclude_none=True)
    a2a_err_unsupported = A2AError.model_validate(unsupported_op_data)
    assert isinstance(a2a_err_unsupported.root, UnsupportedOperationError)

    # 10. Test ContentTypeNotSupportedError
    content_type_err_instance = ContentTypeNotSupportedError()
    content_type_err_data = content_type_err_instance.model_dump(
        exclude_none=True
    )
    a2a_err_content = A2AError.model_validate(content_type_err_data)
    assert isinstance(a2a_err_content.root, ContentTypeNotSupportedError)

    # 11. Test invalid data (doesn't match any known error code/structure)
    invalid_data: dict[str, Any] = {'code': -99999, 'message': 'Unknown error'}
    with pytest.raises(ValidationError):
        A2AError.model_validate(invalid_data)


def test_subclass_enums() -> None:
    """validate subtype enum types"""
    assert In.cookie == 'cookie'

    assert Role.user == 'user'

    assert TaskState.working == 'working'


def test_get_task_push_config_params() -> None:
    """Tests successful validation of GetTaskPushNotificationConfigParams."""
    # Minimal valid data
    params = {'id': 'task-1234'}
    TaskIdParams.model_validate(params)
    GetTaskPushNotificationConfigParams.model_validate(params)


def test_use_get_task_push_notification_params_for_request() -> None:
    # GetTaskPushNotificationConfigRequest
    get_push_notif_req_data: dict[str, Any] = {
        'id': 1,
        'jsonrpc': '2.0',
        'method': 'tasks/pushNotificationConfig/get',
        'params': {'id': 'task-1234', 'pushNotificationConfigId': 'c1'},
    }
    a2a_req_get_push_req = A2ARequest.model_validate(get_push_notif_req_data)
    assert isinstance(
        a2a_req_get_push_req.root, GetTaskPushNotificationConfigRequest
    )
    assert isinstance(
        a2a_req_get_push_req.root.params, GetTaskPushNotificationConfigParams
    )
    assert (
        a2a_req_get_push_req.root.method == 'tasks/pushNotificationConfig/get'
    )


def test_camelCase_access_raises_attribute_error() -> None:
    """
    Tests that accessing or setting fields via their camelCase alias
    raises an AttributeError.
    """
    skill = AgentSkill(
        id='hello_world',
        name='Returns hello world',
        description='just returns hello world',
        tags=['hello world'],
        examples=['hi', 'hello world'],
    )

    # Initialization with camelCase still works due to Pydantic's populate_by_name config
    agent_card = AgentCard(
        name='Hello World Agent',
        description='Just a hello world agent',
        url='http://localhost:9999/',
        version='1.0.0',
        defaultInputModes=['text'],  # type: ignore
        defaultOutputModes=['text'],  # type: ignore
        capabilities=AgentCapabilities(streaming=True),
        skills=[skill],
        supportsAuthenticatedExtendedCard=True,  # type: ignore
    )

    # --- Test that using camelCase aliases raises errors ---

    # Test setting an attribute via camelCase alias raises AttributeError
    with pytest.raises(
        ValueError,
        match='"AgentCard" object has no field "supportsAuthenticatedExtendedCard"',
    ):
        agent_card.supportsAuthenticatedExtendedCard = False

    # Test getting an attribute via camelCase alias raises AttributeError
    with pytest.raises(
        AttributeError,
        match="'AgentCard' object has no attribute 'defaultInputModes'",
    ):
        _ = agent_card.defaultInputModes

    # --- Test that using snake_case names works correctly ---

    # The value should be unchanged because the camelCase setattr failed
    assert agent_card.supports_authenticated_extended_card is True

    # Now, set it correctly using the snake_case name
    agent_card.supports_authenticated_extended_card = False
    assert agent_card.supports_authenticated_extended_card is False

    # Get the attribute correctly using the snake_case name
    default_input_modes = agent_card.default_input_modes
    assert default_input_modes == ['text']
    assert agent_card.default_input_modes == ['text']


def test_get_authenticated_extended_card_request() -> None:
    req_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'method': 'agent/getAuthenticatedExtendedCard',
        'id': 5,
    }
    req = GetAuthenticatedExtendedCardRequest.model_validate(req_data)
    assert req.method == 'agent/getAuthenticatedExtendedCard'
    assert req.id == 5
    # This request has no params, so we don't check for that.

    with pytest.raises(ValidationError):  # Wrong method literal
        GetAuthenticatedExtendedCardRequest.model_validate(
            {**req_data, 'method': 'wrong/method'}
        )

    with pytest.raises(ValidationError):  # Missing id
        GetAuthenticatedExtendedCardRequest.model_validate(
            {'jsonrpc': '2.0', 'method': 'agent/getAuthenticatedExtendedCard'}
        )


def test_get_authenticated_extended_card_response() -> None:
    resp_data: dict[str, Any] = {
        'jsonrpc': '2.0',
        'result': MINIMAL_AGENT_CARD,
        'id': 'resp-1',
    }
    resp = GetAuthenticatedExtendedCardResponse.model_validate(resp_data)
    assert resp.root.id == 'resp-1'
    assert isinstance(resp.root, GetAuthenticatedExtendedCardSuccessResponse)
    assert isinstance(resp.root.result, AgentCard)
    assert resp.root.result.name == 'TestAgent'

    with pytest.raises(ValidationError):  # Result is not an AgentCard
        GetAuthenticatedExtendedCardResponse.model_validate(
            {'jsonrpc': '2.0', 'result': {'wrong': 'data'}, 'id': 1}
        )

    resp_data_err: dict[str, Any] = {
        'jsonrpc': '2.0',
        'error': JSONRPCError(**TaskNotFoundError().model_dump()),
        'id': 'resp-1',
    }
    resp_err = GetAuthenticatedExtendedCardResponse.model_validate(
        resp_data_err
    )
    assert resp_err.root.id == 'resp-1'
    assert isinstance(resp_err.root, JSONRPCErrorResponse)
    assert resp_err.root.error is not None
    assert isinstance(resp_err.root.error, JSONRPCError)

